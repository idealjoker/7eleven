#!/usr/bin/env perl
#======================================================================
#                    U T I L I T I E S / E N C O D E _ D M D _ B I T P L A N E 
#                    doc: Fri Jan  2 10:08:34 2026
#                    dlm: Wed Feb  4 14:44:44 2026
#                    (c) 2026 idealjoker@mailbox.org
#                    uE-Info: 41 49 NIL 0 0 72 2 2 4 NIL ofnI
#======================================================================

# HISTORY:
# Jan  2, 2026: - created
# Jan  3, 2026: - made work
# Jan  8, 2026: - improved to specify brigtness range
#				- improved usage errors
# Jan  9, 2026: - minor improvement with -v 1 output
#				- made -v0 default
#				- BUG: never produced black
# Jan 10, 2026: - BUG: forgot to scale input image intensities
# Jan 12, 2026: - added RELEASE NOTES
#				- added encoding for new UVW bitplanes
#				- BUG: level 3 was not in U
#				- added -d)ither level 1 to try to decrease
#				  flicker; this completely messes up compression
#				> but it is spectacularly successful!
# Jan 14, 2026: - renamed dither to -i)nterlace <method>
#				- implement column-wise interleaving to try to recover
#				  compression
# Jan 15, 2026: - since this does NOT improve compression, I made
#				  -i0 default and use -i to change
# Jan 16, 2026: - added -s, -e, -Q
# Jan 17, 2026: - added 5th brightness level (half tone)
#				- BUG: level 3/5 did not appear on bitplane W
# Jan 28, 2026: - started implementing gamma correction (-g)
# Jan 29, 2026: - made gamma correction work
#				- BUG: gamma correction -s was working wrong way round
#				- BUG: both now wrong way round
#				- replaced -l5 -g1 by -h
# Jan 30, 2026: - added reduced level output warning
#				- added level limit output for debugging
# Feb  1, 2026: - added 7-level bitplanes ABCD
# Feb  4, 2026: - BUG: 7-level encoding was wrong
# HISTORY END

# RELEASE NOTES:
#	- recommendations:
#		driver 		-l5 (better than -h)
#		contrast	orig, -s stretched, -e histogram equalized (may reduce levels)
#		gamma		-g0.57 nominal, increase to darken image
#	- gamma correction
#		- file_gamma * decoding_gamma * display_gamma = viewing_gamma
#		- see [https://www.w3.org/TR/PNG-GammaAppendix.html]
#			plasma DMD 		display_gamma 	= 1.0 	(assumed)
#			source image 	file_gamma		= 2.2 	(assumed)
#							viewing_gamma	= 1.25 	(assumed)
#			-g			    decoding_gamma	= 0.57 	(calculated)
#	- 5-level half-tone driver:
#		- with -h, 5-level driver is enabled and 2nd brightest level is treated as half-tone 
#			- brightness : 0 1 2 2.5 3
#			- pixel value: 0 1 2 3   4
#		- requires at least 8 input levels
#	- This tool requires the Imager PERL library. On a Mac, tis can be installed with the
#     following commands:
#		$ brew install pkg-config libpng jpeg giflib
#		$ cpan Imager

use Getopt::Std;
use strict;
use warnings;
use Imager;

$0 =~ s@^.*/(.*)$@$1@;

#----------------------------------------------------------------------
# Usage
#----------------------------------------------------------------------

die("Usage: $0 \n" .
		"\t[-v)erbosity <n[0]>] [-Q)uiet (no code output)]\n" .
		"\t[brightness-l)evels <n[4]>] [-h)alftone 5-level driver]\n" .
		"\t[apply -g)amma <correction>\n" .
		"\t[apply constrast-s)tretching]\n" .
		"\t[apply histogram-e)qualization\n" .
		"\t[use alternate -i)nterlace <method[0:none,1:cols,2:rows]>]\n" .
		"\t\t<bitplane> <image file>\n")
	        unless (getopts('g:hei:l:Qsv:') && @ARGV==2);

my $bitplane 	= $ARGV[0];
my $image_file	= $ARGV[1];

our $opt_Q;
our $opt_s;
our $opt_e;
our $opt_g;
our $opt_h;
our $opt_l;
our $opt_v =  0 unless defined($opt_v);
our $opt_i = -1 unless defined($opt_i);

if (defined($opt_l)) {
	die("$0: invalid option combination <-l $opt_l -h>\n")
		if $opt_h;
} elsif ($opt_h) {
	$opt_l = 5;
} else {
	$opt_l = 4;
}
 
die("$image_file: no such file or directory\n")
	unless -f $image_file;
die("$0: invalid bitplane number $bitplane\n")
	unless ($bitplane =~ m{^\d+$} && $bitplane>=0 && $bitplane<=7) ||
		   ($bitplane =~ m{^[UuVvWwAaBbCcDd]$});
die("$0: invalid number of brighntess levels $opt_l\n")
	unless $opt_l>=0 && $opt_l<=0xFF;

#----------------------------------------------------------------------
# Read Image File
#----------------------------------------------------------------------	

my($image) = Imager->new(file=>$image_file)								# read image file
	|| die(Imager->errstr()); 

my($w) = $image->getwidth();
my($h) = $image->getheight();
die("$image_file: invalid image dimensions: ${w}x${h}\n")
	unless $w==128 && $h==32;

if ($opt_v > 1) {
	print(STDERR "$image_file:\n");
}

#----------------------------------------------------------------------
# Create $opt_l - Level Grayscale Image
#	- options:
#		- raw
#		- contrast stretched (-s)
#		- histogram equalized (-e)
#---------------------------------------------------------------------- 

my(@rawImg);															# decimated image

for (my($y)=0; $y<32; $y++) {											# create grayscale intensity image
	for (my($x)=0; $x<128; $x++) {										# (adjusting for -g if needed)
		my($pixel) = $image->getpixel(x=>$x,y=>$y);						
		my($R,$G,$B,$A) = $pixel->rgba();
		my($I) = sqrt($R**2/3+$G**2/3+$B**2/3);
		$I = 0xFF*($I/0xFF)**(1/$opt_g)									# -g adjustment is irrelevant when -e is used
			if defined($opt_g) && !$opt_e;
		$rawImg[$y][$x] = $I;
	}
}

if ($opt_e) {															# HISTOGRAM EQUALIZATION

	my(@Ivec,%iVals);															
	for (my($y)=0; $y<32; $y++) {										# create sorted intensity vector
		for (my($x)=0; $x<128; $x++) {
			my($I) = $rawImg[$y][$x];
			die($I) unless $I>=0 && $I<=0xFF;
			push(@Ivec,$I);
			$iVals{int($I+0.5)}++;
		}
	}
	@Ivec = sort { $a <=> $b } @Ivec;

	my($nLvl) = scalar(keys(%iVals));
#	foreach my $val (keys(%iVals)) {
#		print(STDERR "$val\n");
#	}
	printf(STDERR "\tInput Brightness   = \$%02X .. \$%02X (%d distinct levels)\n",$Ivec[0],$Ivec[$#Ivec],$nLvl)
		if ($opt_v > 1);
	die("$image_file: insufficient color depth ($nLvl distinct levels) for -l $opt_l histogram equalization\n")
		if ($opt_l == 5 && $nLvl < 8) ||
		   ($opt_l != 4 && $nLvl < $opt_l);

	my($minIout,$maxIout) = (999,-1);
	my(@llim); 															# level limits
	if ($opt_l == 5) {													# 5-level driver (linear, half-tone, gamma)
		if (!defined($opt_h)) {											#	linear
			for (my($i)=0; $i<=$opt_l; $i++) {
				$llim[$i] = $i * 4096 / $opt_l;
			}
		} elsif (defined($opt_g)) {										#	gamma correction
			for (my($i)=0; $i<=$opt_l; $i++) {
				$llim[$i] = 4096 * ($i/$opt_l)**$opt_g;
			}
		} else {														# 	half tone
			@llim = (0,1024,2048,3072,3584,4096);
		}
	} else {															# regular (not 5-level) drivers (linear, gamma)
		if (defined($opt_g)) {											#	gamma correction
			for (my($i)=0; $i<=$opt_l; $i++) {
				$llim[$i] = 4096 * ($i/$opt_l)**$opt_g;
			}
		} else {														#	linear
			for (my($i)=0; $i<=$opt_l; $i++) {
				$llim[$i] = $i * 4096 / $opt_l;
			}
		}
	}

	for (my($y)=0; $y<32; $y++) {										# decimate scaled input to $opt_l levels								
		for (my($x)=0; $x<128; $x++) {	
			my($I)	  = $rawImg[$y][$x];
			my($Iout) = 0;
			while ($Iout<$opt_l-1 && $I>$Ivec[$llim[$Iout+1]]) {
				$Iout++;
			}
			$rawImg[$y][$x] = $Iout;
			die unless $rawImg[$y][$x]>=0 && $rawImg[$y][$x]<$opt_l;
			$minIout = $rawImg[$y][$x] if $rawImg[$y][$x] < $minIout;
			$maxIout = $rawImg[$y][$x] if $rawImg[$y][$x] > $maxIout;
		}
    }
	printf(STDERR "\tOutput Brightness  = \$%02X .. \$%02X\n",$minIout,$maxIout)
		if ($opt_v > 1);

	if ($opt_v > 1) {
		print(STDERR "\tBrightness Limits  = ");
		for (my($i)=0; $i<@llim-1 && $Ivec[$llim[$i]]<0xFF; $i++) {
			printf(STDERR "%d%% ",int($Ivec[$llim[$i]]/2.55+0.5));
#			printf(STDERR "%d ",$Ivec[$llim[$i]]);
		}
		print(STDERR "100%\n");
	}

} else {																# CONTRAST STRETCHING (-s) / RAW
	my(%iVals);
	my($minI,$maxI) = (999,-1); 										# find contrast limits
	for (my($y)=0; $y<32; $y++) {										    
		for (my($x)=0; $x<128; $x++) {
			my($I) = $rawImg[$y][$x];
			die($I) unless $I>=0 && $I<=0xFF;
			$minI = $I if ($minI > $I);
			$maxI = $I if ($maxI < $I);
			$iVals{$I}++;
		}
	}
	my($nLvl) = scalar(keys(%iVals));
	printf(STDERR "\tInput Brightness   = \$%02X .. \$%02X (%d distinct levels)\n",$minI,$maxI,$nLvl)
		if ($opt_v > 1);
# 	ERROR IS INCORRECT FOR GAME LEVELS
#	die("$image_file: insufficient color depth ($nLvl distinct levels) for -l $opt_l\n")
#		if ($opt_l == 5 && $nLvl<8) ||
#		   ($opt_l != 4 && $nLvl<$opt_l);

	my($minIout,$maxIout) = (999,-1);
	my($Istep) = $opt_h ? 256 / 8										# work with 8 levels when using half-tone driver
						: 256 / $opt_l;										
	for (my($y)=0; $y<32; $y++) {										
		for (my($x)=0; $x<128; $x++) {
			my($I) = $rawImg[$y][$x];
			die($I) unless $I>=0 && $I<=0xFF;
			my($Iout) = $opt_s ? (($I - $minI) / ($maxI - $minI) * 255) : $I;
			$Iout = int($Iout/$Istep);
            if ($opt_h) {												# half-tones 0,1>0 2,3>1 4,5>2 6>3 7>4
            	if ($Iout < 7) {										# nominal levels: 0 1 2 2.5 3
					$Iout = int($Iout/2);								# actual levels : 0 1 2  3  4
				} else {
					$Iout = 4;
				}
            }
			$rawImg[$y][$x] = $Iout;
			die unless $rawImg[$y][$x]>=0 && $rawImg[$y][$x]<$opt_l;
			$minIout = $rawImg[$y][$x] if $rawImg[$y][$x] < $minIout;
			$maxIout = $rawImg[$y][$x] if $rawImg[$y][$x] > $maxIout;
		}
    }
	printf(STDERR "\tOutput Brightness  = \$%02X .. \$%02X\n",$minIout,$maxIout)
		if ($opt_v > 1);

}

my(@nPix);
for (my($y)=0; $y<32; $y++) {
	for (my($x)=0; $x<128; $x++) {
		$nPix[$rawImg[$y][$x]]++;
	}
}
my($lout) = 0;
for (my($l)=0; $l<$opt_l; $l++) {
	$lout++ if defined($nPix[$l]);
}
print(STDERR "WARNING: $image_file: output has only $lout out of $opt_l available levels\n")
	unless $lout == $opt_l;

if ($opt_v > 1) {														# output brightness histogram
	print(STDERR "\t\tFrequency:\n");
	for (my($l)=0; $l<$opt_l; $l++) {
		printf(STDERR "\t\t\tlevel-$l: %4d (%2d%%)\n",$nPix[$l],int(100*$nPix[$l]/4096)+.5)
			if defined($nPix[$l]);
	}
}

if ($opt_v > 2) {														# output as ASCII
	my(@c) = ($opt_l <= 5) ? ('@','*','+','-',' ')
						   : ('@','#','*','+','-',':','.',' ');
	
	print(STDERR "\tDecimated Raw Image:\n\t\t");
	for (my($y)=0; $y<32; $y++) {
		for (my($x)=0; $x<128; $x++) {
  			print(STDERR $c[$rawImg[$y][$x]]);
		}
		print(STDERR "\n");
	  	print(STDERR "\t\t") if $y<31;
	}
}

#----------------------------------------------------------------------
# Extract Bitplanes
#	- 0, 1, 2 for binary-encoded bitplane drivers
#		- WPC drivers use 0 & 1
#		- experimental 8-level driver uses all three
#	- U, V, W
#		- 5-level driver
#	- A, B, C, D
#		- 7-level driver
#----------------------------------------------------------------------

my(@BP);																# extract bitplane

printf(STDERR "\tBitplane           = $bitplane\n")
	if $opt_v > 1;

if ($bitplane =~ m{^\d+$}) {											# binary-encoded bitplanes (bit number)
	die("$0: invalid bitplane for -l $opt_l\n")
		if ($opt_l == 5);
	my($bitMask) = 0x01;
	for (my($i)=0; $i<$bitplane; $i++) { $bitMask <<= 1; }
	for (my($y)=0; $y<32; $y++) {
		for (my($xB)=0; $xB<16; $xB++) {
			$BP[$y][$xB] = 0;
			for (my($xb,$xm)=(0,0x01); $xb<8; $xb++,$xm<<=1) {
				$BP[$y][$xB] |= $xm if ($rawImg[$y][(8*$xB)+$xb] & $bitMask);
			}
		}
	}
} else {																# non-numerical (A-D, U-W)
	for (my($y)=0; $y<32; $y++) {
		for (my($xB)=0; $xB<16; $xB++) {
			$BP[$y][$xB] = 0;
			for (my($xb,$xm)=(0,0x01); $xb<8; $xb++,$xm<<=1) {
				my($x) = (8*$xB) + $xb;
				if (CORE::fc($bitplane) eq CORE::fc('A')) {							# bitplane A
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $x%2==$y%2) ||
										   ($rawImg[$y][$x]==2) ||
										   ($rawImg[$y][$x]==3 && $x%2==$y%2) ||
										   ($rawImg[$y][$x]==5) ||
										   ($rawImg[$y][$x]==6);
				} elsif (CORE::fc($bitplane) eq CORE::fc('B')) {					# bitplane B
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==3 && $x%2==$y%2) ||
										   ($rawImg[$y][$x]==4) ||
										   ($rawImg[$y][$x]==5 && $x%2==$y%2) ||
										   ($rawImg[$y][$x]==6);
				} elsif (CORE::fc($bitplane) eq CORE::fc('C')) {					# bitplane C
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $x%2!=$y%2) ||
										   ($rawImg[$y][$x]==2) ||
										   ($rawImg[$y][$x]==3 && $x%2!=$y%2) ||
										   ($rawImg[$y][$x]==5 && $x%2!=$y%2) ||
										   ($rawImg[$y][$x]==6);
				} elsif (CORE::fc($bitplane) eq CORE::fc('D')) {					# bitplane D
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==3 && $x%2!=$y%2) ||
										   ($rawImg[$y][$x]==4) ||
										   ($rawImg[$y][$x]==5) ||
										   ($rawImg[$y][$x]==6);
				} elsif (CORE::fc($bitplane) eq CORE::fc('U')) {					# bitplane U
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==4);
					if ($opt_i == -1) {									# checkerboard interlacing
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3) && $x%2==$y%2;
					} elsif ($opt_i == 1) {								# column interlacing
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3) && $x%2==0;
					} elsif ($opt_i == 2) {								# row interlacing
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3) && $y%2==0;
					} elsif ($opt_i == 0) {								# no interlacing
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3);
					} else {
						die("$0: invalid interlace method -i $opt_i\n");
					}
				} elsif (CORE::fc($bitplane) eq CORE::fc('V')) {					# bitplane V
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x] == 4);
					if ($opt_i == -1) {									# checkerboard
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3) && $x%2!=$y%2;
					} elsif ($opt_i == 1) {								# columns
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3) && $x%2==1;
					} elsif ($opt_i == 2) {								# rows
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 || $rawImg[$y][$x]==3) && $y%2==1;
					} elsif ($opt_i != 0) {
						die("$0: invalid interlace method -i $opt_i\n");
					}
				} elsif (CORE::fc($bitplane) eq CORE::fc('W')) {					# bitplane W
					$BP[$y][$xB] |= $xm  if ($rawImg[$y][$x] > 1);
				} else {
					die("$0: invalid bitplane <$bitplane>\n");
				}
			}
		}
	}
}

if ($opt_v > 3) {
	print(STDERR "\tBitplane Data:\n\t\t");
	for (my($y)=0; $y<32; $y++) {
		for (my($x)=0; $x<16; $x++) {
	  		for (my($m)=0x01; $m<0x100; $m<<=1) {
	  			print(STDERR ($BP[$y][$x] & $m) ? '@' : ' ');
		  	}
		}
		print(STDERR "\n");
	  	print(STDERR "\t\t") if $y<31;
	}
}

#----------------------------------------------------------------------
# Compress Bitmap
#----------------------------------------------------------------------

my(@RLE);																# encode bitplane
my(@byteVals);															# find unused tag
for (my($y)=0; $y<32; $y++) {
	for (my($x)=0; $x<16; $x++) {
		$byteVals[$BP[$y][$x]]++;
    }
}
my($tag);
for (my($i)=1; $i<256; $i++) {
	next if $byteVals[$i];
	$tag = $i;
	last;
}
die unless defined($tag);
printf('$%02X ',$tag) unless defined($opt_Q);
if ($opt_v > 1) {
	printf(STDERR "\tRLE Tag            = \$%02X\n",$tag);
}

my($bytes_output) = 0;

my($x,$y) = (0,1);
my($rl,$rv) = (1,$BP[0][0]);
while (1) {
	if ($BP[$y][$x] == $rv) {											# continue run
		$rl++;
    } elsif ($rl > 1) {													# output run
    	printf('$%02X $%02X $%02X ',$tag,$rl,$rv) unless defined($opt_Q);
    	$bytes_output += 3;
    	$rv = $BP[$y][$x];
    	$rl = 1;
    } else {															# output single value
    	printf('$%02X ',$rv) unless defined($opt_Q);
    	$bytes_output++;
    	$rv = $BP[$y][$x];
    	$rl = 1;
    }
    $y++;
    if ($y == 32) {
    	$y = 0;
    	$x++;
    	last if $x == 16;
    }
}
if ($rl > 1) {															# output final run or value
   	printf('$%02X $%02X $%02X ',$tag,$rl,$rv) unless defined($opt_Q);
   	$bytes_output += 3;
} else {			
   	printf('$%02X ',$rv) unless defined($opt_Q);
   	$bytes_output++;
}
print("\n") unless defined($opt_Q);

if ($opt_v == 1) {
	printf(STDERR "$image_file: %d%% compression\n",100-int(100*$bytes_output/512+0.5));
} elsif ($opt_v > 1) {
	printf(STDERR "\tBytes Output       = $bytes_output (%d%% compression)\n",100-int(100*$bytes_output/512+0.5));
}

#----------------------------------------------------------------------
# Done
#----------------------------------------------------------------------

exit(0);
