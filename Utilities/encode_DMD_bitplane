#!/usr/bin/env perl
#======================================================================
#                    U T I L I T I E S / E N C O D E _ D M D _ B I T P L A N E 
#                    doc: Fri Jan  2 10:08:34 2026
#                    dlm: Fri Jan 16 10:26:56 2026
#                    (c) 2026 A.M. Thurnherr
#                    uE-Info: 186 74 NIL 0 0 72 2 2 4 NIL ofnI
#======================================================================

# HISTORY:
# Jan  2, 2026: - created
# Jan  3, 2026: - made work
# Jan  8, 2026: - improved to specify brigtness range
#				- improved usage errors
# Jan  9, 2026: - minor improvement with -v 1 output
#				- made -v0 default
#				- BUG: never produced black
# Jan 10, 2026: - BUG: forgot to scale input image intensities
# Jan 12, 2026: - added RELEASE NOTES
#				- added encoding for new UVW bitplanes
#				- BUG: level 3 was not in U
#				- added -d)ither level 1 to try to decrease
#				  flicker; this completely messes up compression
#				> but it is spectacularly successful!
# Jan 14, 2026: - renamed dither to -i)nterlace <method>
#				- implement column-wise interleaving to try to recover
#				  compression
# Jan 15, 2026: - since this does NOT improve compression, I made
#				  -i0 default and use -i to change
# Jan 16, 2026: - added -s, -e, -Q
# HISTORY END

# RELEASE NOTES:
#	This too requires the Imager PERL library. On a Mac, tis can be installed with the
#   following commands:
#		brew install pkg-config libpng jpeg giflib
#		cpan Imager

use Getopt::Std;
use strict;
use warnings;
use Imager;

$0 =~ s@^.*/(.*)$@$1@;

#----------------------------------------------------------------------
# Usage
#----------------------------------------------------------------------

die("Usage: $0 \n" .
		"\t[-v)erbosity <n[0]>] [-Q)uiet (no code output)]\n" .
		"\t[brightness-l)evels <n[4]>]\n" .
		"\t[apply constrast-s)tretching]\n" .
		"\t[apply histogram-e)qualization\n" .
		"\t[use alternate -i)nterlace <method[0:none,1:cols,2:rows]>]\n" .
		"\t\t<bitplane> <image file>\n")
	        unless (getopts('ei:l:Qsv:') && @ARGV==2);

my $bitplane 	= $ARGV[0];
my $image_file	= $ARGV[1];

our $opt_Q;
our $opt_s;
our $opt_e;
our $opt_i = -1 unless defined($opt_i);
our $opt_l =  4 unless defined($opt_l);
our $opt_v =  0 unless defined($opt_v);

die("$image_file: no such file or directory\n")
	unless -f $image_file;
die("$0: invalid bitplane number $bitplane\n")
	unless ($bitplane =~ m{^\d+$} && $bitplane>=0 && $bitplane<=7) ||
		   ($bitplane =~ m{^[UuVvWw]$});
die("$0: invalid number of brighntess levels $opt_l\n")
	unless $opt_l>=0 && $opt_l<=0xFF;

#----------------------------------------------------------------------
# Read Image File
#----------------------------------------------------------------------	

my($image) = Imager->new(file=>$image_file)								# read image file
	|| die(Imager->errstr()); 

my($w) = $image->getwidth();
my($h) = $image->getheight();
die("$image_file: invalid image dimensions: ${w}x${h}\n")
	unless $w==128 && $h==32;

if ($opt_v > 1) {
	print(STDERR "$image_file:\n");
	printf(STDERR "\tBitplane           = $bitplane\n");
}

#----------------------------------------------------------------------
# Create $opt_l - Level Grayscale Image
#	- options:
#		- raw
#		- contrast stretched (-s)
#		- histogram equalized (-h)
#---------------------------------------------------------------------- 

my(@rawImg);															# decimated image

if ($opt_e) {															# HISTOGRAM EQUALIZATION

	my(@Ivec,%iVals);															
	for (my($y)=0; $y<32; $y++) {										# create sorted intensity vector
		for (my($x)=0; $x<128; $x++) {
			my($pixel) = $image->getpixel(x=>$x,y=>$y);
			my($R,$G,$B,$A) = $pixel->rgba();
			my($I) = int(sqrt($R**2/3+$G**2/3+$B**2/3)+0.5);
			die($I) unless $I>=0 && $I<=0xFF;
			push(@Ivec,$I);
			$iVals{$I}++;
		}
	}
	@Ivec = sort { $a <=> $b } @Ivec;									
	printf(STDERR "\tInput Brightness   = \$%02X .. \$%02X (%d distinct levels)\n",$Ivec[0],$Ivec[$#Ivec],scalar(keys(%iVals)))
		if ($opt_v > 1);

	my($minIout,$maxIout) = (999,-1);
	my($Lstep) = 4096 / $opt_l;										
	for (my($y)=0; $y<32; $y++) {										# decimate scaled input to $opt_l levels								
		for (my($x)=0; $x<128; $x++) {	
			my($pixel)		= $image->getpixel(x=>$x,y=>$y);
			my($R,$G,$B,$A) = $pixel->rgba();
			my($I)			= int(sqrt($R**2/3+$G**2/3+$B**2/3)+0.5);
			my($Iout) 		= 0;
			while ($Iout<$opt_l-1 && $I>$Ivec[($Iout+1)*$Lstep-1]) {
				$Iout++;
            }
			$rawImg[$y][$x] = $Iout;
			die unless $rawImg[$y][$x]>=0 && $rawImg[$y][$x]<$opt_l;
			$minIout = $rawImg[$y][$x] if $rawImg[$y][$x] < $minIout;
			$maxIout = $rawImg[$y][$x] if $rawImg[$y][$x] > $maxIout;
		}
    }
	printf(STDERR "\tOutput Brightness  = \$%02X .. \$%02X\n",$minIout,$maxIout)
		if ($opt_v > 1);

} else {																# CONTRAST STRETCHING (-s) / RAW
	my(%iVals);
	my($minI,$maxI) = (999,-1); 										# find contrast limits
	for (my($y)=0; $y<32; $y++) {										    
		for (my($x)=0; $x<128; $x++) {
			my($pixel) = $image->getpixel(x=>$x,y=>$y);
			my($R,$G,$B,$A) = $pixel->rgba();
			my($I) = int(sqrt($R**2/3+$G**2/3+$B**2/3)+0.5);
			die($I) unless $I>=0 && $I<=0xFF;
			$minI = $I if ($minI > $I);
			$maxI = $I if ($maxI < $I);
			$iVals{$I}++;
		}
	}
	printf(STDERR "\tInput Brightness   = \$%02X .. \$%02X (%d distinct levels)\n",$minI,$maxI,scalar(keys(%iVals)))
		if ($opt_v > 1);

	my($minIout,$maxIout) = (999,-1);
	my($Istep) = 256 / $opt_l;											# decimate scaled input to $opt_l levels
	for (my($y)=0; $y<32; $y++) {										
		for (my($x)=0; $x<128; $x++) {
			my($pixel)		= $image->getpixel(x=>$x,y=>$y);
			my($R,$G,$B,$A) = $pixel->rgba();
			my($I)			= int(sqrt($R**2/3+$G**2/3+$B**2/3)+0.5);
			my($Iout)		= $opt_s ? (($I - $minI) / ($maxI - $minI) * 255) : $I;
			$rawImg[$y][$x] = int($Iout/$Istep);
			die unless $rawImg[$y][$x]>=0 && $rawImg[$y][$x]<$opt_l;
			$minIout = $rawImg[$y][$x] if $rawImg[$y][$x] < $minIout;
			$maxIout = $rawImg[$y][$x] if $rawImg[$y][$x] > $maxIout;
		}
    }
	printf(STDERR "\tOutput Brightness  = \$%02X .. \$%02X\n",$minIout,$maxIout)
		if ($opt_v > 1);

}

if ($opt_v > 1) {														# output brightness hisgtogram
	my(@nPix);
	for (my($y)=0; $y<32; $y++) {
		for (my($x)=0; $x<128; $x++) {
			$nPix[$rawImg[$y][$x]]++;
		}
	}
	print(STDERR "\t\tFrequency:\n");
	for (my($l)=0; $l<$opt_l; $l++) {
		print(STDERR "\t\t\tlevel-$l: $nPix[$l]\n") if defined($nPix[$l]);
	}
}

if ($opt_v > 2) {														# output as ASCII 
	print(STDERR "\tDecimated Raw Image:\n\t\t");
	for (my($y)=0; $y<32; $y++) {
		for (my($x)=0; $x<128; $x++) {
  			print(STDERR $rawImg[$y][$x]);
		}
		print(STDERR "\n");
	  	print(STDERR "\t\t") if $y<31;
	}
}

#----------------------------------------------------------------------
# Extract Bitplanes
#	- 0, 1, 2 for WPC drivers
#	- U, V, W for IDD
#----------------------------------------------------------------------

my(@BP);																# extract bitplane

if ($bitplane =~ m{^\d+$}) {											# numerical (bit number)
	my($bitMask) = 0x01;
	for (my($i)=0; $i<$bitplane; $i++) { $bitMask <<= 1; }
	for (my($y)=0; $y<32; $y++) {
		for (my($xB)=0; $xB<16; $xB++) {
			$BP[$y][$xB] = 0;
			for (my($xb,$xm)=(0,0x01); $xb<8; $xb++,$xm<<=1) {
#				printf(STDERR "rawImg[$y][(8*$xB)+$xb] & 0x%02X [$rawImg[$y][(8*$xB)+$xb]]\n",$bitMask),
				$BP[$y][$xB] |= $xm if ($rawImg[$y][(8*$xB)+$xb] & $bitMask);
			}
		}
	}
} else {																# non-numerical (U, V, W)
	for (my($y)=0; $y<32; $y++) {
		for (my($xB)=0; $xB<16; $xB++) {
			$BP[$y][$xB] = 0;
			for (my($xb,$xm)=(0,0x01); $xb<8; $xb++,$xm<<=1) {
				my($x) = (8*$xB) + $xb;
				if ($bitplane =~ m{[uU]}) {								# bitplane U (levels 1(half),3)
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==3);
					if ($opt_i == -1) {									# checkerboard interlacing
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $x%2==$y%2);
					} elsif ($opt_i == 1) {								# columns
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $x%2==0);
					} elsif ($opt_i == 2) {								# rows
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $y%2==0);
					} elsif ($opt_i == 0) {								# none
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1);
					} else {
						die("$0: invalid interlace method -i $opt_i\n");
					}
				} elsif ($bitplane =~ m{[vV]}) {						# bitplane V (levels 1(half),3)
					$BP[$y][$xB] |= $xm if ($rawImg[$y][$x] == 3);
					if ($opt_i == -1) {									# checkerboard
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $x%2!=$y%2);
					} elsif ($opt_i == 1) {								# columns
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $x%2!=$y%2);
					} elsif ($opt_i == 2) {								# rows
						$BP[$y][$xB] |= $xm if ($rawImg[$y][$x]==1 && $y%2==0);
					} elsif ($opt_i != 0) {
						die("$0: invalid interlace method -i $opt_i\n");
					}
				} else {												# bitplane W (levels 2,3)
					$BP[$y][$xB] |= $xm  if ($rawImg[$y][$x] > 1);
				}
			}
		}
	}
}

if ($opt_v > 3) {
	print(STDERR "\tBitplane:\n\t\t");
	for (my($y)=0; $y<32; $y++) {
		for (my($x)=0; $x<16; $x++) {
	  		for (my($m)=0x01; $m<0x100; $m<<=1) {
	  			print(STDERR ($BP[$y][$x] & $m) ? '@' : ' ');
		  	}
		}
		print(STDERR "\n");
	  	print(STDERR "\t\t") if $y<31;
	}
}

#----------------------------------------------------------------------
# Compress Bitmap
#----------------------------------------------------------------------

my(@RLE);																# encode bitplane
my(@byteVals);															# find unused tag
for (my($y)=0; $y<32; $y++) {
	for (my($x)=0; $x<16; $x++) {
		$byteVals[$BP[$y][$x]]++;
    }
}
my($tag);
for (my($i)=1; $i<256; $i++) {
	next if $byteVals[$i];
	$tag = $i;
	last;
}
die unless defined($tag);
printf('$%02X ',$tag) unless defined($opt_Q);
if ($opt_v > 1) {
	printf(STDERR "\tRLE Tag            = \$%02X\n",$tag);
}

my($bytes_output) = 0;

my($x,$y) = (0,1);
my($rl,$rv) = (1,$BP[0][0]);
while (1) {
	if ($BP[$y][$x] == $rv) {											# continue run
		$rl++;
    } elsif ($rl > 1) {													# output run
    	printf('$%02X $%02X $%02X ',$tag,$rl,$rv) unless defined($opt_Q);
    	$bytes_output += 3;
    	$rv = $BP[$y][$x];
    	$rl = 1;
    } else {															# output single value
    	printf('$%02X ',$rv) unless defined($opt_Q);
    	$bytes_output++;
    	$rv = $BP[$y][$x];
    	$rl = 1;
    }
    $y++;
    if ($y == 32) {
    	$y = 0;
    	$x++;
    	last if $x == 16;
    }
}
if ($rl > 1) {															# output final run or value
   	printf('$%02X $%02X $%02X ',$tag,$rl,$rv) unless defined($opt_Q);
   	$bytes_output += 3;
} else {			
   	printf('$%02X ',$rv) unless defined($opt_Q);
   	$bytes_output++;
}
print("\n") unless defined($opt_Q);

if ($opt_v == 1) {
	printf(STDERR "$image_file: %d%% compression\n",100-int(100*$bytes_output/512+0.5));
} elsif ($opt_v > 1) {
	printf(STDERR "\tBytes Output       = $bytes_output (%d%% compression)\n",100-int(100*$bytes_output/512+0.5));
}

#----------------------------------------------------------------------
# Done
#----------------------------------------------------------------------

exit(0);
