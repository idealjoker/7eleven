#======================================================================
#                    C 7 1 1 . V M 
#                    doc: Wed May 21 21:55:45 2025
#                    dlm: Wed Jun  4 08:55:37 2025
#                    (c) 2025 idealjoker@mailbox.org
#                    uE-Info: 1100 0 NIL 0 0 72 8 2 4 NIL ofnI
#======================================================================

# HISTORY:
#	May 21, 2025: - exported from [C711]
#	May 23, 2025: - adapted to strict vars
#				  - replaced encode_scoreByte() with adapted code from 
#					[C711.scoreByte.6a]
#	May 26, 2025: - renamed from C711.WVM
#				  - renamed some funs
#	Jun  2, 2025: - corrected header
# HISTORY END

use strict vars;

# Global Variables

our($OP,@OP_ARG,$MODE,%JSR_TRG,@ROM,$ADDR,%LBL,@IF_CONT_LBL,@LOOP_DONE_LBL,
	$EXEC6800_BLOCK_ID,$OPTIMIZABLE_LABEL_PREFIX,$EIGHT_BIT_LABEL_PREFIX,
	@newly_defined_label,$WMS_System,%System_Option,$IVM_DISABLED,@SRC,
	$TWELVE_BIT_LABEL_PREFIX,@LINE,$opt_v);

# Local Variables

my(@LOOP_LBL);
our($current_mode);																			# cannot be my because of local()

#======================================================================
# WVM Macros
#======================================================================

sub asm_wvm_macros()																		# _SLEEP, _WVM_MODE, ...
{
	
	if ($MODE==0 || $MODE==2) {
		if ($OP eq '_M6800_sleep') {
			set_label_type(2);
			if ((@OP_ARG == 1) && ($OP_ARG[0] =~ m{^#})) {
				die("invalid _M6800_sleep time ($') at input line $.\n")
					unless numberp($') && $'>=0 && $'<=255; 
				$ROM[$ADDR++] = 0x57;														# jumpSubroutine6800 IVM_sleepI
				$ROM[$ADDR++] = 'IVM_sleepI';
				$ROM[$ADDR++] = '16-BIT VALUE';
				$ROM[$ADDR++] = $'; 														# .DB xx
				$MODE=2,return 1;
			} elsif ((@OP_ARG == 1) && ($OP_ARG[0] =~ m{^\[Reg-[AB]\]$})) {
				$ROM[$ADDR++] = wvm_register_arg(0) ? 0x0F : 0x0D;							# store Reg-[AB] _WVM_sleep_arg
				$ROM[$ADDR++] = '_WVM_sleep_arg';
				$ROM[$ADDR++] = 0x57;														# jumpSubroutine6800 WVM_sleep
				$ROM[$ADDR++] = 'WVM_sleep';
				$ROM[$ADDR++] = '16-BIT VALUE';
				$MODE=2,return 1;
			} else {
				die("Syntax: _M6800_sleep #time|[Reg-?] at input line $.\n");
			}
	    }
	}

	return undef;
}

#----------------------------------------------------------------------
# Unroll Structured Programming
#----------------------------------------------------------------------

sub unroll_wvm_structure()
{
#	print(STDERR "unroll_wvm_structure(MODE=$MODE): $OP @OP_ARG\n");
	
    #----------------------------------------
    # WVM If/Unless Statements
    #----------------------------------------

	if ($MODE==0 || $MODE==2) {
		if ($OP eq '_If') {
			$OP = 'branchUnless';
			my($lbl) = auto_label(2);
			push(@OP_ARG,$lbl);
			push(@IF_CONT_LBL,$lbl);
			$MODE=2,return;
		}
	
		if ($OP eq '_Unless') {
			$OP = 'branchIf';
			my($lbl) = auto_label(2);
			push(@OP_ARG,$lbl);
			push(@IF_CONT_LBL,$lbl);
			$MODE=2,return;
		}
	    
		if ($OP eq '_Else') {
			$OP = 'branch';
			@OP_ARG = (auto_label(2));
			define_label(pop(@IF_CONT_LBL),$ADDR+2);
			push(@IF_CONT_LBL,$OP_ARG[0]);
			$MODE=2,return;
		}
	
		if ($OP eq '_EndIf' || $OP eq '_EndUnless') {
			undef($OP);
			define_label(pop(@IF_CONT_LBL));
			$MODE=2,return;
	    }
	}

    #----------------------------------------
    # WVM Loop Statements
    #----------------------------------------

	if ($MODE==0 || $MODE==2) {
		if ($OP eq '_Loop') {										# begin a loop
			undef($OP); 											#	- create 2 labels, but no code
			my($lbl) = auto_label(2);								#	- push labels on loop stack
			define_label($lbl);
			push(@LOOP_LBL,$lbl);
			push(@LOOP_DONE_LBL,auto_label(0));						# don't define type yet; label only used with _ExitLoop
			$MODE=2,return;
		}
	
		if ($OP eq '_EndLoop') {									# end infinite loop
			$OP = 'branch'; 										#	- add a branch statement
			@OP_ARG = (pop(@LOOP_LBL)); 							#	- pop labels from loop stack
			define_label(pop(@LOOP_DONE_LBL),$ADDR+2);
			$MODE=2,return;
		}
	    
		if ($OP eq '_Until') {										# end finite loop on TRUE
			$OP = 'branchUnless';									#	- add branchUnless statement
			push(@OP_ARG,pop(@LOOP_LBL));							#	- pop labels from loop stack
			define_label(pop(@LOOP_DONE_LBL),$ADDR+1+@OP_ARG);
			$MODE=2,return;
		}
	
		if ($OP eq '_While') {										# end finite loop on FALSE
			$OP = 'branchIf';									    
			push(@OP_ARG,pop(@LOOP_LBL));
			define_label(pop(@LOOP_DONE_LBL),$ADDR+1+@OP_ARG);
			$MODE=2,return;
		}
	
		if ($WMS_System == 11) {									# end for-next loop
			if ($OP eq '_Next') {
				$OP = 'decAndBranchUnlessZero';						# decrement register and branch unless 0
				push(@OP_ARG,pop(@LOOP_LBL));
				define_label(pop(@LOOP_DONE_LBL),$ADDR+3);
				$MODE=2,return;
			}
	    }
	}
}

#======================================================================
# WVM Compiler
#======================================================================

#----------------------------------------------------------------------
# Operator Argument Parsers
#----------------------------------------------------------------------

sub wvm_adjustment_arg($)																# return argument value for adjustment operation
{
	my($argi) = @_;
	my($val);
	my($adj) = ($OP_ARG[$argi] =~ m{^Adj#(.*)$});
	if (defined($adj)) {
		$val = hex($adj);
#		die("Invalid adjustment number $val at input line $.\n")
#			unless ($val <= 0x3F);
    } else {
    	die("Cannot decode adjustment argument <$OP_ARG[$argi]> at input line $.\n");
    }
	return $val;
}

sub wvm_register_arg($)																	# return RAM address of Reg-A, Reg-B, ...
{																						# NB: no difference btw [Reg-X] and Reg-X 
	my($argi) = @_;

	my($preg) = ($OP_ARG[$argi] =~ m{^\[?Reg-P([0-5])\]?$});							# Reg-P0 - Reg-P5
	return $preg+2 if defined($preg);
	my($vreg) = ($OP_ARG[$argi] =~ m{^\[?Reg-V([0-7])\]?$});							# Reg-V0 - Reg-V7
	return $vreg+8 if defined($vreg);
	my($reg) = ($OP_ARG[$argi] =~ m{^\[?Reg-([A-P])\]?$});								# Reg-A - Reg-P
	die("Cannot decode register argument <$OP_ARG[$argi]> at input line $.\n")
		unless defined($reg);
	die("Invalid register $reg at input line $.\n")
		unless (ord($reg)-ord('A') <= 0x0F);	
	return ord($reg) - ord('A');
}

sub wvm_bit_arg($@)																		# return argument value for bit operation
{
	my($argi,$add) = @_;
	my($val);
	my($bit,$extra) = ($OP_ARG[$argi] =~ m{^#?Lamp#([0-9A-Fa-f]{2})(.*)$});
	if (defined($bit)) {
		die("Invalid lamp number $val at input line $.\n")
			unless (hex($bit) <= 0x3F);
		$val = hex($bit) + $add;
    } else {
		($bit) = ($OP_ARG[$argi] =~ m{^#?Flag#([0-9A-Fa-f]{2})$});
		die("Cannot decode bit argument <$OP_ARG[$argi]> at input line $.\n")
			unless defined($bit);
		die("Invalid flag number $val at input line $.\n")
			unless (hex($bit) <= 0x3F);
		$val = hex($bit)+$add | 0x40;
    }
	return "$val$extra";
}

sub wvm_lamp_arg($)																		# return argument value for lamp operation
{
	my($argi) = @_;
	my($val);
	my($bit,$extra) = ($OP_ARG[$argi] =~ m{^Lamp#([0-9A-Fa-f]{2})(.*)$});
	if (defined($bit)) {
		$val = hex($bit);
		die("Invalid lamp number $val at input line $.\n")
			unless ($val <= 0x3F);
    } else {
    	die("Cannot decode lamp argument <$OP_ARG[$argi]> at input line $.\n");
    }
	return "$val$extra";
}

sub wvm_bitgroup_arg($@)																# return argument value for bitgroup operation
{
	my($argi,$add) = @_;
	my($val);
	my($bitgroup,$extra) = ($OP_ARG[$argi] =~ m{^Bitgroup#([0-9A-Fa-f]{2})(.*)$});
	die("Cannot decode bitgroup argument <$OP_ARG[$argi]> at input line $.\n")
		unless defined($bitgroup);
	die("Invalid bitgroup number $val at input line $.\n")
		unless (hex($bitgroup) <= 0x3F);
	$val = hex($bitgroup) + $add;
	return "$val$extra";
}

sub wvm_sound_arg($)																	# return argument value for sound operation
{
	my($argi) = @_;
	my($val);
	my($sound) = ($OP_ARG[$argi] =~ m{^Sound#(.*)$});
	die("Cannot decode sound argument <$OP_ARG[$argi]> at input line $.\n")
		unless defined($sound);
	$val = hex($sound);
	return $val;
}

sub wvm_score_arg($)																	# return argument value for score operation
{
	my($argi) = @_;

	die("Cannot decode score argument <@OP_ARG[$argi]> at input line $.\n")				# both old and new syntax
		unless ($OP_ARG[$argi+1] eq '' || CORE::fc($OP_ARG[$argi+1]) eq CORE::fc('PTS'));

	my($times,$base) = ($OP_ARG[$argi] =~ m{^(\d+)x(\d+)$});							# old syntax
	if ($times > 0 && $base > 0) {

		my($val);
		if ($base == 1) 			{ $val = 0; } # 1
		elsif ($base == 10) 		{ $val = 1; } # 10
		elsif ($base == 100)		{ $val = 2; } # 100
		elsif ($base == 1000)		{ $val = 3; } # K
		elsif ($base == 10000)		{ $val = 4; } # 10K
		elsif ($base == 100000) 	{ $val = 5; } # 100K
		elsif ($base == 1000000)	{ $val = 6; } # M
		elsif ($base == 10000000)	{ $val = 7; } # 10M
		else {
			die("Cannot decode score argument <@OP_ARG[$argi]> at input line $.\n");
		}
	
		if ($times > 31) { # 0xF8>>3 == 31
			die("Cannot decode score argument <@OP_ARG[$argi]> at input line $.\n");
		}
	    $val |= $times<<3;
	    return $val;
	}
	return encode_scoreByte($OP_ARG[$argi],"input line $.");							# new syntax
}

sub wvm_switch_arg($)																	# return argument value for switch operation
{
	my($argi) = @_;
	my($val);
	my($switch) = ($OP_ARG[$argi] =~ m{^Switch#(.*)$});
	die("Cannot decode switch argument <$OP_ARG[$argi]> at input line $.\n")
		unless defined($switch);
	$val = hex($switch);
	die("Invalid switch number $val at input line $.\n")
		unless ($val <= 0x3F);
	return $val;
}

sub wvm_thread_arg($)																	# return argument value for thread operation
{
	my($argi) = @_;														
	
	my($thread) = ($OP_ARG[$argi] =~ m{^Thread#(.*)$});
	die("Cannot decode thread argument <$OP_ARG[$argi]> at input line $.\n")
		unless defined($thread);

	my($val);
	my($tid,$mask) = ($thread =~ m{^([^\|]+)\|(.*)$});									# allow hex bit masks
	if (defined($tid) && defined($mask)) {
		if ($mask =~ /^\$/) {
			$val = hex($tid) | hex($');
		} else {
			$val = hex($tid) | aliasValue($mask);
		}
	} else {
		$val = hex($thread);
	}
	die("Cannot decode thread <$thread> argument <$OP_ARG[$argi]> at input line $.\n")
		unless defined($val) && ($val >= 0) && ($val <= 0xFF);

#	my($val) = hex($thread);

	return $val;
}

#----------------------------------------------------------------------
# Conditional Expression Parser
#----------------------------------------------------------------------

sub wvm_parse_cExpr()																	# parse conditional expression
{																						# OUTPUT: last arg scanned
	my($i,$restrictions) = @_;															# INPUT: arg # to start scanning; optional restriction bitmask

	my($nargs);
	unless (defined($i)) {
		$i = 0;
		$nargs = @OP_ARG;
	}
	
	if ($OP_ARG[$i] =~ m{^Adj#[0-9A-Fa-f]{2}$}) {
		my($aa) = wvm_adjustment_arg($i);												# only fist 16 adjustements can be addressed
		die("Adjustment number out of range at input line $.\n")
			if ($aa<0 || $aa>0x0F);
		$ROM[$ADDR++] = 0xD0 + $aa;
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}
		
	if ($OP_ARG[$i] =~ m{^\[?Reg-[A-PV][0-7]?\]?$}) {									# registers (both Reg-C and [Reg-C])
		$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}
	
	if ($OP_ARG[$i] =~ m{^#?Flag#[0-9A-Fa-f]{2}$}) {									# flags
		$ROM[$ADDR++] = wvm_bit_arg($i,0x40);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
    }

	if ($OP_ARG[$i] =~ m{^Bitgroup#[0-9A-Fa-f]{2}}) {									# bitgroups (allows for |#$40)
		$ROM[$ADDR++] = wvm_bitgroup_arg($i,0x80);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
    }

	if ($OP_ARG[$i] =~ m{^#?Lamp#[0-9A-Fa-f]{2}}) {										# lamps (allows for |#$40)
		$ROM[$ADDR++] = wvm_bit_arg($i);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
    }

	if ($OP_ARG[$i] =~ m{^Thread#[0-9A-Fa-f]{2}}) {										# Threads
		$ROM[$ADDR++] = wvm_thread_arg($i);
		if ($restrictions & 0x01) {
			die(sprintf("%%findThread: Thread#%02X restricted to ids 00-CF on input line $.\n",$ROM[$ADDR-1]))
				if ($ROM[$ADDR-1] >= 0xD0);
		}
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
    }

	if ($OP_ARG[$i] =~ m{^Switch#[0-9A-Fa-f]{2}}) {										# Switches
		$ROM[$ADDR++] = wvm_switch_arg($i);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
    }

    if ($OP_ARG[$i] =~ m{^#([\$%]?)([0-9A-Fa-f]+)$}) {									# numbers (immediate addressing)
    	die unless defined($2);
    	   if ($1 eq '$') { $ROM[$ADDR] = hex($2);	}									# decimalize
    	elsif ($1 eq '%') { $ROM[$ADDR] = eval('0b' . $2); }
    	else			  { $ROM[$ADDR] = $2; }
    	die("Cannot decode number <$OP_ARG[$i]> at input line $.\n")
    		unless numberp($ROM[$ADDR]);
   		die("Number <$OP_ARG[$i]> is out of range (>= 0xF0) at input line $.\n")
   			unless ($ROM[$ADDR]>=0 && $ROM[$ADDR]<0xF0);
   		$ADDR++;
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
    	return $i;
    }

    if ($OP_ARG[$i] =~ m{^#}) {															# immediate addressing with labels
    	my($v) = eval_label($',undef,1);
		if (defined($v)) {
	    	$ROM[$ADDR++] = $v;
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
	    	return $i;
	    } 
    }

    if (($OP_ARG[$i] eq '%gameTilted') ||												# old name
		($OP_ARG[$i] eq '%ballTilted')) {
    	$ROM[$ADDR++] = 0xF0;
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
    	return $i;
    }
    		
    if ($OP_ARG[$i] eq '%gameOver') {
    	$ROM[$ADDR++] = 0xF1;
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
    	return $i;
    }
    		
    if ($OP_ARG[$i] eq '%number:') {
    	$ROM[$ADDR++] = 0xF2;
    	die("Syntax: %number: <#byte> at input line $.\n")
    		unless ($OP_ARG[$i+1] =~ m{^#});
		$ROM[$ADDR++] = $';
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+3 != $nargs);
    	return $i + 1;
    }
    		
    if (($OP_ARG[$i] eq '%logicNot:') ||
		($OP_ARG[$i] eq '%not:')) {
    	$ROM[$ADDR++] = 0xF3;
    	$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
    	return $i;
    }
	
	if ($WMS_System == 7) {		  											# system 7: test returns true if lamp lit or blinking
		if (($OP_ARG[$i] eq '%lampLitOrBlinking:') ||
			($OP_ARG[$i] eq '%litOrBlinking:')) {
			$ROM[$ADDR++] = 0xF4;
			if ($OP_ARG[$i+1] =~ m{^\[}) {
				$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i+1);
			} else {
				$ROM[$ADDR++] = wvm_lamp_arg($i+1);
			}
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
			return $i + 1;		    
	    }
	} elsif ($WMS_System == 11) {											# system 11: test returns true if lamp blinking
		if (($OP_ARG[$i] eq '%lampBlinking:') ||
			($OP_ARG[$i] eq '%blinking:')) {
			$ROM[$ADDR++] = 0xF4;
			if ($OP_ARG[$i+1] =~ m{^\[}) {
				$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i+1);
			} else {
				$ROM[$ADDR++] = wvm_lamp_arg($i+1);
			}
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
			return $i + 1;		    
	    }
	} 

    if (($OP_ARG[$i] eq '%allFlagsClear:') ||
        ($OP_ARG[$i] eq '%allLampsOff:') ||
        ($OP_ARG[$i] eq '%allClear:') ||
        ($OP_ARG[$i] eq '%allOff:')) {
    	$ROM[$ADDR++] = 0xF5;
    	if ($OP_ARG[$i+1] =~ m{^\[}) {
			$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i+1);
        } else {
			$ROM[$ADDR++] = wvm_bitgroup_arg($i+1);
        }
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
		return $i + 1;    		
	}

    if (($OP_ARG[$i] eq '%allFlagsSet:') ||
        ($OP_ARG[$i] eq '%allLampsOn:') ||
        ($OP_ARG[$i] eq '%allSet:') ||
        ($OP_ARG[$i] eq '%allOn:') ||
        ($OP_ARG[$i] eq '%allLampsLit:')) {
    	$ROM[$ADDR++] = 0xF6;
    	if ($OP_ARG[$i+1] =~ m{^\[}) {
			$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i+1);
        } else {
			$ROM[$ADDR++] = wvm_bitgroup_arg($i+1);
        }
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
		return $i + 1;    		
	}

    if (($OP_ARG[$i] eq '%lampAltbuf:') ||
    	($OP_ARG[$i] eq '%altBuf:')) {
    	$ROM[$ADDR++] = 0xF7;
    	if ($OP_ARG[$i+1] =~ m{^\[}) {
			$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i+1);
        } else {
			$ROM[$ADDR++] = wvm_lamp_arg($i+1);
        }
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
		return $i + 1;    		
	}

    if (($OP_ARG[$i] eq '%switchClosed:') ||
    	($OP_ARG[$i] eq '%switch:') ||
    	($OP_ARG[$i] eq '%closed:')) {
    	$ROM[$ADDR++] = 0xF8;
    	if ($OP_ARG[$i+1] =~ m{^\[}) {
			$ROM[$ADDR++] = 0xE0 + wvm_register_arg($i+1);
        } else {
			$ROM[$ADDR++] = wvm_switch_arg($i+1);
        }
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
		return $i + 1;    		
	}

    if ($OP_ARG[$i] eq '%bitOr:') {
    	$ROM[$ADDR++] = 0xF9;
    	$i = wvm_parse_cExpr($i+1);
    	$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}

    if (($OP_ARG[$i] eq '%logicAnd:') ||
    	($OP_ARG[$i] eq '%and:')) {
    	$ROM[$ADDR++] = 0xFA;
    	$i = wvm_parse_cExpr($i+1);
    	$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}

    if (($OP_ARG[$i] eq '%logicOr:') ||
    	($OP_ARG[$i] eq '%or:')) {
    	$ROM[$ADDR++] = 0xFB;
    	$i = wvm_parse_cExpr($i+1);
    	$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}

    if (($OP_ARG[$i] eq '%equalTo:') ||
		($OP_ARG[$i] eq '%equal:')) {
    	$ROM[$ADDR++] = 0xFC;
    	$i = wvm_parse_cExpr($i+1);
    	$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}
	
    if (($OP_ARG[$i] eq '%greaterThan:') ||
    	($OP_ARG[$i] eq '%greater:')) {
    	$ROM[$ADDR++] = 0xFD;
    	$i = wvm_parse_cExpr($i+1);
    	$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}

    if (($OP_ARG[$i] eq '%findThread:') ||
    	($OP_ARG[$i] eq '%isRunning:') ||
    	($OP_ARG[$i] eq '%threadRunning:') ||
    	($OP_ARG[$i] eq '%thread:')) {
    	$ROM[$ADDR++] = 0xFE;
    	$i = wvm_parse_cExpr($i+1);
    	if ($WMS_System == 7) {
    		$ROM[$ADDR++] = wvm_thread_arg($i+1);
    		die if ($ROM[$ADDR-1] > 0xCF);									# UNSURE! in BAD CATS, %findThread: Thread#E1 does not work (interpreted as %findThread [Reg-A]?)
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+3 != $nargs);
    		return $i + 1;
    	} elsif ($WMS_System == 11) {
	    	$i = wvm_parse_cExpr($i+1,0x01);											# restrict Threads to 00-CF
			die("Invalid conditional expression at input line $.\n")
				if (defined($nargs) && $i+2 != $nargs);
			return $i;
    	}
    }

    if ($OP_ARG[$i] eq '%bitAnd:') {
    	$ROM[$ADDR++] = 0xFF;
    	$i = wvm_parse_cExpr($i+1);
		$i = wvm_parse_cExpr($i+1);
		die("Invalid conditional expression at input line $.\n")
			if (defined($nargs) && $i+2 != $nargs);
		return $i;
	}
	
	if ($OP_ARG[$i] =~ /^auto_label/) {
		die("Incomplete conditional expression at input line $.\n");
	} else {
		die("Invalid conditional expression <$OP_ARG[$i]> at input line $.\n");
	}
}

#----------------------------------------------------------------------
# Simple Operators
#----------------------------------------------------------------------

sub asm_wvm_op($$$)																		# operations with simple arguments
{
	my($trg,$args,$opc) = @_;
	return undef unless ($OP eq $trg);													# don't do anything unless operation is a match

	$ROM[$ADDR++] = $opc;
	for (my($i)=0; $i<length($args); $i++) {
		my($atype) = substr($args,$i,1);
		if ($atype eq 'B') {															# Byte value
			die("Immediate byte value (#...) expected at input line $.\n")
				unless ($OP_ARG[$i] =~ m{^#});
			$ROM[$ADDR++] = $';
			next;
        } 
		if ($atype eq 'W') {															# Word value
			die("Immediate word value (#...) expected at input line $.\n")
				unless ($OP_ARG[$i] =~ m{^#});
			$ROM[$ADDR++] = $';
			$ROM[$ADDR++] = '16-BIT VALUE';
			next;
        } 
		if ($atype eq 'A') {															# Address word
			$ROM[$ADDR++] = $OP_ARG[$i];
			$ROM[$ADDR++] = '16-BIT VALUE';
			next;
        } 
		if ($atype eq 'a') {															# Zero-page address word
			$ROM[$ADDR++] = $OP_ARG[$i];
			next;
        } 
		if ($atype eq 'R') {															# Register
			$ROM[$ADDR++] = wvm_register_arg($i);
			next;
        } 
		if ($atype eq 'S') {															# Sound
			$ROM[$ADDR++] = wvm_sound_arg($i);
			next;
        } 
		if ($atype eq '$') {															# Score
			$ROM[$ADDR++] = wvm_score_arg($i);
			next;
        } 
		if ($atype eq 'T') {															# Thread
			$ROM[$ADDR++] = wvm_thread_arg($i);
			next;
        } 
    }
	return 1;
}

sub asm_wvm_bitOp($$)																	# flag and lamp operators
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);

	$ROM[$ADDR++] = $opc;
	die("Bit operator $OP requires at least one argument at input line $.\n")
		unless (@OP_ARG > 0);
	for (my($i)=0; $i<@OP_ARG-1; $i++) {
		$ROM[$ADDR++] = wvm_bit_arg($i,0x80);
    }
	$ROM[$ADDR++] = wvm_bit_arg($#OP_ARG);
	return 1;
}

sub asm_wvm_indOp($$$@)																	# bit operators with indirect addressing
{
	my($trg,$opc_dir,$opc_ind,$suppress_multiple_args) = @_;
	return undef unless ($OP eq $trg);

	if ($WMS_System == 7 && $suppress_multiple_args) {
		die("Bit operator $OP requires exactly one argument at input line $.\n")
			unless (@OP_ARG == 1);
	} else {
		die("Bit operator $OP requires at least one argument at input line $.\n")
			unless (@OP_ARG >= 1);
	}
	if ($OP_ARG[0] =~ m{^\[Reg}) {														# indirect addressing
		$ROM[$ADDR++] = $opc_ind;
		for (my($i)=0; $i<@OP_ARG-1; $i++) {
			$ROM[$ADDR++] = wvm_register_arg($i) | 0x80;
	    }
		$ROM[$ADDR++] = wvm_register_arg($#OP_ARG);
		return 1;
	}
	return asm_wvm_bitOp($trg,$opc_dir);
}

sub asm_wvm_grpOp($$)																	# bit group operators
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);

	die("Bitgroup operator $OP requires at least one argument at input line $.\n")
		unless (@OP_ARG >= 1);

	$ROM[$ADDR++] = $opc;
	for (my($i)=0; $i<@OP_ARG-1; $i++) {
		$ROM[$ADDR++] = wvm_bitgroup_arg($i,0x80);
    }
	$ROM[$ADDR++] = wvm_bitgroup_arg($#OP_ARG);
	return 1;
}

sub asm_wvm_jumpOp($$$)																	# optimizable jump operations
{
	my($trg,$opc,$branchtarget_mode) = @_;
#	print(STDERR "asm_wvm_jumpOp($trg,$opc,$branchtarget_mode)\n") if $opt_T;
	return undef unless ($OP eq $trg);													# don't do anything unless operation is a match

	set_label_type($current_mode);														# local($current_mode)==1 for !oneShot, 2 otherwise

	unless ($OP_ARG[$#OP_ARG] =~ m{^[#\$%0-9]}) {										# set type of branch target
		push(@newly_defined_label,($OP_ARG[$#OP_ARG]));
		set_label_type($branchtarget_mode);
    }                   

	$ROM[$ADDR++] = $opc;
	$ROM[$ADDR++] = $OPTIMIZABLE_LABEL_PREFIX . $TWELVE_BIT_LABEL_PREFIX . $OP_ARG[0];	# 12-bit offset
	$ROM[$ADDR++] = '16-BIT VALUE';
	return 1;
}

sub asm_wvm_cJumpOp($$)																	# optimizable conditional jump operators
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);

	set_label_type($current_mode);														# local($current_mode)==1 for !oneShot, 2 otherwise

	unless ($OP_ARG[$#OP_ARG] =~ m{^[#\$%0-9]}) {										# set type of branch target
		push(@newly_defined_label,($OP_ARG[$#OP_ARG]));
		set_label_type($current_mode);													# NB!
    }                   

	my($opc_addr) = $ADDR;
	$ROM[$ADDR++] = $opc;
	die("conditional jump operator $OP requires at least one argument at input line $.\n")
		unless (@OP_ARG > 0);
	wvm_parse_cExpr();
	$ROM[$ADDR] = sprintf('%d%s%s',														# NB: 8-bit offsets have byte offsets befroe the prefix character!
					$ADDR-$opc_addr,$OPTIMIZABLE_LABEL_PREFIX,$EIGHT_BIT_LABEL_PREFIX) . $OP_ARG[$#OP_ARG];	
	$ADDR++;
	$ROM[$ADDR++] = '16-BIT VALUE';
	return 1;
}

sub asm_wvm_cBranchOp($$)																# conditional branch operators (8-bit offsets)
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);

	set_label_type($current_mode);														# local($current_mode)==1 for !oneShot, 2 otherwise

	$ROM[$ADDR++] = $opc;
	die("conditional branch operator $OP requires at least one argument at input line $.\n")
		unless (@OP_ARG > 0);
	wvm_parse_cExpr();

	$OP_ARG[$#OP_ARG] = $LOOP_DONE_LBL[$#LOOP_DONE_LBL]									# _ExitLoop label
		if ($OP_ARG[$#OP_ARG] eq '_ExitLoop');
	$OP_ARG[$#OP_ARG] = $LOOP_LBL[$#LOOP_LBL]											# _NextLoop label
		if ($OP_ARG[$#OP_ARG] eq '_NextLoop');

	unless ($OP_ARG[$#OP_ARG] =~ m{^[#\$%0-9]}) {										# set type of branch target
		push(@newly_defined_label,($OP_ARG[$#OP_ARG]));
		set_label_type($current_mode);													# NB!
    }                   

	$ROM[$ADDR++] = $EIGHT_BIT_LABEL_PREFIX . $OP_ARG[$#OP_ARG];						# 8-bit branch offset
	return 1;
}

sub asm_wvm_switchOp($$)																# switch operators
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);

	$ROM[$ADDR++] = $opc;
	die("switch operator $OP requires at least one argument at input line $.\n")
		unless (@OP_ARG > 0);
	for (my($i)=0; $i<@OP_ARG-1; $i++) {
		$ROM[$ADDR++] = wvm_switch_arg($i) | 0x80;
    }
	$ROM[$ADDR++] = wvm_switch_arg($#OP_ARG);
	return 1;
}

sub asm_wvm_branchOp($$$)																# branch operators (12-bit address)
{
    my($trg,$opc,$branchtarget_mode) = @_;
    return undef unless ($OP eq $trg);

	set_label_type($current_mode);														# local($current_mode)==1 for !oneShot, 2 otherwise

	die("unconditional branch operator $OP requires one argument at input line $.\n")
	        unless (@OP_ARG == 1);
	$ROM[$ADDR++] = $opc;	

	$OP_ARG[$#OP_ARG] = $LOOP_DONE_LBL[$#LOOP_DONE_LBL]											# _ExitLoop label
		if ($OP_ARG[$#OP_ARG] eq '_ExitLoop');
	$OP_ARG[$#OP_ARG] = $LOOP_LBL[$#LOOP_LBL]													# _NextLoop label
		if ($OP_ARG[$#OP_ARG] eq '_NextLoop');

	unless ($OP_ARG[$#OP_ARG] =~ m{^[#\$%0-9]}) {												# set type of branch target
		push(@newly_defined_label,($OP_ARG[$#OP_ARG]));
		set_label_type($branchtarget_mode);
    }                   

	$ROM[$ADDR++] = $TWELVE_BIT_LABEL_PREFIX . $OP_ARG[$#OP_ARG];								# prepend label to mark as 12-bit relative address
	
	return 1;
}

#----------------------------------------------------------------------
# Complex Operations
#----------------------------------------------------------------------

sub asm_wvm_dRABop($$)																	# decAndBranchUnless0
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);													# don't do anything unless operation is a match

	$ROM[$ADDR++] = $opc;																# opcode
	$ROM[$ADDR++] = wvm_register_arg(0)<<4;												# register argument in upper nibble of first argument byte
	$ROM[$ADDR++] = $TWELVE_BIT_LABEL_PREFIX . $OP_ARG[1];								# lower 8 bits of 12-bit branch label
	return 1;
}

sub encode_scoreByte($$)
{
	my($str,$src_line) = @_;

	$str =~ s/[Mm]/000000/g;													# decode M symbol
	$str =~ s/[Kk]/000/g;														# decode K symbol

	my($mult,$expo);
	if ($str =~ m{(.*)x(10*)}) {												# long form
		$mult = $1; 
		$expo = length($2)-1;
		die("encode_scoreByte: invalid score-value <$str> at input line $src_line") 	# range check
			unless ($expo >= 0) && ($expo <= 5);
    } else {																	# short form
		($mult) = ($str =~ m{([^0]*)});
		$expo = length($');
		die("encode_scoreByte: invalid score-value <$str> at input line $src_line") 
			unless ($str =~ m{[1-9]0*}) && ($expo >= 0) && ($expo <= 7);
    }
    return ($mult<<3)|$expo;
}

sub encode_solControl($$)
{
	my($str,$err_loc) = @_;
	my($val);
	
	my($sol,$cmd) = ($str =~ m{^Sol#([A-Fa-f0-9]{2}):(.*)$});
	if (defined($sol) && defined($cmd)) {
		die("Invalid solenoid number in <$str> at $err_loc\n")
			unless (hex($sol) >= 0 && hex($sol) <= 0x1F);
		$val = hex($sol);
	} else {
		($sol,$cmd) = ($str =~ m{^(\d+):(.*)$});
		die("Cannot decode solenoid control argument <$str> at $err_loc\n")
			unless defined($sol) && defined($cmd);
		die("Invalid solenoid number in <$str> at $err_loc\n")
			unless ($sol >= 0 && $sol <= 0x1F);
		$val = $sol;
	}
	if 	  ($cmd eq 'off') 	 	{ $val |= 0x00; }
	elsif ($cmd eq '1-tictoc')  { $val |= 0x20; }
	elsif ($cmd eq '2-tictocs') { $val |= 0x40; }
	elsif ($cmd eq '3-tictocs') { $val |= 0x60; }
	elsif ($cmd eq '4-tictocs') { $val |= 0x80; }
	elsif ($cmd eq '5-tictocs') { $val |= 0xA0; }
	elsif ($cmd eq '6-tictocs') { $val |= 0xC0; }
	elsif ($cmd eq 'on')  		{ $val |= 0xE0; }
	else {
		die("cannot decode solenoid control argument <$str> at $err_loc\n");
	}
	return $val;
}

sub asm_wvm_solControl($$)
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);	

	$ROM[$ADDR++] = $opc + @OP_ARG;														# opcode
	die("Solenoid control operator $OP requires at least one argument at input line $.\n")
		unless (@OP_ARG > 0);
	for (my($i)=0; $i<@OP_ARG; $i++) {
		$ROM[$ADDR++] = encode_solControl($OP_ARG[$i],"input line $.");
	}
	return 1;
}

{ my($begin6800,$previous_exec6800_block_id);

	sub asm_wvm_exec6800op(@)
	{
		my($trg,$opc) = @_;
		return undef unless ($OP eq $trg);
	
		if (defined($opc)) {																# begin6800
			die("Invalid begin6800 at input line $.\n")
				if defined($begin6800);
			$begin6800 = $ADDR;
			$ROM[$ADDR++] = $opc;
			$EXEC6800_BLOCK_ID = $previous_exec6800_block_id + 1;
		} else {																			# end6800
			die("Invalid end6800 at input line $.\n")
				unless ($begin6800 >= 0);
			my($nbytes) = $ADDR - $begin6800 - 1;
			die("bad number of bytes ($nbytes) for begin6800/end6800 at input line $.\n")
				unless ($nbytes>=2 && $nbytes <=13);
			$ROM[$begin6800] += $nbytes - 2; 
			undef($begin6800);
			$previous_exec6800_block_id = $EXEC6800_BLOCK_ID;
			$EXEC6800_BLOCK_ID = 0;
		}
		return 1; 
	}
}

sub asm_wvm_sleep($@)
{
	my($trg,$use_long_opc) = @_;
	return undef unless ($OP eq $trg);											

	die("sleep operator requires one argument at input line $.\n")
		unless (@OP_ARG == 1);
	die("invalid sleep argument $OP_ARG[0] at input line $.\n")
		if ($OP_ARG[0] =~ m{^#\[});

	$OP_ARG[0] =~ s{^#}{};																# immediate addressing (# optional)

	if ($OP_ARG[0] =~ m{^\[(.*)\]$}) {													# indirect addressing mode
		$OP_ARG[0] = $1;
		$ROM[$ADDR++] = 0x60 + wvm_register_arg(0);
		return 1;
	}

	if ($OP_ARG[0] <= 0x0F && !$use_long_opc) {											# short sleep
		$ROM[$ADDR++] = 0x70 + $OP_ARG[0];
		return 1;
	}

	if ($OP_ARG[0] <= 0xFF) {															# long sleep
		printf(STDERR "%5d: WARNING: optimizable statement $SRC[$ADDR]\n",$LINE[$ADDR])
			if ($opt_v && $OP_ARG[0]<=0x0F);
		$ROM[$ADDR++] = 0x53;
		$ROM[$ADDR++] = $OP_ARG[0];
		return 1;
	}

	die("Invalid argument to sleep <@OP_ARG> at input line $.\n");
}


sub asm_wvm_playSound($$)
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);								

	die("playSound requires one argument at input line $.\n")
		unless (@OP_ARG == 1);

	my($sound,$times) = ($OP_ARG[0] =~ m{^(.*):(\d+)x$});

	if (defined($times)) {																# repeated sound
		die("Invalid argument to playSound <@OP_ARG> at input line $.\n")
			unless ($times>=1 && $times<=15);
		$OP_ARG[0] = $sound;
		$ROM[$ADDR++] = 0xD0 + $times;
		$ROM[$ADDR++] = wvm_sound_arg(0);
		return 1;
	}

	my($sound) = wvm_sound_arg(0);														# non-repeated sound
	die("Sound number <$sound> out of range for non-repeated playSound at input line $.\n")
		unless ($sound >= 0 && $sound <= 0x1F);
	$ROM[$ADDR++] = 0xE0 + $sound;			
	return 1;
}


sub asm_wvm_store($)																	# store Reg-A/B <zero-page address>
{
	my($trg) = @_;
	return undef unless ($OP eq $trg);								

	die("Operation $OP not available in System 7 at input line $.\n")
		if ($WMS_System == 7);
	die("Syntax: store <Reg-A|Reg-B> <Zero-Page Address> at input line $.\n")
		unless (@OP_ARG == 2) &&
			   ((wvm_register_arg(0) == 0) ||
			   	(wvm_register_arg(0) == 1));
	$ROM[$ADDR++] = wvm_register_arg(0) ? 0x0F : 0x0D;
	$ROM[$ADDR++] = $OP_ARG[1];
	return 1;
}


sub asm_wvm_load($)																		# load Reg-A/B <zero-page address> | Reg #val
{
	my($trg) = @_;
	return undef unless ($OP eq $trg);								

	die("Syntax: load <Reg-A|Reg-B> <Zero-Page Address> | <Reg-?> <#Byte> at input line $.\n")
		unless (@OP_ARG == 2);
	my($reg) = wvm_register_arg(0);
	if ($OP_ARG[1] =~ m{^#}) {															# Reg #val
		$ROM[$ADDR++] = 0xC0 + $reg;
		$ROM[$ADDR++] = $';
	} elsif ($OP_ARG[1] =~ m{^Reg-}) {													# Reg Reg
		my($sReg) = wvm_register_arg(1);
		$ROM[$ADDR++] = 0x51;
		$ROM[$ADDR++] = $reg<<4 | $sReg;
	} else {																			# Reg-A/B <zero page address>
		die("Syntax: load <Reg-A|Reg-B> <Zero-Page Address> at input line $.\n")
			unless ($reg==0 || $reg==1);
		die("Operation <$OP @OP_ARG> not available in System 7 at input line $.\n")
			if ($WMS_System == 7);
		$ROM[$ADDR++] = $reg ? 0x0E : 0x0C;
		$ROM[$ADDR++] = $OP_ARG[1];
	}
	return 1;
}

sub asm_wvm_addTo($)																	# addTo Reg <#signed byte value> | Reg Reg
{
	my($trg) = @_;
	return undef unless ($OP eq $trg);								

	die("Syntax: addTo <Reg-?> <Reg-?> | <Reg-?> <#Byte> at input line $.\n")
		unless (@OP_ARG == 2);
	my($reg) = wvm_register_arg(0);	
	if ($OP_ARG[1] =~ m{^#}) {															# Reg #val
		$ROM[$ADDR++] = 0xB0 + $reg;
		$ROM[$ADDR++] = $';
	} else {																			# Reg Reg
		$ROM[$ADDR++] = 0x50;
		$ROM[$ADDR++] = $reg<<4 + wvm_register_arg(1);
	}
	return 1;
}

sub asm_wvm_copyTo($$)																	# copyTo Reg Reg
{
	my($trg,$opc) = @_;
	return undef unless ($OP eq $trg);								

	die("Syntax: copyTo <Reg-?> <Reg-?> at input line $.\n")
		unless (@OP_ARG == 2);
	$ROM[$ADDR++] = $opc;
	$ROM[$ADDR++] = wvm_register_arg(0)<<4 | wvm_register_arg(1);
	return 1;
}

#----------------------------------------------------------------------
# Main WVM Compiler Routine
#----------------------------------------------------------------------

sub compile_vm($)
{
	local($current_mode) = @_;															# 1 for !oneShot, 2 for normal
	
#	print(STDERR "compile_vm(MODE=$MODE): $OP @OP_ARG\n");
	if ($System_Option{IVM} >= 2) {
		$MODE=$current_mode,return 1 if asm_wvm_op('displayStr' 	,'WB'	,0x3F);
		$MODE=$current_mode,return 1 if asm_wvm_op('incAudit'		,'W'	,0x23);
		$MODE=$current_mode,return 1 if asm_wvm_op('soundcardCmd'	,'B'	,0x27);
	} else {
		die("IVM: Invalid stage-2 opCode at input line $.\n")
			if asm_wvm_op('soundcardCmd'	,'' 	,0x00) ||
			   asm_wvm_op('displayStr'		,'' 	,0x23) ||
			   asm_wvm_op('incAudit'		,'' 	,0x27);
    }

	$MODE=0,return 1 if asm_wvm_op('halt'					,''		,0x00);
	$MODE=$current_mode,return 1 if asm_wvm_op('noOperation'			,''		,0x01);
	$MODE=0,return 1 if asm_wvm_op('return'					,''		,0x02);
	$MODE=0,return 1 if asm_wvm_op('exitThread'				,''		,0x03);
	$MODE=1,return 1 if asm_wvm_op('M6800_mode'				,''		,0x04);
	$MODE=$current_mode,return 1 if asm_wvm_op('awardSpecial'			,''		,0x05);
	$MODE=$current_mode,return 1 if asm_wvm_op('awardExtraball'			,''		,0x06);
	if ($WMS_System == 11) {
		$MODE=$current_mode,return 1 if asm_wvm_op('spawnThread6800'	,'TA'	,0x07);
		$MODE=$current_mode,return 1 if asm_wvm_op('spawnThread6800_id06','A'	,0x08);
		$MODE=$current_mode,return 1 if asm_wvm_op('spawnThread'		,'TA'	,0x09);
		$MODE=$current_mode,return 1 if asm_wvm_op('spawnThread_id06'	,'A'	,0x0A);
		$MODE=$current_mode,return 1 if asm_wvm_dRABop('decAndBranchUnlessZero'	,0x0B);	
		$MODE=$current_mode,return 1 if asm_wvm_dRABop('decAndBranchUnless0'	,0x0B);	# alt
		$MODE=$current_mode,return 1 if asm_wvm_store('store');					#  0D, 0F
	}

	$MODE=$current_mode,return 1 if asm_wvm_indOp('setBits'				  ,0x10	,0x14);
	$MODE=$current_mode,return 1 if asm_wvm_indOp('clearBits'			  ,0x11	,0x15);
	$MODE=$current_mode,return 1 if asm_wvm_indOp('toggleBits'			  ,0x12	,0x16);
	$MODE=$current_mode,return 1 if asm_wvm_indOp('setBitsBlinkbuf'		  ,0x13	,0x17);
	$MODE=$current_mode,return 1 if asm_wvm_indOp('blinkLamps'			  ,0x13	,0x17);	# alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('setBitgroups'				,0x18);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('clearBitgroups'				,0x19);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('fillBitgroups'				,0x1A);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('fillWrapBitgroups'			,0x1B);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('drainBitgroups' 				,0x1C);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('rotLeftBitgroups'			,0x1D);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('rotRightBitgroups'			,0x1E);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('toggleBitgroups'				,0x1F);

	if ($WMS_System == 7) {																			# system 7
		$MODE=$current_mode,return 1 if asm_wvm_indOp('setBitAltbuf'	  ,0x20 ,0x24,1);
		$MODE=$current_mode,return 1 if asm_wvm_indOp('setAltbuf'		  ,0x20 ,0x24,1); # alt
		$MODE=$current_mode,return 1 if asm_wvm_indOp('clearBitAltbuf' 	  ,0x21 ,0x25,1);
		$MODE=$current_mode,return 1 if asm_wvm_indOp('clearAltbuf' 	  ,0x21 ,0x25,1); # alt
		$MODE=$current_mode,return 1 if asm_wvm_indOp('toggleBitAltbuf'	  ,0x22 ,0x26,1);
		$MODE=$current_mode,return 1 if asm_wvm_indOp('toggleAltbuf'	  ,0x22 ,0x26,1); # alt
	} elsif ($WMS_System == 11) {																	# system 11
		$MODE=$current_mode,return 1 if asm_wvm_indOp('setBitsAltbuf'	  ,0x20 ,0x24);
		$MODE=$current_mode,return 1 if asm_wvm_indOp('setAltbuf'		  ,0x20 ,0x24); # alt
		$MODE=$current_mode,return 1 if asm_wvm_indOp('clearBitsAltbuf'   ,0x21 ,0x25);
		$MODE=$current_mode,return 1 if asm_wvm_indOp('clearAltbuf' 	  ,0x21 ,0x25); # alt
		$MODE=$current_mode,return 1 if asm_wvm_indOp('toggleBitsAltbuf'  ,0x22 ,0x26);
		$MODE=$current_mode,return 1 if asm_wvm_indOp('toggleAltbuf'	  ,0x22 ,0x26); # alt
    }
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('setBitgroupsAltbuf'			,0x28);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('setLampgroupsAltbuf'			,0x28); # alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('clearBitgroupsAltbuf'		,0x29);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('clearLampgroupsAltbuf'		,0x29); # alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('fillBitgroupsAltbuf' 		,0x2A);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('fillLampgroupsAltbuf'		,0x2A); # alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('fillWrapBitgroupsAltbuf' 	,0x2B);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('fillWrapLampgroupsAltbuf'	,0x2B); # alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('drainBitgroupsAltbuf'		,0x2C);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('drainLampgroupsAltbuf'		,0x2C); # alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('rotLeftBitgroupsAltbuf'		,0x2D);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('rotLeftLampgroupsAltbuf'		,0x2D); # alt
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('rotRightBitgroupsAltbuf' 	,0x2E);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('rotRightLampgroupsAltbuf'	,0x2E); # alt
    $MODE=$current_mode,return 1 if asm_wvm_grpOp('toggleBitgroupsAltbuf'       ,0x2F);
	$MODE=$current_mode,return 1 if asm_wvm_grpOp('toggleLampgroupsAltbuf' 		,0x2F); # alt
    
	$MODE=$current_mode,return 1 if asm_wvm_solControl('solControl'				,0x30); # to 3F

	$MODE=$current_mode,return 1 if asm_wvm_op('playSound_score'		,'S$'	,0x40);
	$MODE=$current_mode,return 1 if asm_wvm_op('queueScore'				,'$'	,0x41);
	$MODE=$current_mode,return 1 if asm_wvm_op('score' 					,'$'	,0x42);
	$MODE=$current_mode,return 1 if asm_wvm_op('score_digitSound'		,'$'	,0x43);
	$MODE=1,return 1 			 if asm_wvm_exec6800op('begin6800'				,0x44); # to 4F
	
	$MODE=$current_mode,return 1 if asm_wvm_addTo('addTo');					   # 0x50	# and  B0-BF
	$MODE=$current_mode,return 1 if asm_wvm_copyTo('copyTo'						,0x51);	# alt (canonical handled by load below)
	$MODE=$current_mode,return 1 if asm_wvm_op('setThreadId'			,'T'	,0x52);
	$MODE=$current_mode,return 1 if asm_wvm_op('setThreadFlags'			,'T'	,0x52);	# duplicate mnemonic
	$MODE=$current_mode,return 1 if asm_wvm_sleep('sleep'); 			       # 0x53	# and 60-6F 70-7F (chose opcode based on argument)
	$MODE=$current_mode,return 1 if asm_wvm_sleep('longSleep',1); 			   # 0x53	# should be used only by [D711.pm]
	$MODE=$current_mode,return 1 if asm_wvm_sleep('sleep_subOptimal',1); 	   # 0x53	# alt
	$MODE=$current_mode,return 1 if asm_wvm_op('killThread'				,'BT'	,0x54);
	$MODE=$current_mode,return 1 if asm_wvm_op('killThreads'			,'BT'	,0x55);
	$MODE=$current_mode,return 1 if asm_wvm_jumpOp('jumpSubroutine'				,0x56,2);
	$MODE=$current_mode,return 1 if asm_wvm_jumpOp('jumpSubroutine6800'			,0x57,1);
	$MODE=$current_mode,return 1 if asm_wvm_cJumpOp('jumpIf'					,0x58);
	$MODE=$current_mode,return 1 if asm_wvm_cJumpOp('jumpUnless'				,0x59);
	$MODE=$current_mode,return 1 if asm_wvm_cBranchOp('branchIf'				,0x5A);
	$MODE=$current_mode,return 1 if asm_wvm_cBranchOp('branchUnless'			,0x5B);
	$MODE=0,return 1 			 if asm_wvm_op('jump6800'				,'A'	,0x5C);
	$MODE=$current_mode,return 1 if asm_wvm_switchOp('triggerSwitches'			,0x5D);
	$MODE=$current_mode,return 1 if asm_wvm_switchOp('clearSwitches'			,0x5E);
	$MODE=0,return 1 			 if asm_wvm_jumpOp('jump'						,0x5F,2);

																	# 60-7F handled by sleep

	$MODE=0,return 1 			 if asm_wvm_branchOp('branch'	 				,0x80,2);	# to 8F
	$MODE=$current_mode,return 1 if asm_wvm_branchOp('branchSubroutine'			,0x90,2);	# to 9F
	$MODE=$current_mode,return 1 if asm_wvm_branchOp('branchSubroutine6800'		,0xA0,1);	# to AF

	$MODE=$current_mode,return 1 if asm_wvm_load('load');						#0xC0 to CF, 0C, 0E, 51
	
	$MODE=$current_mode,return 1 if asm_wvm_playSound('playSound',				,0xD0); # to FF
	return undef;
}

1;
