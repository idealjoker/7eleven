#======================================================================
#                    D 7 1 1 . W P C _ D M D 
#                    doc: Thu Jul 18 06:34:49 2024
#                    dlm: Thu Aug 15 12:18:20 2024
#                    (c) 2024 idealjoker@mailbox.org
#                    uE-Info: 136 69 NIL 0 0 72 2 2 4 NIL ofnI
#======================================================================

# WPC Disassembly 

# HISTORY:
#	Jul 18, 2024: - created; WMS CPU vectors disassemble correctly
#	Aug  9, 2024: - continued
#	Aug 10, 2024: - added support for ROM pages
#	Aug 11, 2024: - System Call Pointers disassemble correctly
#				  - BUG: WMS CPU vectors no longer disassemble correctly
#	Aug 12, 2024: - added support for system strings
#	Aug	14, 2024: - imported WPC specific code from [D711.pm]
#	Aug 15, 2024: - BUG: def_WPC_codePtr() did not define target labels

#----------------------------------------------------------------------
# WPC API
#----------------------------------------------------------------------

require "$PATH/WPC_DMD.API";

#----------------------------------------------------------------------
# Game Disassembly Routine
#----------------------------------------------------------------------

sub disassemble_WPC_DMD()
{
	my($dasm_CPU_vectors) 		= 1;
	my($dasm_system_pointers) 	= 1;

	if ($dasm_CPU_vectors) {
		$Address = 0xFFF0;														# CPU vectors
		insert_divider($Address,'CPU Vectors');
	
		def_code_ptr('RESERVED_vector','RESERVED_handler','CPU Vector Handler');	
		def_code_ptr('SWI3_vector','SWI3_handler','CPU Vector Handler');
		def_code_ptr('SWI2_vector','SWI2_handler','CPU Vector Handler');			
		def_code_ptr('FIRQ_vector','FIRQ_handler','CPU Vector Handler');
		def_code_ptr('IRQ_vector','IRQ_handler','CPU Vector Handler');
		def_code_ptr('SWI_vector','SWI_handler','CPU Vector Handler');
		def_code_ptr('NMI_vector','NMI_handler','CPU Vector Handler');				
	    def_code_ptr('RST_vector','RST_handler','CPU Vector Handler');				
    }

	if ($dasm_system_pointers) {
		$Address = 0x8000;
		insert_divider($Address,'Bank Id');
		def_byte_hex('_ROMPG_SYS1_ID');

		insert_divider($Address,'System Call Pointers');
		while ($Address < 0x812D) {
			my($taddr) = sprintf('%04X',WORD($Address));
			my($trpg) = sprintf('%02X',BYTE($Address+2));
			def_WPC_codePtr("syscall_$taddr",'System Call');
		}

		$Address = 0x8133;
		insert_divider($Address,'System Data Pointers');
		def_WPC_stringPtr('sysstr_gameName','System String');
		def_WPC_stringPtr('sysstr_gameNumber','System String');
		def_WPC_stringPtr('sysstr_buildDate','System String');

#		$Address = 0x81C5;
#		my($addr) = def_ptr('^sys_switchTable');
#		def_WPC_switchTable('sys_switchTable','Switch Table');

#		$Address = 0x8285;
#		my($addr) = def_ptr('^sys_fontTable');
#		def_WPC_fontTable('sys_fontTable','Font Table');

#		$Address = 0x8288;
#		my($addr) = def_ptr('^sys_DMDtable');
#		def_WPC_DMDTable('sys_DMDtable','DMD Table');
	}
}

#----------------------------------------------------------------------
# Post Disassembly Magic
#----------------------------------------------------------------------

sub apply_magic_WPC_DMD($$)
{
	my($fa,$la) = @_;

	for (my($addr)=$fa; $addr<=$la-1; $addr++) {
		if ($OP[$addr] eq 'JSR' && $OPA[$addr][0] eq 'sys_JSRPG') {
			$OP[$addr] = '_JSR';
			@{$OPA[$addr]} = @{$OPA[$addr+3]};
			undef($OP[$addr+3]);
		}
	}
}

#----------------------------------------------------------------------
# Init Disassembly System
#----------------------------------------------------------------------

sub init_WPC_DMD()
{
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','sys_runtime_error','.DB','B'));	# keep in sync with [WPC_DMD.API]
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_82B6','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_82F2','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_82FF','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8385','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8346','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8319','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_83DB','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_83E8','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_842B','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8480','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_848F','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_84AD','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8546','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_85F1','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8553','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_85B2','.DB','B'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_865B','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8679','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8690','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8715','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8722','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_87BE','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_88D5','.DW','W'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','sys_JSRPG','.DWB','R'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_89DD','.DWB','WB'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8A9A','.DW','WW'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8AAA','.DW','WW'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8ABA','.DW','WW'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8ACA','.DW','WW'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8B3D','.DBW','BWW'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8B77','.DWWB','WR'));			# R unsure
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8B9D','.DWWB','WR'));			# R unsure
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_8BF7','.DWWB','WR'));			# R unsure
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_D799','.DWBW','WBW'));
	push(@INLINE_ARG_SBR,sprintf('%s-%s-%s','syscall_FDFC','.DB','B'));
}

#======================================================================
# WPC Disassembly Library
#======================================================================

#----------------------------------------------------------------------
# ROM Paging
#----------------------------------------------------------------------

sub select_WPC_RPG($)
{
	my($RPG) = @_;

#	printf(STDERR "RPG %02X($_cur_RPG) -> %02X($RPG)\n",$_cur_RPG,$RPG);
	return $_cur_RPG if ($RPG == 0xFF || $RPG == $_cur_RPG);
	die unless defined($RPG);
	
	@{$OPPG[$_cur_RPG]} 	 	= @OP[0x4000..0x7FFF];									# swap out active page
	@{$INDPG[$_cur_RPG]}	 	= @IND[0x4000..0x7FFF]; 		    
	@{$TYPEPG[$_cur_RPG]}	 	= @TYPE[0x4000..0x7FFF];		    
	@{$OPAPG[$_cur_RPG]}	 	= @OPA[0x4000..0x7FFF]; 		    
	@{$REMPG[$_cur_RPG]}	 	= @REM[0x4000..0x7FFF]; 		    
	@{$EXTRAPG[$_cur_RPG]}	 	= @EXTRA[0x4000..0x7FFF]; 		    
	@{$LBLPG[$_cur_RPG]}	 	= @LBL[0x4000..0x7FFF]; 		    
	@{$AUTO_LBLPG[$_cur_RPG]} 	= @AUTO_LBL[0x4000..0x7FFF]; 		    
	@{$decodedPG[$_cur_RPG]} 	= @decoded[0x4000..0x7FFF];
	@{$ROMPG[$_cur_RPG]}	 	= @ROM[0x4000..0x7FFF]
		unless(@{$ROMPG[$_cur_RPG]});
    
	@OP[0x4000..0x7FFF]			= @{$OPPG[$RPG]};										# swap in new page
	@IND[0x4000..0x7FFF] 		= @{$INDPG[$RPG]};
	@TYPE[0x4000..0x7FFF]		= @{$TYPEPG[$RPG]};
	@OPA[0x4000..0x7FFF] 		= @{$OPAPG[$RPG]};
	@REM[0x4000..0x7FFF] 		= @{$REMPG[$RPG]};
	@EXTRA[0x4000..0x7FFF] 		= @{$EXTRAPG[$RPG]};
	@LBL[0x4000..0x7FFF] 		= @{$LBLPG[$RPG]};
	@AUTO_LBL[0x4000..0x7FFF] 	= @{$AUTO_LBLPG[$RPG]};
	@decoded[0x4000..0x7FFF] 	= @{$decodedPG[$RPG]};
	if (@{$ROMPG[$RPG]}) {
		@ROM[0x4000..0x7FFF]	= @{$ROMPG[$RPG]};										# copy from page buffer
	} else {
		load_ROM($ARGV[0],0x4000,$RPG,16);												# load from file
	}
	
	my($oRPG) = $_cur_RPG;
    $_cur_RPG = $RPG;

	unless ($decoded[0x4000]) {															# decode page id
		my($oA) = $Address;
		$Address = 0x4000;
		def_byte_hex('_ROMPG_ID',sprintf('ROM PAGE %02X',$_cur_RPG));
		$Address = $oA;
	}
	
    return $oRPG;
}

#----------------------------------------------------------------------
# Strings
#----------------------------------------------------------------------

sub decode_WPC_STR_char($)
{
	my($c) = BYTE($_[0]);

	return sprintf('%c',$c)																		# printable ASCII
		if ($c >= 32 && $c < 127);
	return sprintf('\\%02X',$c);																# non-printable
}

sub def_WPC_string(@)
{
	my($lbl,$divider_label,$rem) = @_;

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	insert_divider($Address,$divider_label);
	$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	$lbl .= sprintf('[%02X]',$_cur_RPG)
		unless ($_cur_RPG == 0xFF);
	setLabel($lbl,$Address);
    $Address+=$len,return unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    
	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$OP[$Address] = '.STR';
	my($o);
	$OPA[$Address][0] = "'";
	for ($o=0; BYTE($Address+$o)!=0; $o++) {
		$OPA[$Address][0] .= decode_WPC_STR_char($Address+$o);
		$decoded[$Address+$o] = 1;
	}
	$decoded[$Address+$o] = 1;
	$OPA[$Address][0] .= "'";
	$Address += $o;
}   
		    
sub def_WPC_stringPtr($@)														# DOES NOT MAINTAIN RPG
{																			
	my($str_lbl,$divider_title,$rem) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die("def_WPC_stringPtr(): addresses below 0x8000 not supported (implementation restriction)")
    	unless ($Address >= 0x8000);

	my($str_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
	select_WPC_RPG($RPG);

	$str_lbl = $` if ($str_lbl =~ m{\[[0-9A-F]{2}\]$});            					# remove previous RPG if there is one
	$str_lbl .= sprintf('[%02X]',$_cur_RPG)
		unless ($_cur_RPG == 0xFF);
	setLabel("^$str_lbl",$Address);
	
	my($usr_lbl) = $LBL[$str_addr];
	$str_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($str_lbl,$str_addr);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $codeType_data;
	$OPA[$Address][0] = $str_lbl; 
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	my($sAddr) = $Address;
	$Address = $str_addr;
	def_WPC_string($str_lbl);
	$Address = $sAddr + 3;
}

#----------------------------------------------------------------------
# Code
#----------------------------------------------------------------------

sub def_WPC_codePtr($@)																	# ROUTINE DOES NOT MAINTAIN RPG
{
	my($code_lbl,$divider_title,$rem) = @_;
	die unless defined($Address);

	setLabel("^$code_lbl",$Address);
    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
	my($code_addr) = WORD($Address);

	my($RPG) = BYTE($Address+2);
#	print(STDERR "select_WPC_RPG($RPG);\n");
	select_WPC_RPG($RPG);

	$code_lbl = $` if ($code_lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	$code_lbl .= sprintf('[%02X]',$_cur_RPG)
		unless ($_cur_RPG == 0xFF);
	
	my($usr_lbl) = $LBL[$code_addr];
	$code_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($code_lbl,$code_addr);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$OPA[$Address][0] = $code_lbl; 
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	disassemble_asm($code_base_indent,$code_addr,$code_lbl,$divider_label);
	$Address += 3;
}

#----------------------------------------------------------------------

1; 																# return true

