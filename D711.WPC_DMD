#======================================================================
#                    D 7 1 1 . W P C _ D M D 
#                    doc: Thu Jul 18 06:34:49 2024
#                    dlm: Tue Aug 27 14:45:47 2024
#                    (c) 2024 idealjoker@mailbox.org
#                    uE-Info: 30 29 NIL 0 0 72 10 2 4 NIL ofnI
#======================================================================

# WPC Disassembly 

# HISTORY:
#	Jul 18, 2024: - created; WMS CPU vectors disassemble correctly
#	Aug  9, 2024: - continued
#	Aug 10, 2024: - added support for ROM pages
#	Aug 11, 2024: - System Call Pointers disassemble correctly
#				  - BUG: WMS CPU vectors no longer disassemble correctly
#	Aug 12, 2024: - added support for system strings
#	Aug	14, 2024: - imported WPC specific code from [D711.pm]
#	Aug 15, 2024: - BUG: def_WPC_codePtr() did not define target labels
#	Aug 16, 2024: - many improvements; now switch table disassembles w/o errors
#	Aug 17, 2024: - many improvements
#	Aug 18, 2024: - BUG: API loaded before ROM
#	Aug 19, 2024: - added _skip
#				  - started adapting to ! WPC shortcut
#	Aug 21, 2024: - BUG: EXTRA_IND, EXTRA_BEFORE_LABEL and EXTRA_AFTER_OP where not
#						 paged in and out
#	Aug 23, 2024: - decimalized !*Sleep args
#	Aug 25, 2024: - renamed addScore because it was wrnog
#				  - BUG: substr used wrong length arg
#	Aug 27, 2024: - additions
# END OF HISTORY 

#----------------------------------------------------------------------
# Game Disassembly Routine
#----------------------------------------------------------------------

sub disassemble_WPC_DMD()
{
	require "$PATH/WPC_DMD.API";												# define API after ROM has been loaded

	my($dasm_CPU_vectors) 		= 1;
	my($dasm_system_pointers) 	= 1;
	my($dasm_switchTable)		= 1;
	my($dasm_fontTable)			= 0;
	my($dasm_DMDtable)			= 0;

	if ($dasm_CPU_vectors) {
		$Address = 0xFFF0;														# CPU vectors
		insert_divider($Address,'CPU Vectors');
	
		def_code_ptr('RESERVED_vector','RESERVED_handler','CPU Vector Handler');	
		def_code_ptr('SWI3_vector','SWI3_handler','CPU Vector Handler');
		def_code_ptr('SWI2_vector','SWI2_handler','CPU Vector Handler');			
		def_code_ptr('FIRQ_vector','FIRQ_handler','CPU Vector Handler');
		def_code_ptr('IRQ_vector','IRQ_handler','CPU Vector Handler');
		def_code_ptr('SWI_vector','SWI_handler','CPU Vector Handler');
		def_code_ptr('NMI_vector','NMI_handler','CPU Vector Handler');				
	    def_code_ptr('RST_vector','RST_handler','CPU Vector Handler');				
    }

	if ($dasm_system_pointers) {
		$Address = 0x8000;
		insert_divider($Address,'Bank Id');
		def_byte_hex('_ROMPG_SYS1_ID');

		insert_divider($Address,'System Call Pointers');
		while ($Address < 0x812D) {
			my($taddr) = sprintf('%04X',WORD($Address));
			my($trpg) = sprintf('%02X',BYTE($Address+2));
			def_WPC_codeRef("syscall_$taddr",'System Call');
		}

		$Address = 0x8133;
		insert_divider($Address,'System Data Pointers');
		def_WPC_stringRef('sysstr_gameName','System String');
		def_WPC_stringRef('sysstr_gameNumber','System String');
		def_WPC_stringRef('sysstr_buildDate','System String');

		$Address = 0x813C;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_1');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_WORD_1');

		$Address = 0x813F;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_1');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_WORD_1');

		$Address = 0x8142;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_1');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_WORD_1');

		$Address = 0x8145;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_1');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_1');

		$Address = 0x814E;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_1');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_1');

		$Address = 0x8151;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_1');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_1');

		$Address = 0x8157;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_2');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_2');

		$Address = 0x815A;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_3');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_3');

		$Address = 0x8166;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_1');
			$Address = WORD($Address-2); def_word_hex('_UNKNOWN_SYSTEM_WORD_1');

		$Address = 0x8184;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_2');
			$Address = WORD($Address-2); def_word_hex('_UNKNOWN_SYSTEM_WORD_2');

		$Address = 0x8187;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_2');
			$Address = WORD($Address-2); def_word_hex('_UNKNOWN_SYSTEM_WORD_2');

		$Address = 0x818A;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_3');
			$Address = WORD($Address-2); def_word_hex('_UNKNOWN_SYSTEM_WORD_3');

		$Address = 0x8190;
		def_ptr_hex('^_UNKNOWN_SYSTEM_WORD_4');
			$Address = WORD($Address-2); def_word_hex('_UNKNOWN_SYSTEM_WORD_4');

		$Address = 0x8193;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_4');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_4');

		$Address = 0x8199;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_5');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_5');

		$Address = 0x819C;
		def_ptr_hex('^=UNKNOWN_SYSTEM_TABLE_1');
			$Address = WORD($Address-2); def_wordblock_hex(8,'=UNKNOWN_SYSTEM_TABLE_1','System Table');

		$Address = 0x819F;
		def_ptr_hex('^_UNKNOWN_SYSTEM_BYTE_5');
			$Address = WORD($Address-2); def_byte_hex('_UNKNOWN_SYSTEM_BYTE_5');

		$Address = 0x8296;
		def_ptr_hex('^=STATUS_AREA');
		insert_divider($Address,'System Code');
	}

	if ($dasm_switchTable) {
		$Address = 0x81C5;
		$Address = def_WPC_ref('=SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table');					# label already defined
	}

	if ($dasm_fontTable) {
		$Address = 0x8285;
		my($addr) = def_ptr('^sys_fontTable');
		def_WPC_fontTable('sys_fontTable','Font Table');
	}

	if ($dasm_DMDtable) {
		$Address = 0x8288;
		my($addr) = def_ptr('^sys_DMDtable');
		def_WPC_DMDTable('sys_DMDtable','DMD Table');
	}
}

#----------------------------------------------------------------------
# Post Disassembly Magic
#----------------------------------------------------------------------

sub apply_magic_WPC_DMD($$)
{
	my($fa,$la) = @_;

	for (my($addr)=$fa; $addr<=$la-1; $addr++) {
		if ($OP[$addr] eq 'JMP' && $OPA[$addr][0] eq $LBL[$addr+3]) {
			$OP[$addr] = '_skip';
			undef($LBL[$addr+3])								# should also undef Lbl!
				if ($Lbl_refs{$OPA[$addr][0]} == 1);
			splice(@{$OPA[$addr]},0,1);
		} elsif ($OP[$addr] eq '!' && $OPA[$addr][0] =~ m{Sleep$}) {
			$OPA[$addr][1] = hex(substr($OPA[$addr][1],1,4));
		}
	}
}

#----------------------------------------------------------------------
# Init Disassembly System
#----------------------------------------------------------------------

sub init_WPC_DMD()
{
}

#======================================================================
# WPC Disassembly Library
#======================================================================

#----------------------------------------------------------------------
# ROM Paging
#----------------------------------------------------------------------

sub select_WPC_RPG($)
{
	my($RPG) = @_;

	if (!defined($RPG) || !numberp($RPG) || ($RPG != 0xFF && ($RPG<0 && $RPG>0x3D))) {
		if (numberp($RPG)) {
			die(sprintf("select_WPC_RPG(%02X): bad page id\n",$RPG))
		} else {
			die(sprintf("select_WPC_RPG($RPG): bad page id\n"))
		}
	}
		

#	printf(STDERR "RPG %02X($_cur_RPG) -> %02X($RPG)\n",$_cur_RPG,$RPG);
	return $_cur_RPG if ($RPG == 0xFF || $RPG == $_cur_RPG);
	die unless defined($RPG);
	
	@{$OPPG[$_cur_RPG]} 	 	= @OP[0x4000..0x7FFF];									# swap out active page
	@{$INDPG[$_cur_RPG]}	 	= @IND[0x4000..0x7FFF]; 		    
	@{$TYPEPG[$_cur_RPG]}	 	= @TYPE[0x4000..0x7FFF];		    
	@{$OPAPG[$_cur_RPG]}	 	= @OPA[0x4000..0x7FFF]; 		    
	@{$REMPG[$_cur_RPG]}	 	= @REM[0x4000..0x7FFF]; 		    
	@{$EXTRAPG[$_cur_RPG]}	 	= @EXTRA[0x4000..0x7FFF]; 		    
	@{$EXTRA_INDPG[$_cur_RPG]}	= @EXTRA_IND[0x4000..0x7FFF]; 		    
	@{$EXTRA_BEFORE_LABELPG[$_cur_RPG]}	= @EXTRA_BEFORE_LABEL[0x4000..0x7FFF]; 		    
	@{$EXTRA_AFTER_OPPG[$_cur_RPG]}		= @EXTRA_AFTER_OP[0x4000..0x7FFF]; 		    
	@{$LBLPG[$_cur_RPG]}	 	= @LBL[0x4000..0x7FFF]; 		    
	@{$AUTO_LBLPG[$_cur_RPG]} 	= @AUTO_LBL[0x4000..0x7FFF]; 		    
	@{$decodedPG[$_cur_RPG]} 	= @decoded[0x4000..0x7FFF];
	@{$ROMPG[$_cur_RPG]}	 	= @ROM[0x4000..0x7FFF]
		unless(@{$ROMPG[$_cur_RPG]});
    
	@OP[0x4000..0x7FFF]			= @{$OPPG[$RPG]};										# swap in new page
	@IND[0x4000..0x7FFF] 		= @{$INDPG[$RPG]};
	@TYPE[0x4000..0x7FFF]		= @{$TYPEPG[$RPG]};
	@OPA[0x4000..0x7FFF] 		= @{$OPAPG[$RPG]};
	@REM[0x4000..0x7FFF] 		= @{$REMPG[$RPG]};
	@EXTRA[0x4000..0x7FFF] 		= @{$EXTRAPG[$RPG]};
	@EXTRA_IND[0x4000..0x7FFF]	= @{$EXTRA_INDPG[$RPG]};
	@EXTRA_BEFORE_LABEL[0x4000..0x7FFF] = @{$EXTRA_BEFORE_LABELPG[$RPG]};
	@EXTRA_AFTER_OP[0x4000..0x7FFF] 	= @{$EXTRA_AFTER_OPPG[$RPG]};
	@LBL[0x4000..0x7FFF] 		= @{$LBLPG[$RPG]};
	@AUTO_LBL[0x4000..0x7FFF] 	= @{$AUTO_LBLPG[$RPG]};
	@decoded[0x4000..0x7FFF] 	= @{$decodedPG[$RPG]};
	if (@{$ROMPG[$RPG]}) {
		@ROM[0x4000..0x7FFF]	= @{$ROMPG[$RPG]};										# copy from page buffer
	} else {
		load_ROM($ARGV[0],0x4000,$RPG,16);												# load from file
	}
	
	my($oRPG) = $_cur_RPG;
    $_cur_RPG = $RPG;

	unless ($decoded[0x4000]) {															# decode page id
		my($oA) = $Address;
		$Address = 0x4000;
		def_byte_hex('_ROMPG_ID',sprintf('ROM PAGE %02X',$_cur_RPG));
		$Address = $oA;
	}
	
    return $oRPG;
}

#----------------------------------------------------------------------
# Switch Table
#----------------------------------------------------------------------

sub def_WPC_switchTable(@)
{
	my($lbl,$divider_label) = @_;

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
		$lbl .= sprintf('[%02X]',$_cur_RPG)
			unless ($_cur_RPG == 0xFF);
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of switches, bytes per switch' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($sw)=0; $sw<$rows; $sw++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $data_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DBBRB';
		$REM[$opaddr] = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;

		my($ta,$tp) = (WORD($Address),BYTE($Address+2));
		my($swn) = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},label_address($ta,$swn.'_handler',1));		# suppress address suffix in label
		push(@{$OPA[$opaddr]},sprintf('$%02X',$tp));
		WPC_codeRef($swn.'_handler','Switch Handler');
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('Lamp#%02X',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address))); $decoded[$Address++] = 1;
	}
}   
		    
#----------------------------------------------------------------------
# References
#	- loads RPG
#----------------------------------------------------------------------

sub def_WPC_ref($@)														# DOES NOT MAINTAIN RPG
{																			
	my($pointee_lbl,$rem) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die(sprintf("def_WPC_ref(%04X,$lbl): addresses below 0x8000 not supported (implementation restriction)",$Address))
    	unless ($Address >= 0x8000);

	my($pointee_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
	select_WPC_RPG($RPG);

	$pointee_lbl = $` if ($pointee_lbl =~ m{\[[0-9A-F]{2}\]$});            					# remove previous RPG if there is one
	$pointee_lbl .= sprintf('[%02X]',$_cur_RPG)
		unless ($_cur_RPG == 0xFF);
	setLabel("^$pointee_lbl",$Address);
	
	my($usr_lbl) = $LBL[$pointee_addr];
	$pointee_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($pointee_lbl,$pointee_addr);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $codeType_data;
	$OPA[$Address][0] = $pointee_lbl; 
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	return $pointee_addr;
}

#----------------------------------------------------------------------
# Strings
#----------------------------------------------------------------------

sub decode_WPC_STR_char($)
{
	my($c) = BYTE($_[0]);

	return sprintf('%c',$c)																		# printable ASCII
		if ($c >= 32 && $c < 127);
	return sprintf('\\%02X',$c);																# non-printable
}

sub def_WPC_string(@)
{
	my($lbl,$divider_label,$rem) = @_;

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	insert_divider($Address,$divider_label);
	$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	$lbl .= sprintf('[%02X]',$_cur_RPG)
		unless ($_cur_RPG == 0xFF);
	setLabel($lbl,$Address);
    $Address+=$len,return unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    
	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$OP[$Address] = '.STR';
	my($o);
	$OPA[$Address][0] = "'";
	for ($o=0; BYTE($Address+$o)!=0; $o++) {
		$OPA[$Address][0] .= decode_WPC_STR_char($Address+$o);
		$decoded[$Address+$o] = 1;
	}
	$decoded[$Address+$o] = 1;
	$OPA[$Address][0] .= "'";
	$Address += $o;
}   
		    
sub def_WPC_stringRef($@)														# DOES NOT MAINTAIN RPG
{																			
	my($str_lbl,$divider_title,$rem) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die(sprintf("def_WPC_stringRef(%04X,$str_lbl): addresses below 0x8000 not supported (implementation restriction)"))
    	unless ($Address >= 0x8000);

	my($str_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
	select_WPC_RPG($RPG);

	$str_lbl = $` if ($str_lbl =~ m{\[[0-9A-F]{2}\]$});            					# remove previous RPG if there is one
	$str_lbl .= sprintf('[%02X]',$_cur_RPG)
		unless ($_cur_RPG == 0xFF);
	setLabel("^$str_lbl",$Address);
	
	my($usr_lbl) = $LBL[$str_addr];
	$str_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($str_lbl,$str_addr);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $codeType_data;
	#$OPA[$Address][0] = $str_lbl;
	push(@{$OPA[$Address]},label_address(WORD($Address),$str_lbl,1));        # suppress address suffix in label
    push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	my($sAddr) = $Address;
	$Address = $str_addr;
	def_WPC_string($str_lbl,$divider_title);
	$Address = $sAddr + 3;
}

#----------------------------------------------------------------------
# Code
#----------------------------------------------------------------------

sub WPC_codeRef($@)
{
	my($code_lbl,$divider_label) = @_;
	my($code_addr) = WORD($Address);

	my($RPG) = BYTE($Address+2);
#	print(STDERR "select_WPC_RPG($RPG);\n");
	my($orpg) = select_WPC_RPG($RPG);

	$code_lbl = $` if ($code_lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	$code_lbl .= sprintf('[%02X]',$RPG)
		unless ($RPG == 0xFF);
	
	my($usr_lbl) = $LBL[$code_addr];
	$code_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($code_lbl,$code_addr);

	disassemble_asm($code_base_indent,$code_addr,$code_lbl,$divider_label);
#	die if $unclean;

	select_WPC_RPG($orpg);
#	return $Address-3;
}

sub def_WPC_codeRef($@)																	# ROUTINE DOES NOT MAINTAIN RPG
{
	my($code_lbl,$divider_title,$rem) = @_;
	die unless defined($Address);

	setLabel("^$code_lbl",$Address);
    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
#	$OPA[$Address][0] = $code_lbl;
	push(@{$OPA[$Address]},label_address(WORD($Address),$code_lbl,1));        # suppress address suffix in label
    push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
	$REM[$Address] = $rem unless defined($REM[$Address]); 

	WPC_codeRef($code_lbl,'System Call');    
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
}

#----------------------------------------------------------------------
#	Define System Calls
#
# 	$note ARGUMENTS:
#		1: routine does not return
#----------------------------------------------------------------------

sub define_syscall($$$@)
{
	my($lbl,$addr,$args,$note) = @_;

	define_label($lbl,$addr);
	push(@SYSCALL,$lbl);
	$SC_ADDR[$#SYSCALL] = $addr;
	$SC_ARGS[$#SYSCALL] = $args;
	$SC_NOTE[$#SYSCALL] = $note;
}

1; 																# return true

