#======================================================================
#                    C 7 1 1 . M 6 8 0 9 
#                    doc: Wed May 21 21:53:39 2025
#                    dlm: Fri Jun 13 22:33:57 2025
#                    (c) 2025 idealjoker@mailbox.org
#                    uE-Info: 24 43 NIL 0 0 72 10 2 4 NIL ofnI
#======================================================================

# HISTORY:
#   May 26, 2025: - created from [C711.M6800]
#   May 27, 2025: - adapted and added new opcodes
#   May 29, 2025: - debugging
#   Jun  1, 2025: - BUG: pre-decrement was post-decrement
#                 - BUG: LBfalse had short arg
#   Jun  2, 2025: - BUG: forced indexed mode offset did not work for -ve
#                        offsets
#   Jun  4, 2025: - removed opt_V
#   Jun  8, 2025: - added support for long lexical branches
#                 - BUG: wrong opcodes for 16-bit LD instructions
#   Jun 10, 2025: - BUG: extended mode postbyte was wrong for reg D
#                 - BUG: !exitThread did not respect Note (JMP)
#	Jun 12, 2025: - added support for JMP lexical labels
#				  - BUG: LBRA had wrong opcode
#	Jun 13, 2025: - BUG: indirect extended mode did not work
# HISTORY END

use strict vars;

our($OP,@OP_ARG,%JSR_TRG,@ROM,$ADDR,$RPG,%LBL,@IF_CONT_LBL,@LOOP_LBL,@LOOP_DONE_LBL,
	$EXEC6809_BLOCK_ID,$OPTIMIZABLE_LABEL_PREFIX,$EIGHT_BIT_LABEL_PREFIX,
	$SIXTEEN_BIT_LABEL_PREFIX,@newly_defined_label,$WMS_System,$IVM_DISABLED,
	@SC_ARGS,%SYSCALL,$DP);

my($last_RTS_addr,@forward_lexical_RTS_branch);
my($last_exitThread_addr,@forward_lexical_exitThread_branch);

#======================================================================
# Macros
#======================================================================

sub asm_6809_macros()																			# _SLEEP, ...
{
	if ($OP eq '_SLEEP') {
		die;
		die("Syntax: _SLEEP #time at input line $.\n")
			unless (@OP_ARG == 1 && $OP_ARG[0] =~ m{^#});
		die("invalid _SLEEP time ($') at input line $.\n")
			unless numberp($') && $'>=0 && $'<=255; 
		set_label_type(1);
		$JSR_TRG{WVM_sleepI}++; 	    
		$ROM[$ADDR++] = 0xBD;																# JSR WVM_sleepI
		$ROM[$ADDR++] = 'WVM_sleepI';
		$ROM[$ADDR++] = '16-BIT VALUE';
		$ROM[$ADDR++] = $'; 																# .DB xx
		return 1;
	}

	if ($OP eq '_EXIT_THREAD') {
		die;
		die("_EXIT_THREAD does not accept any arguments at input line $.\n")
			unless (@OP_ARG == 0);
		set_label_type(1);
		$ROM[$ADDR++] = 0x7E;																# JMP WVM_exitThread
		$ROM[$ADDR++] = 'WVM_exitThread';
		$ROM[$ADDR++] = '16-BIT VALUE';
		return 1;
	}

	if ($OP eq '_BOOT_JSR') {
		die;
		die("_BOOT_JSR requires 1 argument at input line $.\n")
			unless (@OP_ARG == 1);
		set_label_type(1);
		$ROM[$ADDR+0] = 0x8E;																# LDS
		$ROM[$ADDR+1] = (($ADDR+5)&0xFF00) >> 8;
		$ROM[$ADDR+2] = (($ADDR+5)&0xFF);
		$ROM[$ADDR+3] = 0x7E;																# JMP
		$ROM[$ADDR+4] = $OP_ARG[0]; $ROM[$ADDR+5] = '16-BIT VALUE';
		$ADDR += 6;
		return 1;
	}

	if ($OP eq '_SETFLAG[A]') {
		die;
		die("Syntax: _SETFLAG[A] <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Flag#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_SETFLAG[A]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_SETFLAG[A]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0x96;															# LDAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;
		$ROM[$ADDR++] = 0x8A;															# ORAA <bit mask>
		$ROM[$ADDR++] = $bit_mask;
		$ROM[$ADDR++] = 0x97;															# STAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;

		return 1;
	}

	if ($OP eq '_SETFLAG[B]') {
		die;
		die("Syntax: _SETFLAG[B] <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Flag#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_SETFLAG[B]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_SETFLAG[B]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0xD6;															# LDAB <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;
		$ROM[$ADDR++] = 0xCA;															# ORAB <bit mask>
		$ROM[$ADDR++] = $bit_mask;
		$ROM[$ADDR++] = 0xD7;															# STAB <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;

		return 1;
	}

	if ($OP eq '_LAMPON[A]') {
		die;
		die("Syntax: _LAMPON[A] <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Lamp#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_LAMPON[A]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_LAMPON[A]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0x96;															# LDAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Lamps'} + $byte_offset;
		$ROM[$ADDR++] = 0x8A;															# ORAA <bit mask>
		$ROM[$ADDR++] = $bit_mask;
		$ROM[$ADDR++] = 0x97;															# STAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Lamps'} + $byte_offset;

		return 1;
	}

	if ($OP eq '_CLEARFLAG[A]') {
		die;
		die("Syntax: _CLEARFLAG[A]	<byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Flag#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_CLEARFLAG[A]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_CLEARFLAG[A]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0x96;															# LDAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;
		$ROM[$ADDR++] = 0x84;															# ANDA <bit mask>
		$ROM[$ADDR++] = ~$bit_mask&0xFF;
		$ROM[$ADDR++] = 0x97;															# STAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;

		return 1;
	}

	if ($OP eq '_CLEARFLAG[B]') {
		die;
		die("Syntax: _CLEARFLAG[B] <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Flag#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_CLEARFLAG[B]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_CLEARFLAG[B]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0xD6;															# LDAB <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;
		$ROM[$ADDR++] = 0xC4;															# ANDB !<bit mask>
		$ROM[$ADDR++] = ~$bit_mask&0xFF;
		$ROM[$ADDR++] = 0xD7;															# STAB <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;

		return 1;
	}

	if ($OP eq '_LAMPOFF[A]') {
		die;
		die("Syntax: _LAMPOFF[A]  <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Lamp#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_LAMPOFF[A]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_LAMPOFF[A]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0x96;															# LDAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Lamps'} + $byte_offset;
		$ROM[$ADDR++] = 0x84;															# ANDA <bit mask>
		$ROM[$ADDR++] = ~$bit_mask&0xFF;
		$ROM[$ADDR++] = 0x97;															# STAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Lamps'} + $byte_offset;

		return 1;
	}

	if ($OP eq '_TESTFLAG[A]') {
		die;
		die("Syntax: _TESTFLAG[A] <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Flag#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_TESTFLAG[A]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_TESTFLAG[A]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0x96;															# LDAA <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;
		$ROM[$ADDR++] = 0x85;															# BITB <bit mask>
		$ROM[$ADDR++] = $bit_mask;

		return 1;
	}

	if ($OP eq '_TESTFLAG[B]') {
		die;
		die("Syntax: _TESTFLAG[B] <byte> at input line $.\n")
			unless (@OP_ARG==1);
		set_label_type(1);

		my($argval);																	# determine numeric argument value if possible in order
		if (numberp($OP_ARG[0])) {														# ... to determine whether direct mode can be used
			$argval = $OP_ARG[0];
		} elsif ($OP_ARG[0] =~ m{^Flag#([0-9A-Fa-f]{2})$}) {
			$argval = hex($1);
		} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
			$argval = hex($1);
		} elsif (numberp($LBL{$OP_ARG[0]})) {
			$argval = $LBL{$OP_ARG[0]};
		} else {
			$argval = eval_label($OP_ARG[0],undef,1);									# returns undef if not a numerical result; no errors on undefined labels
		}
		die("_TESTFLAG[B]: cannot determine value of argument <$OP_ARG[0]>\n")
			unless numberp($argval);
		die("_TESTFLAG[B]: value of argument <$OP_ARG[0]> is out of range\n")
			unless ($argval>=0 && $argval<=0x3F);

		my($byte_offset) = int($argval/8);
		my($bit_number) = $argval % 8;
		my($bit_mask) = 1 << $bit_number;
		    
		$ROM[$ADDR++] = 0xD6;															# LDAB <flag byte>
		$ROM[$ADDR++] = $LBL{'=Flags'} + $byte_offset;
		$ROM[$ADDR++] = 0xC5;															# BITB <bit mask>
		$ROM[$ADDR++] = $bit_mask;

		return 1;
    }

	return undef;
}

#======================================================================
# Structured Programming
#======================================================================

sub macro_IF_6809($$)
{
    my($mac,$cop) = @_;
    if ($OP eq $mac) {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
        $OP = $cop; push(@OP_ARG,auto_label(1));
        push(@IF_CONT_LBL,$OP_ARG[$#OP_ARG]);
        return 1;
    }
    return undef;
}

sub macro_until_6809($$)                                        # _UNTIL_EQ ... _ENDLOOP
{
    my($mac,$cop) = @_;
    if ($OP eq $mac) {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
        my($loop_lbl) = auto_label(1);
        define_label($loop_lbl);
        push(@LOOP_LBL,$loop_lbl);
        $OP = $cop; @OP_ARG = (auto_label(1));
        push(@LOOP_DONE_LBL,$OP_ARG[0]);
        return 1;
    }
    return undef;
}

sub macro_while_6809($$)										# _LOOP ... _WHILE_EQ
{
    my($mac,$cop) = @_;
    if ($OP eq $mac) {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
        $OP = $cop; @OP_ARG = (pop(@LOOP_LBL));
        define_label(pop(@LOOP_DONE_LBL),$ADDR+2);
        return 1;
    }
    return undef;
}

sub unroll_asm_structure()
{
#	print(STDERR "unroll_asm_structure: $OP @OP_ARG\n");
	
    #----------------------------------------
    # M6809 If Statements
    #----------------------------------------

	return if macro_IF_6809('_IF_EQ','BNE');
	return if macro_IF_6809('_IF_NE','BEQ');
	return if macro_IF_6809('_IF_GE','BLT');
	return if macro_IF_6809('_IF_LE','BGT');
	return if macro_IF_6809('_IF_GT','BLE');
	return if macro_IF_6809('_IF_LT','BGE');
	return if macro_IF_6809('_IF_LS','BHI');
	return if macro_IF_6809('_IF_HI','BLS');
	return if macro_IF_6809('_IF_CS','BCC');
	return if macro_IF_6809('_IF_false','BCC');
	return if macro_IF_6809('_IF_CC','BCS');
	return if macro_IF_6809('_IF_true','BCS');
	return if macro_IF_6809('_IF_VS','BVC');
	return if macro_IF_6809('_IF_VC','BVS');
	return if macro_IF_6809('_IF_MI','BPL');
	return if macro_IF_6809('_IF_PL','BMI');

	if ($OP eq '_ELSE') {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
		$OP = 'BRA';
		@OP_ARG = (auto_label(1));
		define_label(pop(@IF_CONT_LBL),$ADDR+2);
		push(@IF_CONT_LBL,$OP_ARG[0]);
		return;
	}

	if (($OP eq '_ENDIF') || ($OP eq '_ENDUNLESS')) {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
		undef($OP);
		define_label(pop(@IF_CONT_LBL));
		return;
    }

    #----------------------------------------
    # M6809 Loop Statements
    #----------------------------------------

	if ($OP eq '_LOOP') {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
		undef($OP);
		my($lbl) = auto_label(1);
		define_label($lbl);
		push(@LOOP_LBL,$lbl);
		push(@LOOP_DONE_LBL,auto_label(0)); 							# don't set type yet, because label is only used with _EXITLOOP
		return;
	}

	return if macro_while_6809('_WHILE_NE','BNE');
	return if macro_while_6809('_WHILE_EQ','BEQ');
	return if macro_while_6809('_WHILE_LE','BLE');
	return if macro_while_6809('_WHILE_GE','BGE');
	return if macro_while_6809('_WHILE_LT','BLT');
	return if macro_while_6809('_WHILE_GT','BGT');
	return if macro_while_6809('_WHILE_HI','BHI');
	return if macro_while_6809('_WHILE_LS','BLS');
	return if macro_while_6809('_WHILE_CC','BCC');		    
	return if macro_while_6809('_WHILE_CS','BCS');
	return if macro_while_6809('_WHILE_VC','BVC');
	return if macro_while_6809('_WHILE_VS','BVS');
	return if macro_while_6809('_WHILE_MI','BMI');
	return if macro_while_6809('_WHILE_PL','BPL');

	return if macro_until_6809('_UNTIL_NE','BNE');
	return if macro_until_6809('_UNTIL_EQ','BEQ');
	return if macro_until_6809('_UNTIL_LE','BLE');
	return if macro_until_6809('_UNTIL_GE','BGE');
	return if macro_until_6809('_UNTIL_LT','BLT');
	return if macro_until_6809('_UNTIL_GT','BGT');
	return if macro_until_6809('_UNTIL_HI','BHI');
	return if macro_until_6809('_UNTIL_LS','BLS');
	return if macro_until_6809('_UNTIL_CC','BCC');		    
	return if macro_until_6809('_UNTIL_CS','BCS');
	return if macro_until_6809('_UNTIL_VC','BVC');
	return if macro_until_6809('_UNTIL_VS','BVS');
	return if macro_until_6809('_UNTIL_MI','BMI');
	return if macro_until_6809('_UNTIL_PL','BPL');

	if ($OP eq '_ENDLOOP') {
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
		$OP = 'BRA';
		@OP_ARG = (pop(@LOOP_LBL));
		define_label(pop(@LOOP_DONE_LBL),$ADDR+2);
		return;
	}

	if ($OP eq '_ENDLOOOP') {									# long loop
    	die("Extraneous argument(s) <@OP_ARG> at input line $.\n")
    		if (@OP_ARG);
		$OP = 'JMP';
		@OP_ARG = (pop(@LOOP_LBL));
		define_label(pop(@LOOP_DONE_LBL),$ADDR+2);
		return;
    }
}

#======================================================================
# Motorola 6809 Assembler
#	Addressing Modes:
#		''	inherent (no other modes possible)
#		B	1-byte immediate
#		W	2-byte immediate
#		U	system(!) stack register set (1-byte immediate, U allowed)
#		S	user(!) stack register set (1-byte immediate, S allowed)
#		E	Extended
#		O	Optimizable extended
#		D	Direct
#		X	indeXed
#		s	8-bit Relative 
#		L	16-bit relative (optimizable)
#======================================================================

sub store_opc($)																		# copy OPC (possibly multi-byte) to @ROM
{
	my($opc) = @_;

	if ($opc > 0x255) {																	# page 2 or 3
		$ROM[$ADDR++] = ($opc >> 8);
		$opc &= 0xFF;
    }
	$ROM[$ADDR++] = $opc;
}


sub store_postBytes_IM($$$)																# copy indexed-mode postbyte and offset to @ROM
{
	my($ofs,$IR,$indirect) = @_;
##	printf(STDERR "%4X: store_postBytes_IM($ofs,$IR,$indirect)\n",code_addr());

	my($f8,$f16);
	if ($ofs =~ m{^>}) {																# forced 8-/16-bint offset
		$f16 = 1;
		$ofs = $';
	} elsif ($ofs =~ m{^<}) {
		$f8 = 1;
		$ofs = $';
	}

	die("Invalid indexed mode address offset <$OP_ARG[0]> at input line $.\n")			# no offset, register offset or numeric offset
		unless length($ofs)==0 || isMember($ofs,'A','B','D') || numberp($ofs);

	my($PB);																			# postbyte
	my($OB1,$OB2);																		# offset bytes
	
	if ($IR eq 'PCR') {																	# ofs,PCR
		die("Invalid PC-relative indirect mode <$OP_ARG[0]> at input line $.\n")
			if $indirect;
		die("Invalid PC-relative 8-bit (forced) offset <$OP_ARG[0]> at input line $.\n")
			if $f8;
		if ($ofs>=-128 && $ofs<=127) {
			$PB = 0b10001000;
	        $OB1 = ($ofs & 0xFF);
	    } elsif ($ofs>=-32768 && $ofs<=32767) {
			$PB = 0b10001001;
			$OB1 = ($ofs & 0xFF00) >> 8;
			$OB2 = ($ofs & 0xFF);
		} else {
			die("Invalid PC-relative offset <$OP_ARG[0]> at input line $.\n");
	    }
	} elsif (isMember($ofs,'A','B','D')) {												# register offset
		die("Invalid (forced) register offset <$OP_ARG[0]> at input line $.\n")
			if ($f8 || $f16);
		if ($ofs eq 'A') {																    
			$PB = 0b10000110;
		} elsif ($ofs eq 'B') {
			$PB = 0b10000101;
		} elsif (isMember($ofs,'D','AB')) {
	        $PB = 0b10001011;
	    } else {
   			die("Invalid indexed mode register offset <$OP_ARG[0]> at input line $.\n")
   		}
	} elsif ($IR =~ m{\+{1,2}$} || $IR =~ m{^-{1,2}}) {									# auto inc/dec
		die("Invalid non-zero auto-increment/-decrement offset <$OP_ARG[0]> at input line $.\n")
			if defined($ofs) && $ofs!=0;
		if ($IR =~ m{\+{2}$}) { 														# 2-byte post increment
			$IR = $`;
			$PB = 0b10000001;
		} elsif ($IR =~ m{\+$}) {														# 1-byte post increment
			die("Invalid indirect indexed mode auto-increment <$OP_ARG[0]> at input line $.\n")
				if $indirect;
			$IR = $`;
			$PB = 0b10000000;
		} elsif ($IR =~ m{^--}) {														# 2-byte pre-decrement
			$IR = $';
			$PB = 0b10000011;
		} elsif ($IR =~ m{^-}) {														# 1-byte pre-decrement
			die("Invalid indirect indexed mode auto-decrement <$OP_ARG[0]> at input line $.\n")
				if $indirect;
			$IR = $';
			$PB = 0b10000010;
	    } else {
   			die("Invalid indexed mode auto post-increment/-decrement <$OP_ARG[0]> at input line $.\n")
   		}
	} else {																			# constant offset
		if (!$f8 && !$f16 && (!defined($ofs) || $ofs==0)) {								# zero offset
			$PB = 0b10000100;
		} elsif (!$indirect && !$f8 && !$f16 && $ofs>=-16 && $ofs<=15) {				# short offset in postbyte
			$PB = $ofs & 0x1F;
		} elsif (!$f16 && $ofs>=-128 && $ofs<=127) {									# 1 postbyte offset 
			$PB = 0b10001000;
			$OB1 = $ofs & 0xFF;
		} elsif ($ofs>=-32768 && $ofs<=32767) {											# 2 postbytes offset
			$PB = 0b10001001;
			$OB1 = ($ofs & 0xFF00) >> 8;
			$OB2 = ($ofs & 0xFF);
		} else {
			die("Invalid indexed mode offset <$OP_ARG[0]> at input line $.\n");
	    }
	}

	$PB |= 0b00010000 if $indirect;														# indirect mode

	if ($IR eq 'X') {																	# index register
		$PB |= 0b00000000;
	} elsif ($IR eq 'Y') {
		$PB |= 0b00100000;
	} elsif ($IR eq 'U') {
		$PB |= 0b01000000;
	} elsif ($IR eq 'S') {
		$PB |= 0b01100000;
	} elsif ($IR ne 'PCR') {															# PCR handled above
		die("Invalid indexed mode register <$OP_ARG[0]> at input line $.\n");
	}

##	printf(STDERR "%04X: PB = %08b, OB1 = $OB1 (%d), OB2 = $OB2 (%d) [$f8/$f16]\n",code_addr(),$PB,defined($OB1),defined($OB2));
	$ROM[$ADDR++] = $PB;
	$ROM[$ADDR++] = $OB1 if defined($OB1);
	$ROM[$ADDR++] = $OB2 if defined($OB2);
}


sub TFR_reg($)																			# transfer register nibble
{
	my($reg) = @_;

	return 0x0 if ($reg eq 'D');
	return 0x1 if ($reg eq 'X');
	return 0x2 if ($reg eq 'Y');
	return 0x3 if ($reg eq 'U');
	return 0x4 if ($reg eq 'S');
	return 0x5 if ($reg eq 'PC');

	return 0x8 if ($reg eq 'A');
	return 0x9 if ($reg eq 'B');
	return 0xA if ($reg eq 'CC');
	return 0xB if ($reg eq 'DP');

	die("Invalid transfer register <$reg> at input line $.\n");
}

		
sub asm_6809_op($$@)
{
	my($trg,$aModes,@opc) = @_;	# also local($OP,@OP_ARG)
	return undef unless (CORE::fc($OP) eq CORE::fc($trg));								# don't do anything unless operation is a match

##	printf(STDERR "%04X: asm_6809_op($trg,$aModes,@opc)\n",code_addr());

	if ($aModes eq '') {																# inherent addressing (no other modes possible)
		die("Usage error: $OP (implied/acc mode) does not allow an argument (<@_> at input line $.)\n")
			unless (@OP_ARG == 0);
		store_opc($opc[0]);
		return 1;
	}

	die("Usage error: $OP (addressing modes $aModes) at input line $. requires an argument\n")
		if (@OP_ARG == 0);
	    
	for (my($i)=0; $i<@opc; $i++) { 													# remaining addressing modes
		my($am) = substr($aModes,$i,1);
##		printf(STDERR "$.: am = $am\n");

		if ($am eq 'B') {																# Immediate Mode Byte
			next unless ($OP_ARG[0] =~ m{^#});
            die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                if (@OP_ARG > 1);
            store_opc($opc[$i]);
            $ROM[$ADDR++] = $';
            return 1;
        }
        if ($am eq 'W') { 																# Word
            next unless ($OP_ARG[0] =~ m{^#});
            die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                if (@OP_ARG > 1);
            store_opc($opc[$i]);
            $ROM[$ADDR++] = $';
            $ROM[$ADDR++] = '16-BIT VALUE';
            return 1;
        }

		if ($am eq 'X') {																# Indexed Mode
			if ($OP_ARG[0] =~ m{([<>]?-?[ABD\d]*)?\s*,\s*([XYUSP\+\-]+)$}) {			# direct
				die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
					if (@OP_ARG > 1);
				store_opc($opc[$i]);
				store_postBytes_IM($1,$2,0);
				return 1;
			} elsif ($OP_ARG[0] =~ m{^\[\s*([<>]?-?[ABD\d]*)\s*,\s*([XYUSP\+\-])\s*\]$}) {	# indirect indexed
				die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
					if (@OP_ARG > 1);
				store_opc($opc[$i]);
				store_postBytes_IM($1,$2,1);
				return 1;
			} elsif ($OP_ARG[0] =~ m{^\[(.*)\]$}) {										# indirect extended
				die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
					if (@OP_ARG > 1);
				store_opc($opc[$i]);
				$ROM[$ADDR++] = 0b10011111; 											# postbyte
				$ROM[$ADDR++] = $1;
				$ROM[$ADDR++] = '16-BIT VALUE';
				return 1;
			} else {
				next;
			}
		}

        if (isMember($am,'U','S')) {                                                    # stack register set (1-byte immediate)
            if (length($OP_ARG[0])==0 || $OP_ARG[0] =~ m{^#[\$%]?0+}) {                 # empty or 0 argument => push zero registers
                print(STDERR "WARNING: empty register set <$OP_ARG[0]> at input line $.\n");
                die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                    if (@OP_ARG > 1);
                store_opc($opc[$i]);
                $ROM[$ADDR++] = 0x00;
                return 1;
            }
            next unless $OP_ARG[0] =~ m{^[ABCDPSUXY,]+$};

            my($PB);                                                                    # postbyte
            my($what);
            foreach my $reg (split(',',$OP_ARG[0])) {
                if ($reg eq 'CC') {
                    $PB |= 0b00000001;
                } elsif ($reg eq 'A') {
                    $PB |= 0b00000010;
                } elsif ($reg eq 'B') {
                    $PB |= 0b00000100;
                } elsif ($reg eq 'DP') {
                    $PB |= 0b00001000;
                } elsif ($reg eq 'X') {
                    $PB |= 0b00010000;
                } elsif ($reg eq 'Y') {
                    $PB |= 0b00100000;
                } elsif ($reg eq $am) {
                    $what = ' stack';
                    $PB |= 0b01000000;
                } elsif ($reg eq 'PC') {
                    $PB |= 0b10000000;
                } else {
                    die("Invalid$what register <$reg> in list <$OP_ARG[0]> at input line $.\n");
                }
            }
            store_opc($opc[$i]);
            $ROM[$ADDR++] = $PB;
            return 1;
        }

        if ($am eq 'R') {                                                               # transfer Register pair
            next unless ($OP_ARG[0] =~ m{^([ABCDPSUXY]+),([ABCDPSUXY]+)$});
            die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                if (@OP_ARG > 1);
            store_opc($opc[$i]);
            $ROM[$ADDR++] = (TFR_reg($1)<<4) | TFR_reg($2);
            return 1;
        }

		if ($am eq 'D') { 																# Direct Mode (LSB of address, pg register is MSB)
			next if ($OP_ARG[0] =~ m{^>});												# > forces extended mode
			my($forced);
			if ($OP_ARG[0] =~ m{^<}) {													# < prefix forces direct mode
				$forced = 1;
				$OP_ARG[0] = $';
			} else {
				next unless defined($DP);												# unforced direct mode requires DP set
			}

			my($argval);																# determine numeric argument value if possible in order
			if (numberp($OP_ARG[0])) {													# ... to determine whether direct mode is valid
				$argval = $OP_ARG[0];
			} elsif ($OP_ARG[0] =~ m{^\$([0-9A-Fa-f]+)$}) {
				$argval = hex($1);
			} elsif (numberp($LBL{$OP_ARG[0]})) {
				$argval = $LBL{$OP_ARG[0]};
			} else {
				$argval = eval_label($OP_ARG[0],undef,1);								# returns undef if not a numerical result; no errors on undefined labels
			}
			if (defined($argval) && $argval > 0xFF) {									# don't use direct addressing mode for large numbers
				die("Invalid argument <$OP_ARG[0]> for forced direct mode at input line $.\n")
					if $forced;
				next;
			}

			die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
				if (@OP_ARG > 1) && $OP ne 'JSR';
			store_opc($opc[$i]);
			$ROM[$ADDR++] = $OP_ARG[0];
			return 1;
		}

        if ($am eq 'E') {                                                               # Extended mode (2-byte absolute address)
			if ($OP_ARG[0] =~ m{^>}) {													# < prefix forces extended mode
				$OP_ARG[0] = $';
			} 
            die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                if (@OP_ARG > 1);
            store_opc($opc[$i]);                                                        # default choice (none of the above has matched, cannot be
            $ROM[$ADDR++] = $OP_ARG[0];                                                 # combined with O, s or L)
            $ROM[$ADDR++] = '16-BIT VALUE';
            return 1;
        }

        if ($am eq 'O') {                                                               # optimizable 2-byte absolute address (2nd default, cannot be
##          die("Invalid lexical label <$OP_ARG[0]> for $OP instruction at input line $.\n")        # combined with s or L); used for syscalls, so no ARG# checking
##              if ($OP_ARG[0] =~ m{^[<>]});
            if ($OP eq 'JSR') {
                $JSR_TRG{$OP_ARG[0]}++;
            } else {
                die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                    if (@OP_ARG > 1);
            }
			if ($OP eq 'JMP') {
				if ($OP_ARG[0] eq '<RTS') { 												# lexical labels
					$OP_ARG[0] = code_addr($last_RTS_addr);
				} elsif ($OP_ARG[0] eq '>RTS') {
					push(@forward_lexical_RTS_branch,$ADDR+1);
					$OP_ARG[0] = 'no RTS found after branch to >RTS';
				} elsif ($OP_ARG[0] eq '>!exitThread') {
					push(@forward_lexical_exitThread_branch,$ADDR+1);
					$OP_ARG[0] = 'no !exitThread found after JMP to >!exitThread';
	            }
	        }
            store_opc($opc[$i]);
            $ROM[$ADDR++] = "1${OPTIMIZABLE_LABEL_PREFIX}${EIGHT_BIT_LABEL_PREFIX}$OP_ARG[0]";  # NB: 1 is byte offset
            unless ($OP_ARG[$#OP_ARG] =~ m{^[#\$%0-9]}) {                               # set type of jump target
                push(@newly_defined_label,($OP_ARG[$#OP_ARG]));
                set_label_type(1);
            }                   
            $ROM[$ADDR++] = '16-BIT VALUE';
            return 1;
        }

        if ($am eq 's') {                                                               # relative mode (1-byte relative address)
            die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                if (@OP_ARG > 1);
            store_opc($opc[$i]);

            $OP_ARG[$OP_ARG[0]] = $LOOP_DONE_LBL[$#LOOP_DONE_LBL]                       # _EXITLOOP pseudo label
                if ($OP_ARG[0] eq '_EXITLOOP' ||
                    $OP_ARG[0] eq '>EXITLOOP');
            $OP_ARG[0] = $LOOP_LBL[$#LOOP_LBL]                                          # _NEXTLOOP pseudo label
                    if ($OP_ARG[0] eq '_NEXTLOOP' ||
                        $OP_ARG[0] eq '<NEXTLOOP');

            if ($OP_ARG[0] eq '<RTS') {                                                 # lexical labels
                $OP_ARG[0] = code_addr($last_RTS_addr);
            } elsif ($OP_ARG[0] eq '>RTS') {
                push(@forward_lexical_RTS_branch,$ADDR);
                $OP_ARG[0] = 'no RTS found after branch to >RTS';
            } elsif ($OP_ARG[0] eq '>!exitThread') {
                push(@forward_lexical_exitThread_branch,$ADDR);
                $OP_ARG[0] = 'no !exitThread found after branch to >!exitThread';
            } else {
                unless ($OP_ARG[0] =~ m{^[#\$%0-9]}) {                                  # set type of branch target
                    push(@newly_defined_label,($OP_ARG[0]));
                    set_label_type(1);
                }
            }

            $ROM[$ADDR++] = $EIGHT_BIT_LABEL_PREFIX . $OP_ARG[0];
            return 1;
        }
        if ($am eq 'L') {                                                               # long relative mode (2-byte relative address)
            die("Extraneous argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
                if (@OP_ARG > 1);
            store_opc($opc[$i]);

            $OP_ARG[$OP_ARG[0]] = $LOOP_DONE_LBL[$#LOOP_DONE_LBL]                       # _EXITLOOP pseudo label
                if ($OP_ARG[0] eq '_EXITLOOP' ||
                    $OP_ARG[0] eq '>EXITLOOP');
            $OP_ARG[0] = $LOOP_LBL[$#LOOP_LBL]                                          # _NEXTLOOP pseudo label
                    if ($OP_ARG[0] eq '_NEXTLOOP' ||
                        $OP_ARG[0] eq '<NEXTLOOP');

            if ($OP_ARG[0] eq '<RTS') {                                                 # lexical labels
                $OP_ARG[0] = code_addr($last_RTS_addr);
            } elsif ($OP_ARG[0] eq '>RTS') {
                push(@forward_lexical_RTS_branch,-$ADDR);								# -ve addr marks long branches
                $OP_ARG[0] = 'no RTS found after branch to >RTS';
            } elsif ($OP_ARG[0] eq '>!exitThread') {
                push(@forward_lexical_exitThread_branch,-$ADDR);
                $OP_ARG[0] = 'no !exitThread found after branch to >!exitThread';
            } else {
                unless ($OP_ARG[0] =~ m{^[#\$%0-9]}) {                                  # set type of branch target
                    push(@newly_defined_label,($OP_ARG[0]));
                    set_label_type(1);
                }
            }
                                
            $ROM[$ADDR++] = $SIXTEEN_BIT_LABEL_PREFIX . $OP_ARG[0];                     # not yet optimizable
            $ROM[$ADDR++] = '16-BIT VALUE';
            return 1;
        }
        
#       die("Unknown addressing mode <$am> while assembling <$OP @OP_ARG> at input line $.\n");
        die("Invalid argument(s) in statement <$OP @OP_ARG> at input line $.\n");
    }

    die("Syntax error in statement <$OP @OP_ARG> at input line $.\n");
}


sub compile_asm()
{
##  print(STDERR "compile_asm(RPG=$RPG ADDR=$ADDR): $OP @OP_ARG\n");

    return 1 if asm_6809_op('NOP'   ,'',0x12);                                          # inherent addressing (no ohter modes)
    return 1 if asm_6809_op('SYNC'  ,'',0x13);
    return 1 if asm_6809_op('DAA'   ,'',0x19);
    return 1 if asm_6809_op('SEX'   ,'',0x1D);
    return 1 if asm_6809_op('ABX'   ,'',0x3A);
    return 1 if asm_6809_op('RTI'   ,'',0x3B);
    return 1 if asm_6809_op('CWAI'  ,'',0x3C);
    return 1 if asm_6809_op('MUL'   ,'',0x3D);
    return 1 if asm_6809_op('SWI'   ,'',0x3F);
    return 1 if asm_6809_op('SWI'   ,'',0x103F);
    return 1 if asm_6809_op('SWI'   ,'',0x113F);
    return 1 if asm_6809_op('NEGA'  ,'',0x40) || asm_6809_op('NEGB','',0x50);
    return 1 if asm_6809_op('COMA'  ,'',0x43) || asm_6809_op('COMB','',0x53);
    return 1 if asm_6809_op('LSRA'  ,'',0x44) || asm_6809_op('LSRB','',0x54);
    return 1 if asm_6809_op('RORA'  ,'',0x46) || asm_6809_op('RORB','',0x56);
    return 1 if asm_6809_op('ASRA'  ,'',0x47) || asm_6809_op('ASRB','',0x57);
    return 1 if asm_6809_op('ASLA'  ,'',0x48) || asm_6809_op('ASLB','',0x58);
    return 1 if asm_6809_op('ROLA'  ,'',0x49) || asm_6809_op('ROLB','',0x59);
    return 1 if asm_6809_op('DECA'  ,'',0x4A) || asm_6809_op('DECB','',0x5A);
    return 1 if asm_6809_op('INCA'  ,'',0x4C) || asm_6809_op('INCB','',0x5C);
    return 1 if asm_6809_op('TSTA'  ,'',0x4D) || asm_6809_op('TSTB','',0x5D);
    return 1 if asm_6809_op('CLRA'  ,'',0x4F) || asm_6809_op('CLRB','',0x5F);

    if (asm_6809_op('RTS','',0x39)) {                                                   # lexical label support
        $last_RTS_addr = $ADDR - 1;
        while (@forward_lexical_RTS_branch) {
        	my($a) = pop(@forward_lexical_RTS_branch);
        	if ($a < 0) {																# long branch
	            $ROM[-$a] = $SIXTEEN_BIT_LABEL_PREFIX . code_addr($ADDR - 1);
        	} elsif ($ROM[$a-1] == 0x7E) {												# JMP
        		$ROM[$a]  = code_addr($ADDR - 1);
        	} else {																	# short branch 
	            $ROM[$a]  = $EIGHT_BIT_LABEL_PREFIX . code_addr($ADDR - 1);
	        }
        }
        return 1;
    }

    return 1 if asm_6809_op('ORCC' ,'B',0x1A);
    return 1 if asm_6809_op('ANDCC','B',0x1C);

    return 1 if asm_6809_op('LEAX','X',0x30);
    return 1 if asm_6809_op('LEAY','X',0x31);
    return 1 if asm_6809_op('LEAS','X',0x32);
    return 1 if asm_6809_op('LEAU','X',0x33);

    return 1 if asm_6809_op('SUBA','BXDE',0x80,0xA0,0x90,0xB0);
    return 1 if asm_6809_op('SUBB','BXDE',0xC0,0xE0,0xD0,0xF0);
    return 1 if asm_6809_op('CMPA','BXDE',0x81,0xA1,0x91,0xB1);
    return 1 if asm_6809_op('CMPB','BXDE',0xC1,0xE1,0xD1,0xF1);
    return 1 if asm_6809_op('SBCA','BXDE',0x82,0xA2,0x92,0xB2);
    return 1 if asm_6809_op('SBCB','BXDE',0xC2,0xE2,0xD2,0xF2);
    return 1 if asm_6809_op('ANDA','BXDE',0x84,0xA4,0x94,0xB4);
    return 1 if asm_6809_op('ANDB','BXDE',0xC4,0xE4,0xD4,0xF4);
    return 1 if asm_6809_op('BITA','BXDE',0x85,0xA5,0x95,0xB5);
    return 1 if asm_6809_op('BITB','BXDE',0xC5,0xE5,0xD5,0xF5);
    return 1 if asm_6809_op('LDA' ,'BXDE',0x86,0xA6,0x96,0xB6);
    return 1 if asm_6809_op('LDB' ,'BXDE',0xC6,0xE6,0xD6,0xF6);
    return 1 if asm_6809_op('EORA','BXDE',0x88,0xA8,0x98,0xB8);
    return 1 if asm_6809_op('EORB','BXDE',0xC8,0xE8,0xD8,0xF8);
    return 1 if asm_6809_op('ADCA','BXDE',0x89,0xA9,0x99,0xB9);
    return 1 if asm_6809_op('ADCB','BXDE',0xC9,0xE9,0xD9,0xF9);
    return 1 if asm_6809_op('ORA' ,'BXDE',0x8A,0xAA,0x9A,0xBA);
    return 1 if asm_6809_op('ORB' ,'BXDE',0xCA,0xEA,0xDA,0xFA);
    return 1 if asm_6809_op('ADDA','BXDE',0x8B,0xAB,0x9B,0xBB);
    return 1 if asm_6809_op('ADDB','BXDE',0xCB,0xEB,0xDB,0xFB);

    return 1 if asm_6809_op('STA' ,'DXE',0x97,0xA7,0xB7);
    return 1 if asm_6809_op('STB' ,'DXE',0xD7,0xE7,0xF7);
    return 1 if asm_6809_op('STD' ,'DXE',0xDD,0xED,0xFD);
    return 1 if asm_6809_op('STU' ,'DXE',0xDF,0xEF,0xFF);
    return 1 if asm_6809_op('STX' ,'DXE',0x9F,0xAF,0xBF);
    return 1 if asm_6809_op('STS' ,'DXE',0x10DF,0x10EF,0x10FF);
    return 1 if asm_6809_op('STY' ,'DXE',0x109F,0x10AF,0x10BF);
    
    return 1 if asm_6809_op('NEG','DXE',0x00,0x60,0x70);
    return 1 if asm_6809_op('COM','DXE',0x03,0x63,0x73);
    return 1 if asm_6809_op('LSR','DXE',0x04,0x64,0x74);
    return 1 if asm_6809_op('ROR','DXE',0x06,0x66,0x76);
    return 1 if asm_6809_op('ASR','DXE',0x07,0x67,0x77);
    return 1 if asm_6809_op('ASL','DXE',0x08,0x68,0x78);
    return 1 if asm_6809_op('ROL','DXE',0x09,0x69,0x79);
    return 1 if asm_6809_op('DEC','DXE',0x0A,0x6A,0x7A);
    return 1 if asm_6809_op('INC','DXE',0x0C,0x6C,0x7C);
    return 1 if asm_6809_op('TST','DXE',0x0D,0x6D,0x7D);
    return 1 if asm_6809_op('CLR','DXE',0x0F,0x6F,0x7F);

	return 1 if asm_6809_op('CMPX','WXDE',0x8C,0xAC,0x9C,0xBC);
    return 1 if asm_6809_op('CMPD','WXDE',0x1083,0x10A3,0x1093,0x10B3);
	return 1 if asm_6809_op('CMPU','WXDE',0x1183,0x11A3,0x1193,0x11B3);
	return 1 if asm_6809_op('CMPS','WXDE',0x118C,0x11AC,0x119C,0x11BC);
	return 1 if asm_6809_op('CMPY','WXDE',0x108C,0x10AC,0x109C,0x10BC);
	
	return 1 if asm_6809_op('SUBD','WXDE',0x83,0xA3,0x93,0xB3);
	return 1 if asm_6809_op('ADDD','WXDE',0xC3,0xE3,0xD3,0xF3);

	return 1 if asm_6809_op('LDD' ,'DWXE',0xDC,0xCC,0xEC,0xFC);
	return 1 if asm_6809_op('LDAB','DWXE',0xDC,0xCC,0xEC,0xFC);				# OWN OPC
	return 1 if asm_6809_op('LDX' ,'DWXE',0x9E,0x8E,0xAE,0xBE);
	return 1 if asm_6809_op('LDU' ,'DWXE',0xDE,0xCE,0xEE,0xFE);
	return 1 if asm_6809_op('LDS' ,'DWXE',0x10DE,0x10CE,0x10EE,0x10FE);
	return 1 if asm_6809_op('LDY' ,'DWXE',0x109E,0x108E,0x10AE,0x10BE);

	return 1 if asm_6809_op('PSHS','U',0x34);								# U allowed
	return 1 if asm_6809_op('PULS','U',0x35);								# U allowed
	return 1 if asm_6809_op('PSHU','S',0x36);								# S allowed
	return 1 if asm_6809_op('PULU','S',0x37);								# S allowed

	return 1 if asm_6809_op('EXG' ,'R',0x1E);							
	return 1 if asm_6809_op('TFR' ,'R',0x1F);							

	return 1 if asm_6809_op('BRA','s',0x20);
	return 1 if asm_6809_op('BHI','s',0x22) || asm_6809_op('BLS','s',0x23);
	return 1 if asm_6809_op('BCC','s',0x24) || asm_6809_op('BCS','s',0x25);
	return 1 if asm_6809_op('BNE','s',0x26) || asm_6809_op('BEQ','s',0x27);
	return 1 if asm_6809_op('BVC','s',0x28) || asm_6809_op('BVS','s',0x29);
	return 1 if asm_6809_op('BPL','s',0x2A) || asm_6809_op('BMI','s',0x2B);
	return 1 if asm_6809_op('BGE','s',0x2C) || asm_6809_op('BLT','s',0x2D);
	return 1 if asm_6809_op('BGT','s',0x2E) || asm_6809_op('BLE','s',0x2F);
	return 1 if asm_6809_op('Btrue','s',0x24) || asm_6809_op('Bfalse','s',0x25);

	return 1 if asm_6809_op('LBRA','L',0x16);
	return 1 if asm_6809_op('LBHI','L',0x1022) || asm_6809_op('LBLS','L',0x1023);
	return 1 if asm_6809_op('LBCC','L',0x1024) || asm_6809_op('LBCS','L',0x1025);
	return 1 if asm_6809_op('LBNE','L',0x1026) || asm_6809_op('LBEQ','L',0x1027);
	return 1 if asm_6809_op('LBVC','L',0x1028) || asm_6809_op('LBVS','L',0x1029);
	return 1 if asm_6809_op('LBPL','L',0x102A) || asm_6809_op('LBMI','L',0x102B);
	return 1 if asm_6809_op('LBGE','L',0x102C) || asm_6809_op('LBLT','L',0x102D);
	return 1 if asm_6809_op('LBGT','L',0x102E) || asm_6809_op('LBLE','L',0x102F);
	return 1 if asm_6809_op('LBtrue','L',0x1024) || asm_6809_op('LBfalse','L',0x1025);

	return 1 if asm_6809_op('BSR','s',0x8D);
	return 1 if asm_6809_op('LBSR','L',0x17);
	return 1 if asm_6809_op('JMP','DXO',0x0E,0x6E,0x7E);
	
	if (asm_6809_op('JSR','DXO',0x9D,0xAD,0xBD)) {							# System Call Handling

		return 1 unless defined($SYSCALL{$OP_ARG[0]});

		if ($OP_ARG[0] eq 'exitThread') {									# handle !exitThread
##			printf(STDERR "%X: $OP @OP_ARG\n",code_addr($ADDR-3));
			die unless $ROM[$ADDR-3] == 0xBD;								# replace JSR (from expand_bangs) with JMP
			$ROM[$ADDR-3] = 0x7E;

			$last_exitThread_addr = $ADDR-3;
	        while (@forward_lexical_exitThread_branch) {
	        	my($a) = pop(@forward_lexical_exitThread_branch);
##	        	printf(STDERR "fixing %04X\n",code_addr($a));
	        	if ($a < 0) {
	        		$ROM[-$a] = $SIXTEEN_BIT_LABEL_PREFIX . code_addr($ADDR-3);
	        	} elsif ($ROM[$a-1] == 0x7E) {								# JMP
	   	    		$ROM[$a]  = code_addr($ADDR-3);
	        	} else {													# branch
	        		$ROM[$a] = $EIGHT_BIT_LABEL_PREFIX . code_addr($ADDR-3);
	        	}
        	}
		}

		my($SCA) = $SC_ARGS[$SYSCALL{$OP_ARG[0]}];
##		print(STDERR "potential syscall at input line $. [$OP @OP_ARG <$SCA>]\n");
		die("Extraneous syscall $OP_ARG[0] $SCA argument(s) <@OP_ARG[1..$#OP_ARG]> at input line $.\n")
			unless length($SCA) == @OP_ARG-1;

		return 1 unless length($SCA)>0;

		for (my($i)=0; $i<length($SCA); $i++) {								# must be consistent with [D711.M6809] disassemble_syscall()
			if (substr($SCA,$i,1) eq 'W') {									# W: word (not addr!)
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
	            $ROM[$ADDR++] = '16-BIT VALUE';
			} elsif (substr($SCA,$i,1) eq 'P') {							# P: pointer (address)
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
	            $ROM[$ADDR++] = '16-BIT VALUE';
			} elsif (substr($SCA,$i,1) eq 'B') {							# B: byte
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'S') {							# S: switch
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'O') {							# O: sOlenoid
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'L') {							# L: Lamp
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'E') {							# E: Error
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'G') {							# G: Bitgroup
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'F') {							# F: Flag
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'T') {							# T: Thread
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
	            $ROM[$ADDR++] = '16-BIT VALUE';
			} elsif (substr($SCA,$i,1) eq 'A') {							# A: Adjustment
				$ROM[$ADDR++] = $OP_ARG[$i+1];
			} elsif (substr($SCA,$i,1) eq 'U') {							# U: aUdit
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
	            $ROM[$ADDR++] = '16-BIT VALUE';
			} elsif (substr($SCA,$i,1) eq 'D') {							# D: DMD animation
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
			} elsif (substr($SCA,$i,1) eq 'C') {							# C: code ptr (W)
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
	            $ROM[$ADDR++] = '16-BIT VALUE';
			} elsif (substr($SCA,$i,1) eq 'R') {							# R: code reference (WB)
				my($pg) = ($OP_ARG[$i+1] =~ m{^([0-9A-Fa-f]{2}):});
				$pg = defined($pg) ? hex($pg) : $RPG;
				die("Invalid syscall reference <$OP_ARG[$i+1]> at input line $. [$pg]\n")
					unless ($pg>=0 && $pg<=0x3D) || $pg==0xFF;
				$ROM[$ADDR++] = $OP_ARG[$i+1];              
	            $ROM[$ADDR++] = 'WPC REFERENCE';
	            $ROM[$ADDR++] = $pg;										# this may be overwritten with FF during resolve_labels()
			} else {
				die("invalid syscall argument spec <$SCA>");
	        }
			
		}

		return 1;
	}

	return undef;
}

1;
