#!/usr/bin/perl
#======================================================================
#                    C 7 1 1 
#					 doc: Sat Jan  4 13:07:44 2020
#                    dlm: Thu May 29 16:52:57 2025
#                    (c) 2020 idealjoker@mailbox.org
#                    uE-Info: 367 10 NIL 0 0 72 10 2 4 NIL ofnI
#======================================================================

# Williams Systme 7-11 Compiler

# HISTORY:
#   Jan  4, 2020: - created
#                 - implemented main program structure and all M6800 opcodes
#   Jan  5, 2020: - implemented most pragmas
#                 - implemented good part of wvm assembler
#   Jan  6, 2020: - finished basic wvm assembler (no expr parser yet)
#                 - made everything case sensitive
#                 - implemented 6800 structure macros
#   Jan  7, 2020: - fixed bugs and added missing routines
#                 - implemented parser for wvm conditional expressions
#   Jan  8, 2020: - BUG: expression parser did not allow for testing lamps
#   Jan  9, 2020: - finished parser
#   Jan 10, 2020: - adapted to new .PRAGMAs (.LBL .DEF .STR .S7R)
#                 - continued development
#                 - added -t)rust and verify option
#   Jan 11, 2020: - lots of bugs fixed
#   Jan 12, 2020: - added support for @CHECKSUM_BYTE (compiler variable)
#                 - made it work! [A711(D711(PinBot_L5)) == PinBot_L5
#   Jan 13, 2020: - added @FREE_SPACE
#                 - changed produce_output to write ic26,77.out
#   Jan 14, 2020: - changed produce_output to write <basename>.128 <basename>.256
#                 - implemented label arithmetic "label>>8" and "label&#$val"
#   Jan 15, 2020: - improved checksum handling
#   Jan 23, 2020: - changed output to <basename>.U26 and <basename>.U27
#                 - added support for @ASSEMBLY_TIMESTAMP
#   Jan 31, 2020: - BUG: verify-checksum only verified every 4th...
#   Feb  1, 2020: - added -c)ode listing
#                 - regularized compiler variable diagnostic output
#   Feb  2, 2020: - replaced .DEF by .DEFINE and swapped arguments
#   Feb  9, 2020: - replaced -c by -l; added -c, -r, -D
#                 - cosmetics
#   Feb 12, 2020: - BUG: nested .IF statements did not work correctly
#                 - added -t
#   Feb 22, 2020: - BUG: #LG_all did not work
#   Feb 23, 2020: - improved error message
#                 - BUG: .DEFINE var+1 $FF was not handled correctly
#   Feb 25, 2020: - improved error messages
#   Mar  3, 2020: - BUG: store command did not work correctly
#   Mar  5, 2020: - BUG: e.g. Lamp#36|$40 was not allowed
#   Mar  6, 2020: - BUG: multi-level ALIASes were not allowed
#   Mar 16, 2020: - added size check to begin6800/6800
#   Mar 17, 2020: - added line continuation
#   Apr 27, 2020: - added NOTES
#   Apr 28, 2020: - fixed erroneous _IF macros (IFGT -> IF_GE, IFLT -> IF_LE, IFGE -> IF_GT, IFLE -> IF_LT
#                 - renamed remaining _IF macros
#   May 29, 2020: - changed output to <basename>_U26.bin and <basename>_U27.bin
#   Jun  1, 2020: - changed WVM_sleep to WVM_sleepI
#   Jun 19, 2020: - BUG: Adjustments in condidtional expressions did not accept hex digits A-F
#   Jul 22, 2020: - added -w to find un-optimized statements
#   Jul 23, 2020: - added -f and -o
#                 - renamed from A711
#   Aug  3, 2020: - disabled -f with WMS jumps for testing
#                 - BUG: DOES NOTHING!
#                 - disabled JSR optimization for testing (leaving JMP)
#   Aug  4, 2020: - improved optimization
#                 - disabled M6800 optimization (not safe?)
#   Aug 19, 2020: - re-enabled BSR optimization (not BRA) because I need the space
#                 - enabled only first n BSR optimizations (just what's needed)  !!!
#                 - enabled optimization of BRA
#   Aug 20, 2020: - added source statements to -f output and -o input
#   Aug 22, 2020: - added mode selection based on extension
#                 - added documentation for "Partial Optimization"
#                 - suppressed output on -f
#   Sep  5, 2020: - ROM error => ROM mismatch
#   Sep 12, 2020: - made M6800 ops case-insensitive
#                 - started adding System 7 API definitions
#                 - changed DEFINE to allow multi-word commands (for JLaab)
#                 - made PTS in score argument optional and case-insensitive
#   Sep 13, 2020: - continued System 7 API
#                 - BUG: rotLeft and rotRight had been switched
#   Sep 14, 2020: - implemented {SolCmd} syntax
#   Sep 15, 2020: - turned fatal warning regarding exceeding 8-bit branch offset
#                   back into an error (turns out TASMx does not check for this)
#                 - BUG: Incorrect error message about attempting to overwrite
#                        ROM byte
#                 - made wvm_arg_checking for Threads more restrictive
#                 - changed @FREE_SPACE to take argument
#   Sep 16, 2020: - finalized adaptation to System 7 (JL_aab)
#   Sep 17, 2020: - implemented system-7 checksum
#   Sep 18, 2020: - added ROM overflow checks
#                 - BUG: @CHECKSUM at MAX_ROM_ADDR did not work
#                 - removed @FREE_SPACE (was buggy)
#                 - re-enabled optimization sanity check
#   Sep 19, 2020: - BUG: .DEFINE N Reg-I; sleep [N] did not work
#                 - added setThreadId (does same as setThreadFlags)
#   Sep 20, 2020: - end_of_ball -> SYS_end_of_ball
#   Sep 26, 2020: - added '?' to list of alias-id characters (consistent with
#                   labels)
#   Oct  4, 2020: - renamed buf2 macros
#   Oct 11, 2020: - invert -> toggle (for consistency)
#                 - added new macro names for alt buffers
#   Oct 13, 2020: - renamed old macro to use Altbuf instead of AltBuf
#   Oct 16, 2020: - lampOff: -> lampAltbuf:
#   Oct 21, 2020: - changed -w/-w behavior so that -w prevents overflow
#                   errors
#                 - added label arithmetic to zero-page labels
#                 - renamed ASSEMBLY_TIMESTAMP to COMPILATION_TIMESTAMP
#   Oct 24, 2020: - made Altbuf lamp (not group) opcodes single-argument
#                   for system 7
#                 - added -v to list source while compiling to find
#                   infinite loops
#                 - added %lampLitOrBlinking: for system 7
#                 - suppressed optimization in begin6800/end6800 blocks
#   Oct 25, 2020: - cleaned up system 7 API
#                 - removed partial optimization code
#   Oct 27, 2020: - adapted to new register names
#   Nov  6, 2020: - BUG: .S7R string parser did not throw error on
#                        on un-translatable characters!
#                 - added -s)uffix
#   Nov 19, 2020: - BUG: error messages missing in wvm_lamp_arg and wvm_adj_arg
#                 - modified to allow bit masks with Thread ids
#   Nov 21, 2020: - improved compilation message to indicate input file name
#                 - added %allLampsOff: %allLampsOn: %allLampsLit: aliases
#   Nov 25, 2020: - allowed for Thread flags using aliases
#   Nov 27, 2020: - WVM_tilt -> WVM_tilt_game
#                 - BUG: undefined thread_arg did not throw an error
#   Nov 28, 2020: - increased # bytes of code to output on -l from 5 to 7 
#   Dec  6, 2020: - updated system 7 API
#                 - added abbreviatons for WVM expressions
#   Dec  8, 2020: - one more
#   May 22, 2021: - modified regexp (deprecated syntax)
#   May 29, 2021: - BUG: only worked for source file in current directory
#                 - suppress ROM output on -l
#                 - began implementing -x
#   May 30, 2021: - continued implementing -x
#   May 31, 2021: - BUG: -x required def_byteblock_hex_alt() for datatables
#                        followed immediately by checksum byte
#                 - BUG: There was a feature ensuring that relative labels used in 
#                        begin/end6800 blocks must reside inside the block, 
#                        because the block is moved before execution. However,
#                        labels just beyond the block end are printed after 
#                        the corresponding end6800 statement during disassembly
#                        by D711, which is important for nesting such
#                        blocks inside _If statements. However, there is
#                        such a block in PEMBOT J1 with a branch statement
#                        to the end of the block. Since the end is technically
#                        outside the block, the safety check failed in this case.
#   Jun  5, 2021: - BUG: die (w/o comment) possible on -f (check removed from
#                        resolve_labels)
#                 - checksum error message removed on -f
#                 - BUG: no error generated on illegal binary digits
#   Jun  6, 2021: - BUG: debug statementleft in place
#   Jun 16, 2021: - added label arithmetic statements to -x output
#                 - BUG: final data table was byteblock_hex() instead of byteblock_hex_alt()
#                 - renamed byteblock_hex_alt() to byteblock_hex_magic()
#   Jul 17, 2021: - BUG: no error check for missing arguments in M6800 code
#   Jul 24, 2021: - added info on RAM location of extraballs waiting from SC
#   Sep 30, 2021: - improved .STR parsing
#                 - added .ASCII
#   Oct  2, 2021: - BUG: @COMPILATION_TIMESTAMP produced :
#                 - made prefix labels definable
#   Oct 10, 2021: - adapted lightly to updated D711.pm
#   Oct  6, 2022: - added _EXIT_THREAD (not used in Pinbot!)
#                 - added support for ANALYSIS_GAP:
#                 - BUG: could not use label arithmethic before label was defined
#   Oct  7, 2022: - added address to debug output
#   Oct  8, 2022: - removed unnecessary hard-coded sleep and start routine addresses
#                 - BUG: invalid 14-segment string test
#   Oct  9, 2022: - fiddled
#   Oct 13, 2022: - added @COMPILATION_INFO
#                 - added @FREE_SP
#   Oct 16, 2022: - adapted calc_checksums() to WMS convention
#                 - BUG: @COMPILATION_INFO reported current release instead of next one
#   Oct 22, 2022: - added .DBBW
#   Oct 23, 2022: - added optional # to sleep argument
#                 - BUG: thread args were not allowed in %findThread: in System 11
#                 - added _Next macro to allow FOR-NEXT loops
#                 - added _ExitLoop and _EXITLOOP labels
#   Oct 26, 2022: - added _PSHX and _PULX
#                 - added _SETFLAG, _CLEARFLAG, _TESTFLAG
#   Oct 28, 2022: - added missing _CLEARFLAG[B]
#                 - BUG: _ExitLoop did not work correctly with _Until and _While
#   Oct 30, 2022: - undid Oct 23 fix#2 and replaced it with a better one
#                 - did the same for Switch#
#   Nov  5, 2022: - added two additional % alternatives (%blinking, %litOrBlinking:)
#   Nov  8, 2022: - improved treatment of Sol# handling
#   Nov  9, 2022: - BUG: accidentally allowed re-definition of number lexicals
#                 - added + as an another legal character for alias names, which disables
#                   arithmetic processing for aliases with + symbol (- had been handled differently)
#                 - added numbers/labels as additional conditional exprs
#   Nov 10, 2022: - increased code listing to 15 bytes per instruction to show string16
#                 - BUG: period in last chacter of string is ignored
#   Nov 11, 2022: - BUG: #$ and #$xxx arguments produced 0
#                 - changed line continuation to allow comments on all lines
#   Nov 12, 2022: - BUG: -l did missed \n
#   Jan  9, 2023: - BUG: System 7 compilation broken (WVM_start, sleepI)
#                 - BUG: .OPTIMIZABLE jumps had no NL at end???
#   Feb  7, 2023: - BUG: optimizable statements did not work any more?!?
#                 - added support for COMPILATION_INFO77
#   Feb 11, 2023: - improved error messages for out-of-range auto labels (e.g. long _Ifs)
#   Feb 12, 2023: - added error for unmatched end statements
#   Feb 14, 2023: - added error messages for open if and loop statements
#   Feb 26, 2023: - improved to allow %equal: #L_xxx (instead of only w/o #)
#   Mar 15, 2023: - added WVM expression checks (found 2 bugs in TCM immediately)
#   Mar 23, 2023: - improved error checking and messages in resolve_labels
#   Mar 25, 2023: - added -e
#   Mar 26, 2023: - added .DBWB
#                 - added .UNDEF
#                 - added warnings for used but not defined DEFINES
#                 - added -J
#   Mar 28, 2023: - added _BOOT_JSR
#   Mar 29, 2023: - improved error message
#   Apr  4, 2023: - added -I)VM source support for _WVM_MODE (level 1),
#                   _EXIT_THREAD (level 2), !oneShot (level 1),
#                 - added PSHX, PULX (level 3)
#                 - added _SETFLAG[], _CLEARFLAG[] (level 1)
#   Apr  5, 2023: - diddled for debugging
#   Apr  6, 2023: - added IVM defines
#   Apr  7, 2023: - re-wrote optimization with -1/-2 options, keeping
#                   -f and -o for compatibility
#                 - completed adaptation to lower-case hex digits everywhere
#                 - removed old -v
#                 - replaced -w by -v
#                 - added new -w
#   Apr  8, 2023: - reversed sort on -J output
#                 - improved warning message
#                 - added support for lbl&$FF+2
#   Apr 11, 2023: - BUG: bad R. release info
#   Apr 15, 2023: - added labels to -l output
#   Apr 17, 2023: - added .UNDEFINE
#                 - fixed two bugs with -l output
#   Apr 21, 2023: - BUG: Optimizer: had old STAGE3/4
#                 - added IVM_mode, PSHX, PULX mnemonics
#                 - added AAX, ABX macros and mnemonics
#   Apr 23, 2023: - made -l quiet (suppress diagnostics and warnings)
#   Apr 26, 2023: - added .DISABLE_IVM .ENABLE_IVM
#                 - added oneShot assembly errors
#                 - BUG: IVM_mode not used
#   Apr 27, 2023: - BUG: _CLEARFLAG was optimized to !setBits
#   Apr 28, 2023: - BUG: -t produced output (completely pointless)
#   Apr 29, 2023: - added support for -I5
#   Apr 30, 2023: - BUG: I5 OPC did not process arguments
#   May  4, 2023: - added {ScoreByte} encoder
#                 - added {zStrPtr} encoder
#                 - added {LSB} {MSB} encoders
#                 - BUG: encoders did not allow arithmetic
#   May 11, 2023: - added {InvertByte} encoder
#   May 16, 2023: - allowed for value when using .UNDEF[INE]
#                 - changed IVM_mode opcode to $00
#   May 19, 2023: - BUG: label decimalization ignored {Interpreter}
#                 - BUG: labelValue() did not handle hex and binary numbers correctly
#                 - BUG: -I5 (re-)used opcode $00
#                 - BUG: {zStrPtr} was never implemented
#                 - BUG: .ZSTR produced trash
#                 - changed .ZSTR encoding from A-Z0-4 to A-Z0-35, consistent
#                   with .STR encoding (and, thus, efficient to unpack)
#   May 20, 2023: - added -m to suppress detail memory output
#                 - added info on # bytes missing on ROM overflow errors
#	May 21, 2023: - inverted ZSTR encoding bits to make decoding easier
#				  - disabled {zStrPtr} Interpreter
#	May 22, 2023: - added optional length to .STR
#				  - removed .TZSTR
#	May 23, 2023: - updated to new STAGE system
#				  - re-enabled noOperation in IVM_mode
#				  - BUG: new syscalls could only be compiled as !oneShots??!?!?!
#				  - BUG: optimizer had old STAGE defintions
#				  - added check for !oneShot in begin6800/6800
#	May 24, 2023: - minor cosmetic change
#	Jun  7, 2023: - BUG: wrong IVM oneshot opcode check
#	Jun  8, 2023: - added _M6800_sleep
#	Aug 30, 2023: - renamed %gameTilted to %ballTilted
#	Sep 16, 2023: - added restriction to %findThread% ids
#	Sep 24, 2023: - BUG: SETFLAG/CLEARFLAG/TESTFLAG had wrong argument range checks
#				  - added _LAMPON[A], _LAMPON[B]
#	Sep 27, 2023: - BUG: optimizer was active even in false .IFDEF branches!!!
#	Oct 13, 2023: - renamed SolCmd tics to tictocs
#	Oct 20, 2023: - added _!IF and _!UNLESS
#	Oct 21, 2023: - added _NEXTLOOP, _NextLoop
#	Oct 28, 2023: - implemented mode checking
#				  - added .WVM_MODE
#				  - added -R
#	Oct 29, 2023: - gave mode checking teeth
#				  - exported all encoders to separate files (modularized design)
#	Dec  3, 2023: - added support for << (left shift) to label arithmetic
#				  - bug string length check did not allow for \xx codes
#	Dec 18, 2023: - added _ENDUNLESS
#	Dec 19, 2023: - BUG: jump6800 did not change the mode
#	Dec 20, 2023: - added _ENDLOOOP (long loop with JMP)
#	Jan  1, 2024: - added support for System 6
# 	Jan  5, 2024: - added -g to support Sys 6 EPROM adapter
#	Jan  6, 2024: - added -a to support full Sys 6 address range
#	Jan  9, 2024: - disabled empty optimizaition warning unless -v
#				  - added sys6 checksum handling
#	Jan 18, 2024: - added .IFDEF || support
#	Jan 20, 2024: - BUG: Flag#XX|$80 was not allowed, but same with Lamp was
#	Feb 12, 2024: - BUG: S11 checksum no longer worked
#	Feb 18, 2024: - added -i and -k for GreenRom.s6
#				  - BUG: TXS produced wrong opcode!!!
#	May 27, 2024: - modularized System APIs
#	May 31, 2024: - disallow Flag#3, Lamp#2, etc.
#				  - added {BitMask} and {ByteOffset}
#	Aug 24, 2024: - added support for <_LOOP and >_EXITLOOP pseusdo labels
#	Aug 25, 2024: - added support for <RTS and >RTS
#	Oct 10, 2024: - BUG: Flag# with trailing arithmetic was not allowed?!?!?!
#	Oct 25, 2024: - if encoder not found, try with WMS-system suffix (e.g. .s6)
#	Oct 27, 2024: - change order of encoder loading, starting with the one with a suffix
#	Nov  2, 2024: - BUG: -t/-r did not respect -p
#				  - adapted -D to allow multiple symbols
#	Nov  6, 2024: - improved error messages
#	Nov  7, 2024: - replaced -i/-a by new -a
#				  - added new -i to load API
#	Nov  9, 2024: - shuffled options and added API output
#	Nov 12, 2024: - added define_alias()
#	Nov 14, 2024: - added .DECLARE
#				  - added match_pragma to deal properly with abbreviations
#	Nov 16, 2024: - added .+1 capability to define_label
#	Nov 24, 2024: - BUG: encoder alias substitution did not work any more for TCM
#	Dec 13, 2024: - added export support for @ALIASes when  producing API
#	Dec 14, 2024: - added .ASSUME_DEFINED, .ASSUME_UNDEFINED
#	Feb  4, 2025: - BUG: .ASSUME_UNDEFINED increased the reference counts
#	Feb  9. 2025: - BUG: expand_aliases did not handle all exceptions correctly
#	Feb 19, 2025: - added .[UN]LOCK_ROM_PAGE
#	Feb 22, 2025: - BUG: sys6 compilation without -o option broken (wrong ROM range)
#	Feb 23, 2025: - BUG: -I defined @aliases that were not defined in library
#				  - changed defined value from !DEFINED! to ALIAS_IS_DEFINED for clarity
#	Mar  2, 2025: - BUG: checksum handling was wrong for Sys 6 code linked with
#						 non-std OS
#				  - added fake error message to label when >RTS is used without
#				    RTS in following code
#	Mar  4, 2025: - added -T)race assembly
#				  - BUG: label-type error preventing PEMBOT from compiling
#				  - BUG: oneshot jump/branchSubroutine6800 had wrong code mode
#	Mar  6, 2025: - made .DECLARE multi-valued
#				  - improved .UNDEF parsing
#	Mar  8, 2025: - BUG: oneshot did not work correctly with mode checking
#				  - BUG: .UNDEF needs to allow multiple arguments, since .DEFINE does
#				  > first version that correctly compiles Ideal.s6, PEMBOT.s11 and TCM.s11
#	Mar 11, 2025: - updated assertions for new defined alias string (DEFINED_ALIAS)
#				  - extended -D to allow assignment of values
#				  - BUG: Cannot decode number error message did not list number
#	Apr 23, 2025: - added &expand_repeatBytes
#	Apr 24, 2025: - &expand_repeatBytes only looked at least significant digit
#	Apr 25, 2025: - disabled checksum verification for System 6 System ROMs (GreenROM)
#				  - suppress hg not found error message on systems w/o Mercurial
#	May  7, 2025: - RTI returned wrong mode
#	May  8, 2025: - replaced sleep_subOptimal by longSleep
#				  - replaced copyTo by load
#				  - replaced decAndBranchUnless0 by decAndBranchUnlessZero
#				  - renamed many alternate Lampgroup ops
#	May  9, 2025: - BUG: encode_scoreByte() could not handle 25000
#	May 10, 2025: - renamed two pseudo label alternate names
#				  - added .DATA_MODE, .M6800_MODE, .M6809_MODE
#				  - added -f
#	May 12, 2025: - BUG: data pragmas set mode to 3
#	May 13, 2025: - added better error message for lexical labels erroneously used
#				    with JMP instructions
#	May 14, 2025: - added implicit .DECLARE to .ASSUME_UNDEFINED
#	May 15: 2025: - BUG: page locking was checked during phase 1
#				  - BUG: page locking considered 1 byte beyond block
#	May 19, 2025: - BUG: .IFUNDEF did not work
#	May 22, 2025: - added use strict vars, finding several bugs in the process
#	May 23, 2025: - made it work
#				  - started working on WPC support
#	May 26, 2025: - continued implementing WPC support
#	May 27, 2025: - continued implementing WPC support
#	May 29, 2025: - continued implementing WPC support
# HISTORY END

# RELEASE NOTES:
#	- jump6800 does not mark the target as mode-1 (no support for mode propagation
#	  in asm_wvm_op yet)
#	- Loop pseudo labels:
#		- _ExitLoop, _EXITLOOP jump to first statement past end of loop
#		- _NextLoop, _NEXTLOOP jump to beginning of loop
#   	- _ExitLoop with _Until and _While statements assumes that each word in the
#     	  expression accounts for exactly one byte
#	- long loops:
#		- use _ENDLOOOP to JMP instead of BRA
#   - 1 or 2-byte addressing mode for M6800 ops is determined at compile time
#     from known value of labels. This means that all zero page labels have
#     to be defined before they are used
#   - label identifiers can use letters, numbers, underscore, as well as ?
#   - modes as well as if/unless can be mixed in structured programming statements,
#           e.g. _IF_NE _Else _EndUnless 
#   - case sensitive, EXCEPT that case is ignored for M6800 opcodes (but not _MACROS)
#   - when to use .DEFINE vs .LBL:
#       - label names can include + and - characters
#       - alias names cannot
#       - there is label arithmetic, there is no alias arithmetic
#       => when arithmetic is necessary, use labels
#       => no arithmetic allowed switch numbers, for example!
#   - Interpreters
#		- are loaded from $PATH/C711.$encoder
#		- currently implemented
# 	      	- {SolCmd}
#   		- {ScoreByte}
#       	- {LSB} {MSB}
#	       	- {InvertByte}
#			- {BitMask}			for lamps and flags
#			- {ByteOffset}		for lamps and flags
#		- need {eval} for label arithmetic
#			- simplistic arithmetic (+,-,&,|) needs to remain in eval_label() to allow
#			  e.g. LDAA =SolBuf{LSB}+2
#			- this could be disallowed because {eval} provided alternatives
#			  e.g. LDAA (=Solbuf&$00FF)+2{eval}

# System 6 Linker Support:
#	- option -I is used to compile OS and produces API on STDOUT:
#		- metadata (address range & code hash)
#		- non-local (not starting with ~) labels
#		- exported (starting with @) aliases
#	- option -l <OS binary file> is used to compile game code
#		- in addition to <OS binary file> it also reads (imports) the API
#		- API file has same basename and .API extension

# System 11 Ideal Virtual Machine (IVM) Support:
#   - Stage 1:  !oneShot                            IVM_STAGE1
#               IVM_mode
#               _WVM_MODE       optimization
#               _SETFLAG[?]     optimization
#               _CLEARFLAG[?]   optimization
#				_LAMPON[?]		optimization
#				_LAMPOFF[?]		optimization
#   - Stage 2:  soundcardCmd                       IVM_STAGE2
#               displayStr
#               incAudit
#	- Stage 3: 	.ZSTR								IVM_STAGE3
#   - Stage 4:  _PSHX, _PULX    optimization        IVM_STAGE4
#               _AAX, _ABX      optimization
#   - Stage 5:  _SLEEP          optimization        IVM_STAGE5

# Optimizer:
#   - 2 pass compilation:
#       -1 finds optimizable instructions
#           - done in resolve_labels()
#           - -f can be used to restrict address range
#           - optimization instructions on stdout (if redirected)
#             or in .OPTINFO_<src-file-name>
#       -2 compiles with optimization
#           - -o can be used to supply optiization instructions
#             from non-standard file
#   - optimizable instructions:
#       WVM       : JSR, JMP, jump.*
#       IVM STAGE1: _WVM_MODE, _SETFLAG[A], _SETFLAG[B], _CLEARFLAG[A], _CLEARFLAG[B], _EXIT_THREAD
#				    _LAMPON[A], _LAMPOFF[A]
#       IVM_STAGE4: _PSHX, _PULX, _AAX, _ABX
#       IVM_STAGE5: _SLEEP
#   - suppress optimization:
#       - !! at the beginning of a line turns off optimization for the line
#       - .SUPPRESS_OPTIMIZATION <RE> suppressess optimizations for all
#         instructions starting with the regular expression
#           - e.e. .SUPPRESS_OPTIMIZATION [jJ] disables all jump optimization

# TO-DO:
#   - improve error messages and add more warnings
#   ? add -U)ndefine option
#   ? add .INCLUDE (this will break line number stuff)
#   ? add _ELSE_IF, _ElseIf
#   ? add _UNLESS_NE, _ENDUNLESS
#   ? add .IF <var|val> [=,!=,<,>,<=,>=] <var|val>
#   ? implement more general label arithmetic

no warnings 'deprecated';                                       # suppress warning about Goto into structure :)
use strict vars;

our($EIGHT_BIT_LABEL_PREFIX)   = '(';                            # don't start labels with these characters or with numbers
our($TWELVE_BIT_LABEL_PREFIX)  = ')';
our($SIXTEEN_BIT_LABEL_PREFIX) = '|';
our($OPTIMIZABLE_LABEL_PREFIX) = '`';                            # this is preceded by a numeric (decimal byte offset)

my($PATH) = $0; $PATH =~ s{/[^/]*$}{};

use Getopt::Std;
die("Usage: $0 \n\t[system -6|-7 source] [-W)PC <A[lphanumeric>|DM[D]|F[liptronic]|DC[S]|S[ecurity]|9[5]" .
			  "\n\t[sys11 I-V)M <stage>]" .
              "\n\t[-D)EFINE <symbol>]" .																# conditional compilation
              "\n\t[-1)st pass [-F)ind optimizable statements <from-addr,to-addr>]]" .					# code optimization
              "\n\t[-2)nd pass [-O)ptimization info <file>]]" .
              "\n\t[system -i)nterface <API file>] [-l)ink system <code file> (s6)]" .					# game code compilation/linker
			  "\n\t[output -I)nterface on stdout (s6)]" .												# system code compilation/linker
			  "\n\t[-o)utput <file> (s6)] [prepend image with -g)ap of <x> KB of FF bytes (s6)]" .		# linker output control
              "\n\t[ROM -a)ddress range <min hex addr,max hex addr>]".									# compilation/output address range
              "\n\t[ROM output -s <suffix>] [create -e)qual-sized (32K) ROM images (s11)]" .			# ROM image output control
              "\n\t[suppress -w)arnings] [-v)erbose (show warnings)]" .									# general compilation options
   			  "\n\t[suppress chec-k)sum verification]" .
			  "\n\t[-f)orce (attempt compilation of source files with disassembly warnings)]" .
			  "\n\t[alt. output code -L)isting] [-x) alt. output D711 .dasm file]" .					# alternative output options
              "\n\t[-d)ump labels] [dump -J)SR targets] [dump -R)OM before resolving labels]" .			
              "\n\t[-c)hecksum info] [report free -m)emory blocks]" .
              "\n\t[-t)rust_but_verify <ROM_image[,...]> [check already during label -r)esolution]]" .	# ouput checking
              "\n\t[-T)race compilation (debug)] [trace -C)onditional compilation (debug)]" .			# debugging
	          "\n\t[verify -A)ddress information in source (debug)]" .
              "\n\t<asm file>\n")
    unless &getopts('1267Aa:cCdD:efF:g:i:IJkLl:mO:o:Rrs:Tt:V:vW:wx') && (@ARGV == 1);

our($opt_1,$opt_2,$opt_6,$opt_7,$opt_a,$opt_A,$opt_c,$opt_C,$opt_d,$opt_D,$opt_e,$opt_f,$opt_F,
	$opt_g,$opt_i,$opt_I,$opt_J,$opt_k,$opt_L,$opt_l,$opt_m,$opt_o,$opt_O,$opt_r,$opt_R,
	$opt_s,$opt_t,$opt_T,$opt_v,$opt_V,$opt_w,$opt_W,$opt_x);

my($dummy,$basename,$ext) = ($ARGV[0] =~ m{([^/]+/)?([^\.]+)\.(.*)}); 
$basename = 'out' unless defined($basename);

our($WMS_System);      																					# source type
if ($opt_6 || ($ext =~ m{^[sS]6$})) {
	$WMS_System = 6;
} elsif ($opt_7 || ($ext =~ m{^[sS]7$})) {
	$WMS_System = 7;
} elsif ($ext =~ m{^[sS]11$}) {
	$WMS_System = 11;
} elsif ($opt_W =~ m{^A}) {
	$WMS_System = 'WPC(Alphanumeric)';
} elsif ($opt_W =~ m{^DM}) {
	$WMS_System = 'WPC(DMD)';
} elsif ($opt_W =~ m{^F}) {
	$WMS_System = 'WPC(Fliptronic)';
} elsif ($opt_W =~ m{^DC}) {
	$WMS_System = 'WPC(DCS)';
} elsif ($opt_W =~ m{^S}) {
	$WMS_System = 'WPC(Security)';
} elsif ($opt_W =~ m{^9}) {
	$WMS_System = 'WPC(95)';
} else {
	die("$0: cannot determine source type\n");
}

die("$0: System11 source required for -e\n")
    if ($opt_e && $WMS_System != 11);

#----------------------------------------------------------------------
# Load System Dependent Libraries
#----------------------------------------------------------------------

my($unroll_structureR,$asm_macrosR);

use lib ($0 =~ m@/[^/]*$@,$`);												# add 7eleven installation dir to path

if ($WMS_System == 6) {
	require "C711.M6800";

	$unroll_structureR = sub {
							unroll_asm_structure(@_);
						 };
	$asm_macrosR = sub {
						return asm_6800_macros();
    			   };

} elsif ($WMS_System == 7 || $WMS_System == 11) {
	require "C711.M6800";
	require "C711.VM";

	$unroll_structureR = sub {
							unroll_asm_structure(@_);
			  				unroll_wvm_structure(@_);
						 };

	$asm_macrosR = sub {
						my($retval) = asm_6800_macros();
						return $retval if $retval;
						return asm_wvm_macros();
    			   };

} elsif ($WMS_System =~ m{^WPC}) {
	require "C711.M6809";
	require "C711.WPC";

	$unroll_structureR = sub {
							unroll_asm_structure(@_);
						 };
	$asm_macrosR = sub {
						return asm_6809_macros();
    			   };
} else {
	die("Unsupported WMS System <$WMS_System>\n");
}

#----------------------------------------------------------------------
# Global Variables
#	my		PRIVATE: available in this source file only
#	our		available in entire compiler
#----------------------------------------------------------------------

our(@ROM);														# output buffer
our($ADDR,$MIN_ROM_ADDR,$MAX_ROM_ADDR);							# Sys6-11: CPU address space; WPC: 1MB ROM address space
our($RPG);														# Sys6-11: undefined; 		  WPC: current ROM page
our($DP);														# undefined until .ASSUME_DP is used

if ($WMS_System == 6) {											# System6
	$MIN_ROM_ADDR = 0x6000; 
	$MAX_ROM_ADDR = 0x67FF;
} elsif ($WMS_System == 7) {									# System7
	$MIN_ROM_ADDR = 0xD800; 
	$MAX_ROM_ADDR = 0xE7FF;
} elsif ($WMS_System == 11) {									# System11
	$MIN_ROM_ADDR = 0x4000; 			 
	$MAX_ROM_ADDR = 0xFFFF;
} elsif ($WMS_System =~ m{^WPC}) {								# WPC (1MB ROM)
	$MIN_ROM_ADDR = 0x00000;
	$MAX_ROM_ADDR = 0xFFFFF;									
} else {
	die;
}

if (defined($opt_a)) {											# override ROM address range with -a
	my($mia,$maa) = split(',',$opt_a);
	$MIN_ROM_ADDR = hex($mia);
	$MAX_ROM_ADDR = hex($maa);
	die("$0: cannot decode -a $opt_a")
		unless ($MAX_ROM_ADDR > 0);
}
	
my($FIRST_ADDR) = $MAX_ROM_ADDR + 1;                            # PRIVATE: first @ROM address used; sentinel (true value set by .ORG)

my(@vROMimage);                                                 # PRIVATE: verification ROM image

our(@SRC);														# source lines (used for optimizer and warnings)
local(our(@LINE));												# source line number indexed by ADDR (used for optimizer and warnings)

local(our($OP,@OP_ARG));										# currently compiling operation and argments

local(our(%ALIAS,%ALIAS_REFD));                                 # aliases (defines), number of references
our(%LBL);														# labels (name -> address)
our(%LBP);														# ROM page of label (undef except in WPC)
our(%LBL_TYPE);													# label type (see MODE below)
our(@LBL);														# labels (address -> name)
our(@newly_defined_label);										# list of newly defined labels (since last instruction), possibly of unknown type

my(@AUTO_LABEL_DEF);											# PRIVATE: line numbers of auto label definitions for error messages

my(@IF_STACK) = (0);                                            # PRIVATE: conditional compilation (TOS 0: sentinel: outside any if; 1: then/else compiling; -1: then/else not compiling; -2: nested if, not compiling)

our($EXEC6800_BLOCK_ID) = 0;                                   	# WVM begin6800/end6800 blocks; 0: outside block, >0 inside block 
our($MODE) = 0;													# compilation mode/label type; 0: undefined; 1: M6800; 2: WVM/IVM; 3: data

our(%JSR_TRG);													# number of calls to subroutines for -J

our(@IF_CONT_LBL,@LOOP_DONE_LBL);								# structured programming

our($IVM_DISABLED);												# flag indicating that IVM is disabled; set by .ENABLE_IVM/.DISABLE_IVM

#----------------------------------------------------------------------
# Command-Line Options
#----------------------------------------------------------------------

if (defined($opt_V)) {                                          # IVM support
    die("cannot decode -V $opt_V\n")
        unless ($opt_V =~ m/^\d+$/);
}
my($i);     
for ($i=1; $i<=$opt_V; $i++) {
    $ALIAS{"IVM_STAGE$i"} = 'ALIAS_IS_DEFINED';
    $ALIAS_REFD{"IVM_STAGE$i"}++;
}
while ($i < 20) {
    $ALIAS_REFD{"IVM_STAGE$i"} = -99;                           # prevent compiler warnings
    $i++;
}

die("$ARGV[0]: No such file or directory\n")                    # check input file
    unless (-r $ARGV[0]);

$opt_w = 1 if $opt_L;                                           # suppress warnings on code outputs

die("-f requires -1 (1st pass)\n")                              # OPTIMIZER (1st pass)
    if ($opt_F && !$opt_1);
my($opt_F_from,$opt_F_to) = (0x0000,0xFFFF);                    # address range for optimizations
if (defined($opt_F)) {
    ($opt_F_from,$opt_F_to) = split(',',$opt_F);
    $opt_F_from = hex($opt_F_from);
    $opt_F_to   = hex($opt_F_to);
    die("cannot decode -f $opt_F\n")
        unless ($opt_F_to > $opt_F_from);
}
if ($opt_1 && -t 1) {                                           # open optimization output file
    open(OPTF,">.OPTINFO_$ARGV[0]")
        || die(".OPTINFO_$ARGV[0]: $!\n");
}

die("-o requires -2 (2nd pass)\n")                              # OPTIMIZER 2nd pass)
    if ($opt_O && !$opt_2);
my($next_statement_to_optimize);
if ($opt_2) {
    if (defined($opt_O)) {
        open(OF,$opt_O) || die("$opt_O: $!\n");
    } else {
        open(OF,".OPTINFO_$ARGV[0]") || die(".OPTINFO_$ARGV[0]: $!\n");
    }
    my($line) = scalar(<OF>);
    $line =~ s/^\s*//;
    ($next_statement_to_optimize) = split(/\s+/,$line);
	unless (numberp($next_statement_to_optimize)) {
		print(STDERR "Warning: empty optimization information file\n")
			if $opt_v;
		$next_statement_to_optimize = 9e99;
	}
}

if (defined($opt_D)) { 											# define symbol from command line 
	foreach my $s (split(',',$opt_D)) {
		my(@tk) = split('=',$s);								# tokenize
		if (@tk>1 && length($tk[0])>0 && length("@tk[1..$#tk]")>0) {
			$ALIAS{$tk[0]} = "@tk[1..$#tk]";
		    $ALIAS_REFD{$tk[0]}++;
		} else {
			$ALIAS{$s} = 'DEFINED_ALIAS';
		    $ALIAS_REFD{$s}++;
		}
    }
}

load_vROM(split(/,/,$opt_t)) if defined($opt_t);

my($MERCURIAL_RELEASE,$COMPILATION_INFO,$COMPILATION_INFO77,$COMPILATION_TIMESTAMP);

chop($MERCURIAL_RELEASE =                                       # Compilation Information
    `hg log 2>/dev/null | awk -F: '/^ch/{if (NR == 1) print "R."\$2+1}'`);
chop($COMPILATION_INFO =                                        # BAD CATS (16-character display)
    $MERCURIAL_RELEASE . `date '+ %m-%d-%Y'`);
chop($COMPILATION_INFO77 =                                      # PIN BOT (2x7-character display)
    $MERCURIAL_RELEASE . `date '+   %m%d%y'`);
chop($COMPILATION_TIMESTAMP = uc(`date '+%h %d  %H %M '`));     # used for PIN BOT first
printf(STDERR "$ARGV[0] [$COMPILATION_INFO]\n")                 # report on screen during 2nd pass
    unless defined($opt_1 || $opt_L);
    
#----------------------------------------------------------------------
# Load API
#----------------------------------------------------------------------

my($LIB_API) = $opt_i;

unless (defined($LIB_API)) {
	if ($WMS_System =~ m{^WPC}) {
		$LIB_API = "$PATH/WPC.API";
	} else {
		$LIB_API = "$PATH/System$WMS_System.API";
	}
}

my($LIB_MIN_ADDR,$LIB_MAX_ADDR,$LIB_CHECKSUM,@LIB_FN,@LIB_HASH);
my($LIB_BASENAME) = ($LIB_API =~ m{([^/]+)$});

{
	sub code_address_range($$)
	{
		($LIB_MIN_ADDR,$LIB_MAX_ADDR) = @_;
		die(sprintf("$LIB_BASENAME: invalid librarary address range (\$%04X-\$%04X)\n",
			$LIB_MIN_ADDR,$LIB_MAX_ADDR,$MIN_ROM_ADDR))
				unless ($LIB_MAX_ADDR - $LIB_MIN_ADDR >= 2048) && ($LIB_MIN_ADDR >= 0);
	}

	sub code_checksum($)
	{
		($LIB_CHECKSUM) = @_;
		die(sprintf("$LIB_BASENAME: invalid librarary checksum (\$%02X)\n",$LIB_CHECKSUM))
			unless ($LIB_CHECKSUM>=0 && $LIB_CHECKSUM<=0xFF);
	}

	sub code_hash($)
	{
		foreach my $hd (@_) {
			my($fn,$hash) = ($hd =~ m{^SHA2-256\((.*)\)= ([0-9a-fA-F]{64})$});
			die("$LIB_BASENAME: invalid hash specifier <$hd>\n")
				unless defined($hash);
			push(@LIB_FN,$fn);
			push(@LIB_HASH,$hash);				
		}
	}

	require $LIB_API unless ($LIB_API eq '');
}

#----------------------------------------------------------------------
# Linker
#----------------------------------------------------------------------

if (defined($opt_l)) {
	die("$opt_l: need LIB_MIN_ADDR for linking\n")						# check address range
		unless defined($LIB_MIN_ADDR);
	printf(STDERR "$opt_l: WARNING: system code (\$%04X-\$%04X) outside " .
									"ROM address range (\$%04X-\$%04X)\n",
						$LIB_MIN_ADDR,$LIB_MAX_ADDR,$MIN_ROM_ADDR,$MAX_ROM_ADDR)
		if ($LIB_MIN_ADDR > $MAX_ROM_ADDR || $LIB_MAX_ADDR < $MIN_ROM_ADDR);

	my($hd) = `openssl sha256 $opt_l`;									# verify sha256 hash (using openssl)
	my($fn,$hash) = ($hd =~ m{^SHA2-256\((.*)\)= ([0-9a-fA-F]{64})$});
	die("$opt_l: invalid hash specifier <$hd>\n")
        unless defined($hash);
	($fn) = ($fn =~ m{([^/]+)$});        
   	my($match) = 0;
    for (my($i)=0; $i<@LIB_HASH; $i++) {
		next unless ($hash eq $LIB_HASH[$i]);
		$match = 1;
		print(STDERR "$opt_l: WARNING: filename mismatch [$fn vs $LIB_FN[$i]]\n")
			unless ($fn eq $LIB_FN[$i]);
		last;
	}
	die("$opt_l: hash mismatch\n")
		unless $match;

	open(F,$opt_l) || die("$opt_l: $!\n");								# read code
	my($ROMimage);
	my($nRead) = read(F,$ROMimage,0xFFFF);
    die("$opt_l: no data\n") unless ($nRead > 0);
	die("$opt_l: size does not match LIB_MIN/MAX_ADDR information\n")	# make sure API agrees 
		unless ($nRead == $LIB_MAX_ADDR-$LIB_MIN_ADDR+1);

	@ROM[$LIB_MIN_ADDR..$LIB_MAX_ADDR] = unpack("C*",$ROMimage); 		# populate @ROM
}

#======================================================================
# Main Program
#======================================================================

my($EXTRA);																# additional statements on the current line
my(@NO_OPT);															# addresses where optimization is not allowed; set by !! line prefix
my(@optimization_suppressed);											# instructions that must not be optimized; set by .SUPPRESS_OPTIMIZATION
my(@OP);																# address -> instruction for optimizer
my($locked_page);														# page addr (MSB ROM address) for .[UN]LOCK_ROM_PAGE
my($tag_rpg,$tag_addr);													# address info from <> line prefix

while (!eof()) {
	if ($EXTRA) {														# additional statements on current line
##		print(STDERR "EXTRA = $EXTRA\n");
		$_ = $EXTRA;
		undef($EXTRA);
	} else {
		$_ = <>;
	}

	if (defined($ADDR) && ($ADDR<$MIN_ROM_ADDR || $ADDR>$MAX_ROM_ADDR+1)) {
		if ($opt_v || $opt_t) {
			printf(STDERR "WARNING: ROM overflow (\$%04X) at input line $.\n",$ADDR);
		} elsif (!$opt_1) {
			die(sprintf("ROM overflow (\$%04X) at input line $.\n",$ADDR));
		}
	}
	chomp;																# strip EOL
	s{;.*}{};															# strip comments
	m{^<([0-9A-Fa-f]{2})?:?([0-9A-Fa-f]{4})>};							# record address information for -A
	$tag_rpg   = hex($1) if defined($1);
	$tag_addr = hex($2) if defined($2);
	s{^<([0-9A-Fa-f]{2}:)?[0-9A-Fa-f]{4}>\s+}{};						# strip disassembly addresses and leading whitespace
	while (m{\\\s*$}) { 												# line continuation
		$_ = $` . <>;
		chomp;															# strip EOL
		s{;.*}{};														# strip comments
	}

	if ($IF_STACK[$#IF_STACK] >= 0) {									# currently assembling code
		if (m{^\s*!!}) {												# OPTIMIZER: disable writing of optimization instruction for this line
			die unless defined($ADDR);
			$_ = $';
			$NO_OPT[$ADDR] = 1;
		}
	
		if ($opt_2) {													# Optimizer: Pass 2: Implement instructions
			die("Invalid optimization information for line $next_statement_to_optimize\n")
				unless numberp($next_statement_to_optimize) && ($next_statement_to_optimize >= $.);
			if ($next_statement_to_optimize == $.) {
				my($suppress);
				foreach my $s (@optimization_suppressed) {				# .SUPPRESS_OPTIMIZATION 
					$suppress=1,last if m{^\s*$s};
				}
				unless ($suppress) {
#				print(STDERR "[Optimizer: optimizing $_]\n");
					my($subst) = 0; 									# optimize this statement
				    
					$subst += s/\bJMP\b/BRA/g;							# JMP
					$subst += s/\bJSR\b/BSR/g;							# JSR
					$subst += s/\bjump/branch/g;						# branchIf, branchUnless, branch
					if ($opt_V >= 1) {									# IVM STAGE1
						$subst += s/\b_WVM_MODE\b/!IVM_mode/g;			# _WVM_MODE
						$subst += s/\b_SETFLAG\[A\]/!setBits/g; 		# _SETFLAG[A]
						$subst += s/\b_SETFLAG\[B\]/!setBits/g; 		# _SETFLAG[B]
						$subst += s/\b_LAMPON\[A\]/!setBits/g;			# _LAMPON[A]
						$subst += s/\b_CLEARFLAG\[A\]/!clearBits/g; 	# _CLEARFLAG[A]
						$subst += s/\b_CLEARFLAG\[B\]/!clearBits/g; 	# _CLEARFLAG[B]
						$subst += s/\b_LAMPOFF\[A\]/!clearBits/g;		# _LAMPOFF[A]
						$subst += s/\b_EXIT_THREAD\b/!exitThread/g; 	# _EXIT_THREAD
					}
					if ($opt_V >= 4) {									# IVM STAGE4
						$subst += s/\b_PSHX\b/!PSHX/g;					# _PSHX
						$subst += s/\b_PULX\b/!PULX/g;					# _PULX
						$subst += s/\b_AAX\b/!AAX/g;					# _AAX
						$subst += s/\b_ABX\b/!ABX/g;					# _ABX
					}
					if ($opt_V >= 5) {									# IVM STAGE5
						$subst += s/\b_SLEEP\b/!sleep/g;				# _SLEEP
					}
				    
					die("failed optimization instruction for line $next_statement_to_optimize\n")
						unless ($subst > 0);
					printf(STDERR "%5d: WARNING: ambiguous optimization substitution\n",$next_statement_to_optimize)
						if ($subst > 1);
				}
				my($srcln) = $.;
				$next_statement_to_optimize = eof(OF) ? 9e99 : <OF>;
				$. = $srcln;
				my(@tmp) = split(/\s+/,$next_statement_to_optimize);
				$next_statement_to_optimize = $tmp[0];
			}
	    }
	}
    
    if (defined($ADDR)) {                                   			# store source statement for listing, warnings, optimization 
        $SRC[$ADDR] = $_;
        $LINE[$ADDR] = $.;
    }
    
    @_ = split;                                             			# tokenize (separate into operator and operands)

	for (my($i)=0; $i<@_; $i++) {										# handle addtional statements on same line
		next unless $_[$i] eq '&';
		$EXTRA = "@_[$i+1..$#_]";
		splice(@_,$i);
	}
		
    next unless (@_ > 0);                                   			# empty line => nothing to compile

    $MODE = 0 if $opt_f;												# force compilation of "dirty" source files

	printf(STDERR "$. \[ADDR=%04X MODE=$MODE IF_STACK=$IF_STACK[$#IF_STACK]]: %s (@newly_defined_label)\n",$ADDR,"@_")
		if $opt_T;														# trace compilation

    if ($IF_STACK[$#IF_STACK] >= 0) {                       			# currently assembling code
        if ($_[0] =~ m{:$}) {                               			# define label
            define_label($`);
            push(@newly_defined_label,$`);
			set_label_type($MODE) if ($MODE > 0);
            shift(@_);
            next if (@_ == 0);                              			# label-only line => nothing to compile
        }
    
        &expand_aliases;                                    			# expand aliases (except for .IFDEF, .IFNDEF, etc. which are handled in compile_pragma())
		&expand_repeatBytes;											# expand $FF[512x] 255[2x]
		&expand_bang;													# expand !longJSR
        &decimalize;                                        			# convert all numbers to decimal (e.g. for .ORG); NB: does not deal with #$numbers
        ($OP,@OP_ARG) = @_;                                 			# make available to all subroutines (local)
        $OP[$ADDR] = $OP;                                   			# make available to OPTIMIZER

        $unroll_structureR->();                                			# _IF, _Loop, etc.  
        next unless defined($OP);                           			# some structure keywords only generate labels
    }

    next if &compile_pragma;                               				# .ORG, .DB, .ENDIF, etc.; also done while not currently compiling code!

    if ($IF_STACK[$#IF_STACK] >= 0) {                       			# currently assembling code
    	if ($opt_A) {													# verify <> address information
    		if (defined($RPG)) {
    			my($caddr) = ($RPG == 0xFF) ? $ADDR : ($ADDR + 0x4000) - $RPG*0x4000;
	    		die(sprintf("ROM reference mismatch (%02X:%04X expected, %02X:%04X found) at input line $.\n",$tag_rpg,$tag_addr,$RPG,$caddr))
    				unless ($caddr == $tag_addr) && ($RPG == $tag_rpg);
    		} else {
	    		die(sprintf("ROM address mismatch (\$%04X expected, \$%04X found) at input line $.\n",$tag_addr,$ADDR))
    				unless ($ADDR == $tag_addr);
    		}
    	}

		next if $asm_macrosR->();

        if (($MODE==0||$MODE==1) && &compile_asm) {       				# LDA, _IFEQ, etc.
            set_label_type(1);
            next;
        }
		if ($WMS_System>=7 && $WMS_System<=11) {
			if (($MODE==0||$MODE==2) && &compile_vm(2)) {				# load, sleep, _If, etc.
				set_label_type(2,1);
				next;
	        }
	    }
        die("unrecognized mode-$MODE statement <@_> at input line $.\n");
    }
}

die("missing .ENDIF at EOF\n")											# End-of-File checks
    if ($IF_STACK[$#IF_STACK] != 0);

die("missing .UNLOCK_PAGE at EOF\n")
	if defined($locked_page);

die("Unfinished if statement(s) at EOF [@IF_CONT_LBL]\n")
    if (@IF_CONT_LBL);

if (@LOOP_DONE_LBL) {
    print(STDERR "Unfinished loop statement(s) at EOF:\n");
    foreach my $lbl (@LOOP_DONE_LBL) {
        my($lno) = ($lbl =~ m{_(\d+)$});
        printf(STDERR "\t$lbl defined on line %d\n",$AUTO_LABEL_DEF[$lno]);
    }
    exit(1);
}

#----------------------------------------------------------------------

if ($opt_d) {                                               # dump labels
    dump_labels();
    exit(0);
}

if ($opt_R) {												# dump ROM
	dump_ROM();
	exit(0);
}

check_duplicate_label_types()								# make sure duplicate labels have same type
	unless $opt_1;
resolve_labels();                                           # resolve labels; writes OPTIMIZER instructions during 1st pass
my($bytesFree) = find_free_space();                             # scan/report free space

my($FREE_SP_ADDR);
if (defined($FREE_SP_ADDR)) {                               # handle @FREE_SP (compiler variable)
    my($freestr) = sprintf('%5d BF',$bytesFree);
#   print(STDERR "[$freestr]\n") unless defined($opt_1);
    for (my($i)=0; $i<8; $i++) {
        $ROM[$FREE_SP_ADDR+$i] = ord(substr($freestr,$i,1));
        $ROM[$FREE_SP_ADDR+$i] |= 0x80 if ($i > 5);
    }
}

unless ($opt_1 || $opt_k) {	                                # Checksums on 2nd pass
    calc_checksums();                                       # handle @CHECKSUM_BYTE
    verify_checksums();                                     # verify checksums
}

if (defined($opt_t)) {                                      # compare with target com
    verify_vROM();
    exit(0);
}

if ($opt_x) {                                               # create .dasm file
    my($data_start,$data_lbl,$lastAddr);
    foreach my $lbl (sort { $LBL{$a} <=> $LBL{$b} } keys(%LBL)) {
        next unless defined($LBL{$lbl});
        next if ($lbl =~ '^auto_label_\d+');                # ignore auto labels
        printf("&D711::setLabel('%s',0x%04X,1);\n",$lbl,$LBL{$lbl});
        next unless ($LBL{$lbl}>=$MIN_ROM_ADDR && $LBL{$lbl}<=$MAX_ROM_ADDR);
        next if ($LBL{$lbl} == $lastAddr);

        if (defined($data_start)) {                         # data definition in progress
            printf("\t&D711::def_byteblock_hex_magic(%d,'%s');\n",
                $LBL{$lbl}-$data_start,$data_lbl);
            undef($data_start); undef($data_lbl);
        }

        printf("\t\$D711::Address = 0x%04X;\n",$LBL{$lbl});
        $lastAddr = $LBL{$lbl};

        if ($LBL_TYPE{$lbl} eq 'M6800') {
            printf("\t&D711::def_code('%s');\n",$lbl);
        } elsif ($LBL_TYPE{$lbl} eq 'WVM') {
            printf("\t&D711::def_wvm_code('%s');\n",$lbl);
        } elsif ($LBL_TYPE{$lbl} eq 'DATA') {
            $data_start = $lastAddr; $data_lbl = $lbl;
        } else {
            die("$lbl: unknown label type\n");
        }
    }

    if (defined($data_start)) {                         # data definition in progress
        printf("\t&D711::def_byteblock_hex_magic(%d,'%s');\n",
            $MAX_ROM_ADDR+1-$data_start,$data_lbl);
    }
    
    exit(0);
} # if $opt_x

if ($opt_J) {                                               # dump JSR targets
    dump_JSR();
    exit(0);
}

exit(0) if $opt_1;                                          # on 1st pass we are done

unless ($opt_w || $opt_L) {
    foreach my $a (sort keys(%ALIAS_REFD)) { 				# final pass => produce warnings	
        print(STDERR "WARNING: alias $a referenced but not defined\n")
            if ($ALIAS_REFD{$a} > 0) && !defined($ALIAS{$a});
    }
}

produce_output();                                           # output either code listing or ROM image files

if (defined($opt_I)) {										# output Interface (API)
	printf("code_address_range(0x%04X,0x%04X);\n",
		$MIN_ROM_ADDR,$MAX_ROM_ADDR);
	my($sum,$carry) = (0,0);
	for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {
		$sum += defined($ROM[$a]) ? $ROM[$a] : 0xFF;
		$sum++ if ($carry);
		if ($sum > 0xFF) {
			$sum &= 0xFF;
			$carry = 1;
		} else {
			$carry = 0;
		}
	}
	$sum++ if $carry;										# IMPORTANT!!!
	printf("code_checksum(0x%02X);\n",$sum);		

	if (defined($opt_o)) {									# single linked output 
		chomp(my($hash) = `openssl sha256 $opt_o`);
		print("code_hash('$hash');\n");
    }
	foreach my $lbl (sort { $LBL{$a} <=> $LBL{$b} } keys(%LBL)) {
		next unless defined($LBL{$lbl});
		next if ($lbl =~ m{^auto_label_\d+});				# ignore auto labels
		next if ($lbl =~ m{^~});							# ignore local labels
		next if ($lbl =~ m{[+-]\d+$});						# ignore labels with trailing arithmetic
		printf("define_label('%s',0x%02X);\n",$lbl,$LBL{$lbl});
	}
	foreach my $alias (keys(%ALIAS)) {						# export @ALIASes 
		next unless ($alias =~ m{^@});
		next unless defined($ALIAS{$alias});
		if ($ALIAS{$alias} eq 'ALIAS_IS_DEFINED') {
			printf("define_alias('%s');\n",$alias);
		} else {
			printf("define_alias('%s','%s');\n",$alias,$ALIAS{$alias});
		}
	}
}

exit(0);

#======================================================================
# Utilities
#======================================================================

sub numberp(@)
{ return  $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/; }

sub isMember($@)
{
    my($target,@list) = @_;

    foreach my $le (@list) {
        return 1 if ($le eq $target);
    }
    return 0;
}

sub set_label_type($)
{
    my($lt) = @_;

	print(STDERR "\tset_label_type($lt) [@newly_defined_label]\n") if $opt_T;
	foreach my $l (@newly_defined_label) {
		if ($opt_f) {
	  		$LBL_TYPE{$l} = 0;
	  	} else {
	    	die("attempting to re-define mode-$LBL_TYPE{$l} label <$l> to mode-$lt at input line $.\n")
				if ($LBL_TYPE{$l}>0 && $LBL_TYPE{$l}!=$lt);
  			$LBL_TYPE{$l} = $lt;
        }
    }
    undef(@newly_defined_label);
}

sub dump_JSR()
{
    foreach my $t (sort { $JSR_TRG{$b} <=> $JSR_TRG{$a} } keys(%JSR_TRG)) {
        printf("%3d: %s\n",$JSR_TRG{$t},$t);
    }
}


#----------------------------------------------------------------------
# Checksum Handling
#----------------------------------------------------------------------

sub checkSumS6()
{
	die unless defined($LIB_CHECKSUM);
	my($sum,$carry) = ($LIB_CHECKSUM,0); 							# NB: LIB_CHECKSUM must include final carry!
#	for (my($a)=0x6FFF; $a>0x6000; $a--) {
	for (my($a)=$MAX_ROM_ADDR; $a>0x6000; $a--) {
		next if ($a>=$LIB_MIN_ADDR && $a<=$LIB_MAX_ADDR);
		$sum += defined($ROM[$a]) ? $ROM[$a] : 0xFF;
		$sum++ if ($carry);
		if ($sum > 0xFF) {
			$sum &= 0xFF;
			$carry = 1;
		} else {
			$carry = 0;
		}
#		printf(STDERR "%04X: <$ROM[$a](%d)> -> %02X(%d)\n",$a,defined($ROM[$a]),$sum,$carry);
	}
    return $sum;
}


sub checkSumS711($)                                                                        # 
{
    my($addr) = @_;

    my($ble) = ($WMS_System == 7) ? 0x800 : 0x1000;
    my($bsa) = ($addr&0xF000);
    $bsa += 0x800 if (($WMS_System == 7) && ($addr&0x0FFF) >= 0x800);
    
    my($sum,$carry) = (0,0);    
    for (my($a)=$bsa+$ble-1; $a>=$bsa; $a--) {          
        $sum += $ROM[$a] + $carry;                                  
        if ($sum > 0xFF) {
            $sum &= 0xFF;
            $carry = 1;
        } else {
            $carry = 0;
        }
    }
    return $sum;
}

sub verify_checksums()
{
    if ($WMS_System == 6) {												# System 6 Game ROM (Not GREENROM)
    	if ($MIN_ROM_ADDR == 0x6000) {
			my($sum,$carry) = ($LIB_CHECKSUM,0); 
			for (my($a)=0x7FFF; $a>0x6000; $a--) {
				next if ($a>=$LIB_MIN_ADDR && $a<=$LIB_MAX_ADDR); 
				$sum += defined($ROM[$a]) ? $ROM[$a] : 0xFF;
				$sum++ if ($carry);
				if ($sum > 0xFF) {
					$sum &= 0xFF;
					$carry = 1;
				} else {
					$carry = 0;
				}
			}
			print(STDERR sprintf("Checksum Error (got: %02X expected: %02X)\n",$sum,$ROM[0x6000]))
	            unless ($sum == $ROM[0x6000]);
	    }
    } elsif ($WMS_System == 7) {										# System 7 Game ROM
        for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a+=0x800) {
            print(STDERR sprintf("Block %04X Checksum Error (got: %02X expected: 80)\n",$a,checkSumS711($a)))
                unless (checkSumS711($a) == 0x80);
        }
    } elsif ($WMS_System == 11) {										# System 11 Game ROM
        for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a+=0x1000) {
            print(STDERR sprintf("Block %04X Checksum Error (got: %02X expected: 80)\n",$a,checkSumS711($a)))
                unless (checkSumS711($a) == 0x80);
        }
    } else {
    	print(STDERR "WARNING: WPC checksums not yet implemented\n");
    }
}

#----------------------------------------------------------------------
# Labels
#----------------------------------------------------------------------

sub dump_labels()
{
	my($types) = '?MVD';												# undefined, M680x, xVM, Data
	foreach my $lbl (sort { $LBL{$a} <=> $LBL{$b} } keys(%LBL)) {
		next unless defined($LBL{$lbl});
		my($c) = substr($types,$LBL_TYPE{$lbl},1);
		if ($WMS_System =~ m{^WPC}) {
			printf("%40s = %02X:%04X [$c]\n",$lbl,$LBP{$lbl},$LBL{$lbl});
		} else {
			printf("%40s = \$%04X [$c]\n",$lbl,$LBL{$lbl});
		}
    }
}

sub check_duplicate_label_types()
{
	my($lLbl,$lAddr,$lType);
    foreach my $lbl (sort { $LBL{$a} <=> $LBL{$b} } keys(%LBL)) {
        next unless defined($LBL{$lbl});												# ???
        next unless ($LBL_TYPE{$lbl} > 0);												# ignore (auto-)labels with type 0
		die(sprintf("duplicate label pair $lLbl,$lbl (\$%04X) has inconsistent types ($lType,$LBL_TYPE{$lbl})\n",$lAddr))
			if defined($lAddr) &&
			   ($LBL{$lbl} == $lAddr && $LBP{$lbl} == $LBP{$lLbl}) &&
			   ($lType != $LBL_TYPE{$lbl});
       	$lLbl = $lbl;
       	$lAddr = $LBL{$lbl};
       	$lType = $LBL_TYPE{$lbl};
    }
}


{ my($last_label_addr) = -1; 															# static scope used for .
	sub define_label($@)
	{
		my($lbl,$addr,$allow_relabel) = @_;
	
		$addr = $ADDR unless defined($addr);
		die("ERROR: undefined address (.ORG missing) when defining label <$lbl> at input line $.\n")
			unless defined($addr);

		$addr = code_addr($addr)														# convert WPC ROM to code addr
			if defined($RPG);
	
##		printf(STDERR "define_label($lbl,%04X,$allow_relabel) [%02X:%04X]\n",$addr,$RPG,$ADDR);

		my($lofs) = ($addr =~ m{^\.\+(\d+)$});											# handle .+1 '.' dot
		$addr = $last_label_addr + $lofs if defined($lofs);
		    
		die("ERROR: Unmatched END on line $.\n") unless (length($lbl) > 0);
	
		unless ($opt_1) {																# don't generate label errors during 1st pass (optimization)
			if (defined($LBL{$lbl}) &&													# check for label redefinition attempts
				($LBL{$lbl} ne $addr) && ($LBP{$lbl} == $RPG) &&						# NB: LBP & RPG are undef except in WPC
				($lbl ne 'ANALYSIS_GAP') &&
				($lbl ne 'FREE_SPACE')) {
##					die(sprintf("$lbl: %04X (addr = %04X) pg %02X (RPG = %02X)",$LBL{$lbl},$addr,$LBP{$lbl},$RPG));
					my($msg) = sprintf("label <$lbl> = \$%04X [$addr] already defined with different value (\$%04X [$LBL{$lbl}]) at input line $.\n",$addr,$LBL{$lbl});
					if ($opt_w) { print(STDERR "WARNING: $msg"); }
					else		{ die("ERROR: $msg"); }
			}
	    
			printf(STDERR "WARNING: re-defining label $LBL[$addr] at address \$%04X to $lbl\n",$addr)
				if !$allow_relabel && $addr!=$last_label_addr
								   && !$opt_w && defined($LBL[$addr])
								   && ($LBL[$addr] ne $lbl)
								   && !($lbl =~ m/^auto_label_\d*$/ || $LBL[$addr] =~ m/^auto_label_\d*$/);
			$last_label_addr = $addr;
		}
	
		$LBL{$lbl} = $addr;
		$LBP{$lbl} = $RPG;																# undef except in WPC
		$LBL[$addr] = $lbl;
	}
} # scope of $last_lbl_addr


sub labelValue($$)
{
    my($caller_id,$lbl) = @_;

    $lbl = hex($1) if ($lbl =~ m{^\$([0-9A-Fa-f]+)$});									# return numeric values (not labels)
    $lbl = eval('0b' . $1) if ($lbl =~ m{^%([01]+)$});
    return $lbl if numberp($lbl);
    
	if ($opt_f) {																		# force mode, intended to compile (some) source files with D711 warnings
		if (numberp($LBL{$lbl}) || $lbl =~ m{#[0-9A-Fa-f]{2}$}) {
			return $LBL{$lbl};
		} elsif ($lbl =~ m{_([0-9A-Fa-f]{4})$}) {										# allow undefined labels with addresses but without label base (e.g. _873C)
			return hex($1);																#    (I am not sure why/when this is needed)
		} else {
		    die("Undefined label <$lbl> (cid $caller_id)\n");
		}
	} else {																			# not force mode
	    die("Undefined label <$lbl> (cid $caller_id)\n")
			unless numberp($LBL{$lbl}) || $lbl =~ m{#[0-9A-Fa-f]{2}$};
		die("Label <$lbl> references different ROM page (%02X instead of %02X)\n")
			unless ($LBP{$lbl} == $RPG);
	    return $LBL{$lbl};
	}
}


{ my($auto_label_no) = 1;
    sub auto_label($)
    {
    	my($lt) = @_;
        $AUTO_LABEL_DEF[$auto_label_no] = $.;
        my($lbl) = sprintf('auto_label_%d',$auto_label_no++);
        $LBL_TYPE{$lbl} = $lt;
        return $lbl;
    }
}


sub eval_label($@)                                                                  	# Label Arithmetic (addr argument is used whith -x)
{                                                                                   
##	print(STDERR "eval_label(@_)\n");
    my($lexpr,$addr,$suppress_errors) = @_;

	my($lbl,$arg1,$arg2) = ($lexpr =~ m{^([^&]+)&\$([0-9A-Fa-f]+)([-+]\d+)$});		  	# hex bit mask with offset (e.g. (table_label&$FF)+2)
	if (defined($lbl) && defined($arg1) && defined($arg2)) {
		return undef if (!defined($LBL{$lbl}) && $suppress_errors);
		printf("\$D711::Address = 0x%04X; &D711::def_lbl_arith('$lexpr');\n",$addr)
			if (numberp($addr) && !numberp($lbl) && $opt_x);
		my($lv) = labelValue(3,$lbl);
		return ($lv & hex($arg1))+$arg2 if numberp($lv);
	}

	my($lbl,$arg) = ($lexpr =~ m{^([^+-]+)([-+]\d+)$}); 								# constant offsets (e.g. LBL+3)
	if (defined($lbl) && defined($arg)) {
		return undef if (!defined($LBL{$lbl}) && $suppress_errors);
		printf("\$D711::Address = 0x%04X; &D711::def_lbl_arith('$lexpr');\n",$addr)
			if (numberp($addr) && !numberp($lbl) && $opt_x);
		my($lv) = labelValue(1,$lbl);
		return $lv + $arg if numberp($lv);
	}
    
	($lbl,$arg) = ($lexpr =~ m{^([^\|]+)\|\$([0-9A-Fa-f]+)$});							# hex bit mask (e.g. LG_all|$40)
	if (defined($lbl) && defined($arg)) {
		return undef if (!defined($LBL{$lbl}) && $suppress_errors);
		printf("\$D711::Address = 0x%04X; &D711::def_lbl_arith('$lexpr');\n",$addr)
			if (numberp($addr) && !numberp($lbl) && $opt_x);
		my($lv) = labelValue(2,$lbl);
		return $lv | hex($arg) if numberp($lv);
	}
    
	($lbl,$arg) = ($lexpr =~ m{^([^&]+)&\$([0-9A-Fa-f]+)$});							# hex bit mask (e.g. table_label&$FF)
	if (defined($lbl) && defined($arg)) {
		return undef if (!defined($LBL{$lbl}) && $suppress_errors);
		printf("\$D711::Address = 0x%04X; &D711::def_lbl_arith('$lexpr');\n",$addr)
			if (numberp($addr) && !numberp($lbl) && $opt_x);
		my($lv) = labelValue(3,$lbl);
		return $lv & hex($arg) if numberp($lv);
	}

	($lbl,$arg) = ($lexpr =~ m{^([^>]+)>>(\d+)$});										# decimal shift bits (e.g. table_label>>8)
	if (defined($lbl) && defined($arg)) {
		return undef if (!defined($LBL{$lbl}) && $suppress_errors);
		printf("\$D711::Address = 0x%04X; &D711::def_lbl_arith('$lexpr');\n",$addr)
			if (numberp($addr) && !numberp($lbl) && $opt_x);
		my($lv) = labelValue(4,$lbl);
		return $lv >> $arg if numberp($lv);
	}

	($lbl,$arg) = ($lexpr =~ m{^([^>]+)<<(\d+)$});										# decimal shift bits (e.g. table_label<<8)
	if (defined($lbl) && defined($arg)) {
		return undef if (!defined($LBL{$lbl}) && $suppress_errors);
		printf("\$D711::Address = 0x%04X; &D711::def_lbl_arith('$lexpr');\n",$addr)
			if (numberp($addr) && !numberp($lbl) && $opt_x);
		my($lv) = labelValue(4,$lbl);
		return $lv << $arg if numberp($lv);
	}

	return defined($LBL{$lexpr}) ? labelValue(12,$lexpr) : undef;						# assume simple number (not an expression); undef returned on auto lbls
}


#----------------------------------------------------------------------
# Resolve Labels and write OPTIMIZER instructions
#   - optimizable instructions done here to keep the list
#     sorted 
#----------------------------------------------------------------------

sub resolve_labels($)
{
    for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {                               # first, substitute all label values
        next unless defined($ROM[$a]);

        if ($_[0]) {                                                                    # debug dump
            if (numberp($ROM[$a])) {
                printf(STDERR "%04X: %02X\n",$a,$ROM[$a]);
            } else {
                printf(STDERR "%04X: $ROM[$a]\n",$a);
            }
        }

		our($bo); die if defined($bo); 													# UNUSED VARIABLE
		our($offset); die if defined($offset); 											# UNUSED VARIABLE
        if ($opt_1 && !$NO_OPT[$a-$bo]                                                  # Optimizer: Pass 1: Write instructions
                   && ($a-$bo)         >= $opt_F_from && ($a-$bo)         <= $opt_F_to
                   && ($offset+$a+$bo) >= $opt_F_from && ($offset+$a+$bo) <= $opt_F_to) {
            if ((($opt_V >= 1) &&
                    (($OP[$a] eq '_WVM_MODE') ||
                     ($OP[$a] eq '_SETFLAG[A]') ||
                     ($OP[$a] eq '_SETFLAG[B]') ||
                     ($OP[$a] eq '_LAMPON[A]') ||
                     ($OP[$a] eq '_CLEARFLAG[A]') ||
                     ($OP[$a] eq '_CLEARFLAG[B]') ||
                     ($OP[$a] eq '_LAMPOFF[A]') ||
                     ($OP[$a] eq '_EXIT_THREAD'))) ||
                (($opt_V >= 4) &&                   
                    (($OP[$a] eq '_PSHX') ||
                     ($OP[$a] eq '_PULX') ||
                     ($OP[$a] eq '_AAX') ||
                     ($OP[$a] eq '_ABX'))) ||
                (($opt_V >= 5) &&                   
                    ($OP[$a] eq '_SLEEP'))) {
                        my($opt) = "$LINE[$a] $SRC[$a]\n";
                        if (! -t 1) { print($opt); }
                        else        { print(OPTF $opt); }
            }
        }

        if (numberp($ROM[$a])) {                                                        # already a number (opcodes, data & immediate args)
            if (defined($opt_r)) {                                                      # check against ROM image if one is provided
                if ($ROM[$a] <= 0xFF && 
                    ($ROM[$a]&0xFF) != $vROMimage[$a-$MIN_ROM_ADDR+1024*$opt_g] && 
                    ($ROM[$a]&0xFF) != 0x80 && 
                    ($ROM[$a]&0xFF) != 0x90) {
                        print(STDERR sprintf("ROM mismatch at %04X: found %02X instead of %02X (... %02X %02X %02X)\n",
                                    $a,$ROM[$a],$vROMimage[$a-$MIN_ROM_ADDR+1024*$opt_g],@ROM[$a+1..$a+3]));
                }
            }
            next;
        }

        next if ($ROM[$a] =~ m{^\@});                                                   # leave resolution of @COMPILER_VARIABLES for later
        next if ($ROM[$a] eq '16-BIT VALUE');

        $ROM[$a] = hex($1) if ($ROM[$a] =~ m{^\$([0-9A-Fa-f]+)$});                      # turn $hex and %binary numbers into decimals
        $ROM[$a] = eval('0b' . $1) if ($ROM[$a] =~ m{^%([01]+)$});
        die(sprintf("<%04X> $@\n",$a)) unless defined($ROM[$a]);
        next if numberp($ROM[$a]);                                                      # we are done, if we have a number

        if ($ROM[$a] =~ m/^Adj#([0-9A-Fa-f]{2})/ ||                                     # substitute all system identifiers
            $ROM[$a] =~ m/^Sol#([0-9A-Fa-f]{2})/ ||
            $ROM[$a] =~ m/^Lamp#([0-9A-Fa-f]{2})/ ||
            $ROM[$a] =~ m/^Bitgroup#([0-9A-Fa-f]{2})/ ||
            $ROM[$a] =~ m/^Switch#([0-9A-Fa-f]{2})/ ||
            $ROM[$a] =~ m/^Sound#([0-9A-Fa-f]{2})/ ||
            $ROM[$a] =~ m/^Thread#([0-9A-Fa-f]{2})/) {
                $ROM[$a] = hex($1) . $';												# decimal, and with trailing arithmetic (e.g. Lamp#3C|$40)
                next if numberp($ROM[$a]);                                              # we are done, if we have a number
        }
        if ($ROM[$a] =~ m/^Flag#([0-9A-Fa-f]{2})/) {	                                # flags are lamps with bit 6 set (all systems?)
            $ROM[$a] = hex($1) + 64 . $';
			next if numberp($ROM[$a]);                                                  # we are done, if we have a number
        }
        
        my($ms) = '^\\' . $EIGHT_BIT_LABEL_PREFIX;                                      # 8-bit relative address
        if ($ROM[$a] =~ m{$ms}) {                                                   
            my($offset) = labelValue(5,$') - $a - 1;
            my($src_addr) = $a;
            while (!defined($LINE[$src_addr])) { $src_addr--; }
            die(sprintf("8-bit branch offset $offset <$ROM[$a]> out of range at source line %d\n",$LINE[$src_addr]))
                unless ($offset >= -128 && $offset <= 127);
            $ROM[$a] = ord(pack('c',$offset));
            next;
        }
        my($ms) = '^\\' . $TWELVE_BIT_LABEL_PREFIX;                                     # 12-bit relative address
        if ($ROM[$a] =~ m{$ms}) {               
            my($offset) = labelValue(6,$') - $a - 1;
            my($src_addr) = $a;
            while (!defined($LINE[$src_addr])) { $src_addr--; }
            die(sprintf("12-bit branch offset <$ROM[$a]> out of range at source line %d\n",$LINE[$src_addr]))
                unless ($offset >= -2048 && $offset <= 2047);
            $ROM[$a-1] += ($offset>>8) & 0x0F;                                          # set high nibble of previous byte
            $ROM[$a]    =  $offset     & 0xFF;   
            next;
        }

        my($ms) = '\\' . $OPTIMIZABLE_LABEL_PREFIX . '\\' . $EIGHT_BIT_LABEL_PREFIX;    # absolute address potentially optimizable to 8-bit relative address
        if ($ROM[$a] =~ m{$ms}) {                                                       
            my($bo) = $`;                                                               # byte offset (1 for unconditional jumps)
            my($lbl) = $';

            my($offset) = labelValue(7,$lbl) - $a - $bo;
            if ($offset >= -128 && $offset <= 127) {
                printf(STDERR "\$%04X %5d: WARNING: optimizable statement %s\n",$a-$bo,$LINE[$a-$bo],$SRC[$a-$bo])
                    if ($opt_v);
                if ($opt_1 && !$NO_OPT[$a-$bo]
                           && ($a-$bo)         >= $opt_F_from && ($a-$bo)         <= $opt_F_to
                           && ($offset+$a+$bo) >= $opt_F_from && ($offset+$a+$bo) <= $opt_F_to) {
                    my($opt) = "$LINE[$a-$bo] $SRC[$a-$bo]\n";
                    if (! -t 1) { print($opt); }
                    else        { print(OPTF $opt); }									# Optimizer pass 1
                }
            }
            $ROM[$a] = labelValue(8,$lbl);
            next;
        }

        my($ms) = '^\\' . $OPTIMIZABLE_LABEL_PREFIX . '\\' . $TWELVE_BIT_LABEL_PREFIX;
        if ($ROM[$a] =~ m{$ms}) {                                                       # potentially optimizable to 12-bit address
            my($lbl) = $';
            my($offset) = labelValue(9,$lbl) - $a - 1;
            if ($offset >= -2048 && $offset <= 2047) {
                printf(STDERR "\$%04X %5d: WARNING: optimizable statement $SRC[$a-1]\n",$a-1,$LINE[$a-1])
                    if ($opt_v);
                if ($opt_1 && !$NO_OPT[$a-$bo]
                           && ($a-1)            >= $opt_F_from && ($a-1)         <= $opt_F_to
                           && ($offset+$a+1)    >= $opt_F_from && ($offset+$a+1) <= $opt_F_to) {
                    my($opt) = "$LINE[$a-1] $SRC[$a-1]\n";
                    if (! -t 1) { print($opt); }
                    else        { print(OPTF $opt); }									# Optimizer pass 1
                }
            }
            $ROM[$a] = labelValue(10,$lbl);
            next;
        }

        if (numberp($LBL{$ROM[$a]})) {                                                  # if entire remaining string exists in list of labels, substitute its value
#           print(STDERR "$ROM[$a] -> ");       
            $ROM[$a] = labelValue(11,$ROM[$a]);                                         # [ this allows re-defining apparent label arithmetic 
#           print(STDERR "$ROM[$a]\n");     
            next;                                                                       # (e.g. .LBL RAM_var $FF; .LBL RAM_var+1 $C000)]
        }

        #----------------------------------------------------------------------
        # Value Encoders / Data Types
        #   - should allow for simple arithmetic to be applied afterwards
        #     where this makes sense
        #   - Examples:
        #       LDAA    #Sol_GI_playfield:off{SolCmd}
        #       LDAB    #100K{ScoreByte}
        #       LDAA    #continue_WVM_at_[X]{MSB}
        #       LDAB    =SolBuf{LSB}+2
        #----------------------------------------------------------------------

		my($str,$encoder) = ($ROM[$a] =~ m/^'?(.+)\{([^}\s]+)\}'?/);					# "encoder" (e.g. LDAA #Sol_GI_playfield:off{SolCmd} )
		if (defined($encoder)) {														# 	initial '? allows for strings with spaces e.g. in 'ls -l{ShellCmd}'
			my($remainder) = $';
##			print(STDERR "encoder($str,$encoder) [$ROM[$a]]\n");
			$encoder .= ".s$WMS_System"
				if (-f "$PATH/C711.$encoder.s$WMS_System");
			require "$PATH/C711.$encoder";
			$encoder =~ s/\./_/g;														# replace . by _ in function name
			my($ofs);																	# find statement base address
			our($addr); die if defined($addr);											# UNUSED VARIABLE
			for ($ofs=0; !defined($LINE[$a-$ofs]); $ofs++) {}
			my($expr) = sprintf("$encoder('%s',%d);",$str,$LINE[$a-$ofs]);
#			print(STDERR "eval($expr)\n");
##          $ROM[$a] = sprintf("%d$remainder",eval($expr));
			my($ev) = eval($expr);
            die($@) if $@;
			$ROM[$a] = $ev . $remainder;
#           printf(STDERR "ROM[%04X] = %02X\n",$a,$ROM[$a]);            
		}

        #----------------------------------------------------------------------
        # Simple Label Arithmetic
        #----------------------------------------------------------------------

        my($lval) = eval_label($ROM[$a],$a);                                            # label with simple arithmetic
        if (defined($lval)) {
            $ROM[$a] = $lval;
            next;
        }

        $ROM[$a] = labelValue(666,$ROM[$a]);                                            # this will always trigger an error unless ROM[a] is numeric
    }
    
    for (my($a)=$FIRST_ADDR; $a<=$MAX_ROM_ADDR; $a++) {                                 # finally, split signed words & check ranges
        next unless defined($ROM[$a]);
        next if ($ROM[$a] =~ m{^\@});
        my($opaddr) = $a;                                                               # find source line of operation
        while (!defined($LINE[$opaddr])) { $opaddr--; }
        die(sprintf("Error: Invalid intermediate value $ROM[$a] at address \$%04X (input line $LINE[$opaddr])\n",$a)) 
            unless ($opt_1 || numberp($ROM[$a]));
        die("Error: Invalid intermediate value $ROM[$a] at address $a (input line $LINE[$opaddr])\n")
            unless ($ROM[$a]>=0 || $ROM[$a]<=0xFFFF);
        die(sprintf("Error: byte value $ROM[$a] out of range at address \$%04X (input line $LINE[$opaddr])\n",$a))
            if (!$opt_1 && $ROM[$a] > 0xFF && defined($ROM[$a+1]) && $ROM[$a+1] ne '16-BIT VALUE');                                         
#       print(STDERR sprintf("Attempting to overwrite already defined ROM [%02X %02X <%02X($ROM[$a+1])> %02X] at address \$%04X with high byte of word value \$%04X\n",
#           $ROM[$a-1],$ROM[$a],$ROM[$a+1],$ROM[$a+2],$a+1,$ROM[$a])) 
#               if (!defined($opt_1) && $ROM[$a] > 0xFF && defined($ROM[$a+1]) && $ROM[$a+1] ne '16-BIT VALUE');
        if ($ROM[$a+1] eq '16-BIT VALUE') {                                             # signed byte value
#           printf(STDERR "splitting 16-bit value $ROM[$a] at address %04X -> ",$a);
            $ROM[$a+1] =  $ROM[$a]     & 0xFF;
            $ROM[$a]   = ($ROM[$a]>>8) & 0xFF;
#            printf(STDERR "\$%02X \$%02X\n",$ROM[$a],$ROM[$a+1]);
        } else {                                                                        # signed word value
            $ROM[$a] &= 0xFF;                                                           
        }
        die("Invalid final value $ROM[$a] at address $a\n")
            unless ($ROM[$a]>=0 || $ROM[$a]<=0xFF);
    }
    die("Invalid final value $ROM[$#ROM] at address $#ROM\n")
        unless ($ROM[$#ROM]>=0 || $ROM[$#ROM]<=0xFF);
}

#----------------------------------------------------------------------
# Calculate Checksum Bytes
#   - apparently (BadCats), when checksum 0 is valid, so is FF 
#----------------------------------------------------------------------

sub calc_checksums()                                                                    # replace @CHECKSUM_BYTE with checksum value
{
    for (my($a)=$FIRST_ADDR; $a<=$MAX_ROM_ADDR; $a++) {  
        next unless ($ROM[$a] eq '@CHECKSUM_BYTE');

        printf("\$D711::Address = 0x%04X;\n&D711::def_checksum_byte();\n",$a)
            if ($opt_x);

		if ($WMS_System == 6) {
	    	$ROM[$a] = checkSumS6();
	        printf(STDERR "<%04X> \@CHECKSUM_BYTE = \$%02X\n",$a,$ROM[$a])
            if defined($opt_c);
	    	
			return;
        }
            
        my($ble) = ($WMS_System == 7) ? 0x800 : 0x1000;
        my($bsa) = ($a&0xF000);
        $bsa += 0x800 if (($WMS_System == 7) && ($a&0x0FFF) >= 0x800);
        my($sum,$carry) = (0,0);
        for (my($ba)=$bsa+$ble-1; $ba>=$bsa; $ba--) {
            next if ($ba == $a);
            $sum += $ROM[$ba] + $carry;
            if ($sum > 0xFF) {
                $sum &= 0xFF;
                $carry = 1;
            } else {
                $carry = 0;
            }
        }
        $ROM[$a] = ($sum > 0x80) ? 0x180-$sum : 0x80-$sum;                          # this can be off by one depending on ...
        $ROM[$a]-- if (checkSumS711($a) == 0x81);                                      # whether checksum byte triggers carry flag
        $ROM[$a] = 0xFF if ($ROM[$a] == 0);                                         # both are equally valid; BadCats uses 0xFF consistently
        die(sprintf("No valid checksum byte possible at %04X (%02X)\n",$a,checkSumS711($a)))
            unless checkSumS711($a)== 0x80;
        printf(STDERR "<%04X> \@CHECKSUM_BYTE block %02Xxx = \$%02X\n",
            $a,($bsa&0xFF00)>>8,$ROM[$a])
            if defined($opt_c);
        next;
    }
}

#----------------------------------------------------------------------
# Lexical Substitutions (Game-Specific Identifiers; ALIAS DEFINE)
#   - match beginning of operand after optional # or [ to allow
#     Sol#17:on, Sound#10:3x, LG_ALL|$40, #LG_all, [Reg-I]
#   - multi-word defines:
#       - 'string aliases' are recognized by the leading '
#       - other multi-word aliases are commands that need
#         to be spliced into @_
#----------------------------------------------------------------------

sub define_alias($@)																# used in API files
{
	my($name,$value) = @_;
	die("ERROR: cannot define alias <$name>\n")
		unless defined($name);
	$ALIAS{$name} = defined($value) ? $value : 'ALIAS_IS_DEFINED';
}

sub aliasValue($)
{
    my($alias) = @_;
    my($val) = $ALIAS{$alias};

    die("Undefined alias <$alias>\n")
        unless defined($val);
    $ALIAS_REFD{$alias}++;
    $val = hex($') if ($val =~ m/^\$/);
    die("Invalid alias <$alias> value <$ALIAS{$alias}>\n")
        unless ($val >= 0 && $val <= 255);
    return $val;
}

sub match_pragma($$$)
{
	my($s,$m,$o) = @_;

	return undef unless ($s =~ m{^$m});													# mandatory part does not match

	my($l) = (length($s) > (length($m)+length($o)))
		   ? length($m) + length($o)
		   : length($s);
	return 0 unless substr($s,0,$l) eq substr($m.$o,0,$l);							 	# no match unless optional part matches
	return 1;
}


sub expand_aliases()                                        
{														    
	for (my($i)=0; $i<@_; $i++) {
		next if ($i == 1 && match_pragma($_[0],'.DEF','INE'));							# forgeting this caused a lot of confusion when I accidentally redefined the number 47 :)
		next if ($i == 1 && match_pragma($_[0],'.UNDEF','INE'));
		next if ($i == 1 && match_pragma($_[0],'.DECL','ARE'));
		next if match_pragma($_[0],'.IFDEF','');
		next if match_pragma($_[0],'.IFNDEF','');
		next if match_pragma($_[0],'.IFUNDEF','');
		next if match_pragma($_[0],'.ASSUME_DEFINED','');
		next if match_pragma($_[0],'.ASSUME_UNDEFINED','');
		while (1) {
			my($pre,$alias,$post);
			if ($_[$i] =~ m/{.+}/) {													# encoder
				my($p1,$p2);
				($p1,$p2,$alias,$post) = ($_[$i] =~ m{^([\#\[])?([A-Za-z0-9_]+\()?([A-Za-z\?0-9_\.\#\+-]+)(.*)$});
				$pre = $p1 . $p2;
#				print(STDERR "$_[$i] $p1/$p2/$alias/$post [$ALIAS{$alias}]\n");
            } else {	
				($pre,$alias,$post) = ($_[$i] =~ m{^([\#\[])?([A-Za-z\?0-9_\.\#\+-]+)(.*)$});
			}
#			print(STDERR "$_[$i] $pre/$alias/$post [$ALIAS{$alias}]\n");

			last unless defined($ALIAS{$alias});
			$ALIAS_REFD{$alias}++;
			my(@sali) = split(/\s+/,$ALIAS{$alias});
			if (@sali==1 || $ALIAS{$alias}=~m{^'}) {									# single word or multi-word string
				$_[$i] = $pre . $ALIAS{$alias} . $post;
			} else {																	# multi-word command
				splice(@_,$i,1,@sali);
			}
		}
#		print(STDERR "$_[$i]\n");
	}
}

#----------------------------------------------------------------------
# Expand Repeat Bytes 
#----------------------------------------------------------------------

sub expand_repeatBytes()
{
    for (my($i)=0; $i<@_; $i++) {
        next unless ($_[$i] =~ m{\[(\d+)x\]$});
        $_[$i] = $`;
        for(my($j)=$1; $j>1; $j--,$i++) {
        	splice(@_,$i+1,0,$_[$i]);
        }
    }
}

#----------------------------------------------------------------------
# Expand ! to JSR
#----------------------------------------------------------------------

sub expand_bang()
{
	return unless ($_[0] =~ m{^!});
	splice(@_,1,0,$');
	$_[0] = 'JSR';
}

#----------------------------------------------------------------------
# Convert All Numbers to Decimal
#----------------------------------------------------------------------

sub decimalize()
{
    for (my($i)=0; $i<@_; $i++) {
        next unless ($_[$i] =~ m{^\$([0-9a-fA-F]+)$});
        $_[$i] = hex($1);
    }
}

#----------------------------------------------------------------------
# Verify ROM Image (-t)rust_but_verify)
#----------------------------------------------------------------------

sub load_vROM(@)
{
    my(@files) = @_;

    while (@files) {                                            # load ROM files
        my($fn) = shift(@files);
        open(F,$fn) || die("$fn: $!\n");
        my($ROMimage);
        my($nRead) = read(F,$ROMimage,0xFFFF);
        die("$fn: no data\n") unless ($nRead > 0);
        push(@vROMimage,unpack("C*",$ROMimage));
    }
}

sub verify_vROM(@)
{
	my($AFMT) = ($WMS_System =~ m{^WPC}) ? '%05X' : '%04X';
    for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {
        my($val) = defined($ROM[$a]) ? $ROM[$a] : 0xFF;
        next if ($val == $vROMimage[$a-$MIN_ROM_ADDR+1024*$opt_g]);
        printf(STDERR "ROM mismatch at $AFMT: %02X instead of %02X [$AFMT]\n",
                      $a,$val,$vROMimage[$a-$MIN_ROM_ADDR+1024*$opt_g],$a-$MIN_ROM_ADDR+1024*$opt_g);
    }
}

#----------------------------------------------------------------------
# Manage Free Space
#----------------------------------------------------------------------

sub find_free_space()
{
    my($free) = my($totalfree) = 0;
    my($a);
    for ($a=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {
        if (defined($ROM[$a])) {
            if ($free > 0) {
                printf(STDERR "<%04X> %d bytes free\n",$a-$free,$free)
                    if $opt_m;
                $free = 0;
            }
            next;
        }
        $free++; $totalfree++;
    }
    if ($free > 0) {
        printf(STDERR "<%04X> %d bytes free\n",$a-$free,$free)
            if $opt_m;
    }
    printf(STDERR "Total Free Space = %d bytes\n",$totalfree)
        unless $opt_1 || $opt_L;
    return $totalfree;
}

#----------------------------------------------------------------------
# Produce Output
#	-L			code listing
#	otherwise	create one or more ROM image files
#----------------------------------------------------------------------

sub produce_output()
{
    if ($opt_L) {                                                                               # code listing
        my($src_line,$src_addr,$src_lbl,$a);
        for ($a=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {
            next unless defined($SRC[$a]);                                                      # skip to next opcode
            if (defined($src_addr)) {                                                           # if there was an opcode before (usually)
                printf("<%04X> ",$src_addr);                                                    # print ROM address
                my($bytes_done) = 0;
                for (my($i)=0; $i<15; $i++) {                                                   # print (max 15) operation bytes
                    $bytes_done |= ($i>0 && defined($SRC[$src_addr+$i]));
                    if ($bytes_done) { printf("   "); }
                    else             { printf("%02X ",$ROM[$src_addr+$i]); }
                }
                $src_line =~ s/(\w+)\s+/\1 /g;
                if (length($src_lbl) > 0) {
                    $src_line =~ s/^\s+//;
                    $src_line = $' if ($src_line =~ m{^\^});                                    # allow for labels starting with ^
                    $src_line =~ s{^$src_lbl:\s*}{}; 
                    print("$src_lbl: $src_line\n");
                } else {
                    print("$src_line\n");                                                               
                }
            }
            if ($a<=$MAX_ROM_ADDR) {
                $src_line = $SRC[$a]; $src_addr = $a; $src_lbl = $LBL[$a];
            }
        } # for
        printf("<%04X> ",$src_addr);                                                            # print ROM address of last statement
        for (my($i)=0; $i<15; $i++) {                                                           # print (max 15) operation bytes
            if ($src_addr+$i>$MAX_ROM_ADDR) { printf("   "); }
            else                            { printf("%02X ",$ROM[$src_addr+$i]); }
        }
        $src_line =~ s/(\w+)\s+/\1 /g;
        if (length($src_lbl) > 0) {
            $src_line =~ s/^\s+//;
            $src_line = $' if ($src_line =~ m{^\^});                                            # allow for labels starting with ^
            $src_line =~ s/^$src_lbl:\s*//;
            print("$src_lbl: $src_line\n");
        } else {
            print("$src_line\n");                                                               
        }
        exit(0);
    } # if $opt_L

	if ($WMS_System == 6) {																		# System 6
		if (defined($opt_o)) {																	# single linked output file
			open(F,">$opt_o") || die("$opt_o: $!\n");
			if (defined($opt_g)) {																# add pre gap
				die("$0: invalid -g $opt_g\n") unless ($opt_g > 0);
				for (my($k)=0; $k<$opt_g; $k++) {
					my($FF) = pack('c',0xFF);
					for (my($b)=0; $b<1024; $b++) { print(F $FF); }
				}
	        } 
		} else {																				# default system 6 file
			print(STDERR "WARNING: linker-options ignored\n")
				if defined($opt_g) || defined($opt_l);
			die(sprintf("${basename}${opt_s}_U14.bin: invalid ROM address range (\$%04X-\$%04X) for System 6\n",
							$MIN_ROM_ADDR,$MAX_ROM_ADDR))
				unless ($MIN_ROM_ADDR == 0x6000 && $MAX_ROM_ADDR == 0x67FF);
	        open(F,">${basename}${opt_s}_U14.bin") || die("${basename}${opt_s}_U14.bin: $!\n"); # 6000-7FFF
		}
			
        for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {									# output code
            print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
        }
        close(F);
    } elsif ($WMS_System == 7) {                                                                  # system 7
        open(F,">${basename}${opt_s}_U26.bin") || die("${basename}${opt_s}_U26.bin: $!\n");     # D800-DFFF
        for (my($a)=$MIN_ROM_ADDR; $a<$MIN_ROM_ADDR+0x800; $a++) {
            print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
        }
        close(F);
        open(F,">${basename}${opt_s}_U14.bin") || die("${basename}${opt_s}_U14.bin: $!\n");     # E000-E7FF
        for (my($a)=$MIN_ROM_ADDR+0x800; $a<=$MAX_ROM_ADDR; $a++) {
            print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
        }
        close(F);
    } elsif ($WMS_System == 11) {                                                               # system 11
        open(F,">${basename}${opt_s}_U26.bin") || die("${basename}${opt_s}_U26.bin: $!\n");     # 4000-7FFF
        for (my($a)=$MIN_ROM_ADDR; $a<$MIN_ROM_ADDR+0x4000; $a++) {
            print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
        }
        if ($opt_e) {                                                                           # 32K ROM chips (e.g. Bad Cats)
            for (my($a)=$MIN_ROM_ADDR; $a<$MIN_ROM_ADDR+0x4000; $a++) {                         
                print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
            }
        }
        close(F);
        open(F,">${basename}${opt_s}_U27.bin") || die("${basename}${opt_s}_U27.bin: $!\n");     # 8000-FFFF
        for (my($a)=$MIN_ROM_ADDR+0x4000; $a<=$MAX_ROM_ADDR; $a++) {
            print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
        }
        close(F);
    } elsif ($WMS_System =~ m{^WPC}) {															# WPC
		if (defined($opt_o)) {																	# single linked output file
			open(F,">$opt_o") || die("$opt_o: $!\n");
			if (defined($opt_g)) {																# add pre gap
				die("$0: invalid -g $opt_g\n") unless ($opt_g > 0);
				for (my($k)=0; $k<$opt_g; $k++) {
					my($FF) = pack('c',0xFF);
					for (my($b)=0; $b<1024; $b++) { print(F $FF); }
				}
	        } 
		} else {																				# default system 6 file
			print(STDERR "WARNING: linker-options ignored\n")
				if defined($opt_g) || defined($opt_l);
			die(sprintf("${basename}${opt_s}_U6.bin: invalid ROM address range (\$%05X-\$%05X) for WPC\n",
							$MIN_ROM_ADDR,$MAX_ROM_ADDR))
				unless ($MIN_ROM_ADDR == 0x00000 && $MAX_ROM_ADDR == 0xFFFFF);
	        open(F,">${basename}${opt_s}_U6.bin") || die("${basename}${opt_s}_U6.bin: $!\n");	
		}
			
        for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {									# output code
            print(F pack('c',defined($ROM[$a])?$ROM[$a]:0xFF));
        }
        close(F);
    } else {
    	die("Unsupported WMS System <$WMS_System>\n");
    }
}

#----------------------------------------------------------------------
# Assembler .PRAGMAs
#----------------------------------------------------------------------

sub setROM($$)
{
    my($addr,$val) = @_;

    if (defined($ROM[$addr])) {
        if ($opt_v || $opt_t) {
            printf(STDERR "WARNING: ROM overflow at %04X at input line $LINE[$addr] ($ROM[$addr])\n",$addr);
        } else {
            die(sprintf("ROM overflow at %04X at input line $LINE[$addr] ($ROM[$addr])\n",$addr))
                unless $opt_1;
        }
    }
    $ROM[$addr] = $val; 
}

sub compile_pragma()
{
    my($OP,@OP_ARG) = @_;
    return undef unless ($OP =~ m{^\.});

	#------------------------------
	# Mode Checking
	#------------------------------

    if (($MODE==0 || $MODE==1) && ($OP eq '.WVM_MODE' || $OP eq '.IVM_MODE')) {    
        die("Syntax: .WVM_MODE|.IVM_MODE (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        $MODE = 2;
        return 1;
    }

    if (($MODE==0 || $MODE==2) && ($OP eq '.M6800_MODE' || $OP eq '.M6809_MODE')) {    
        die("Syntax: .M6800_MODE|.M680X_MODE (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        $MODE = 1;
        return 1;
    }

    if ($OP eq '.DATA_MODE') {    
        die("Syntax: .DATA_MODE (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        $MODE = 0;																			# don't set to mode 3, because after any data mode byte, there can be any mode
        return 1;
    }

    #------------------------------
    # IVM: Enabling and Disabling
    #------------------------------

    if ($OP eq '.DISABLE_IVM') {    
        die("Syntax: .DISABLE_IVM (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        die("attempted nesting of .DISABLE_IVM at input line $.\n")
            if $IVM_DISABLED;
        $IVM_DISABLED = 1;
        return 1;
    }

    if ($OP eq '.ENABLE_IVM') { 
        die("Syntax: .ENABLE_IVM (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        die("attempted nesting of .ENABLE_IVM at input line $.\n")
            unless $IVM_DISABLED;
        undef($IVM_DISABLED);
        return 1;
    }

    #---------------------------------
    # Optimizer: Suppress Optimization
    #---------------------------------

    if ($OP eq '.SUPPRESS_OPTIMIZATION') {                                              
        die("Syntax: .SUPPRESS_OPTIMIZATION <string> (<@_> at input line $.)\n")
            unless (@OP_ARG == 1);
        push(@optimization_suppressed,$OP_ARG[0]);
        return 1;
    }

	#--------------------
	# Memory Management
	#	- Page locking
	#--------------------

    if ($OP eq '.LOCK_ROM_PAGE') {                                              
        die("Syntax: .LOCK_ROM_PAGE (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
##        printf(STDERR "page locked at %04X\n",$ADDR) unless $opt_1;
		$locked_page = ($ADDR >> 8);
        return 1;
    }

    if ($OP eq '.UNLOCK_ROM_PAGE') {                                              
        die("Syntax: .UNLOCK_ROM_PAGE (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
		die("unexpected .UNLOCK_ROM_PAGE at input line $.\n")
			unless defined($locked_page);
		unless ($opt_1) {			
##	        printf(STDERR "page unlocked at %04X\n",$ADDR-1);
			die(sprintf("page-lock violation (%02X -> %04X) at input line $.\n",$locked_page,$ADDR-1))
				unless $locked_page == (($ADDR-1) >> 8);
		}
		undef($locked_page);
        return 1;
    }

    #---------------------
    # Conditional Assembly
    #---------------------

    if ($OP eq '.ENDIF') {                                                              # .ENDIF
        die("Syntax: .ENDIF (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        die("unexpected .ENDIF at input line $.\n")                                     # no .IF to end
            if ($IF_STACK[$#IF_STACK] == 0);
        pop(@IF_STACK);
        printf(STDERR "%d: @_ -> [@IF_STACK]\n",$.) if defined($opt_C);
        return 1;
    }

    if ($OP eq '.ELSE') {                                                               # .ELSE
        die("Syntax: .ELSE (<@_> at input line $.)\n")
            unless (@OP_ARG == 0);
        if ($IF_STACK[$#IF_STACK] == 1) {                                               # then, assembling -> else, not assembling
            $IF_STACK[$#IF_STACK] = -1;
        } elsif ($IF_STACK[$#IF_STACK] == -1) {                                         # then, not assembling -> else, assembling
            $IF_STACK[$#IF_STACK] = 1;
        } elsif ($IF_STACK[$#IF_STACK] != -2) {                                         # nested if, not assembling
            die("unexpected .ELSE at input line $. [@IF_STACK]\n");
        }
        printf(STDERR "%d: @_ -> [@IF_STACK]\n",$.) if defined($opt_C);
        return 1;
    }

    if ($OP eq '.IFDEF') {                                                              # .IFDEF
        die("Syntax: .IFDEF id (<@_> at input line $.)\n")
            unless (@OP_ARG >= 1);
		if ($IF_STACK[$#IF_STACK] < 0) {												# currently not assembling => skip entire nested if
			push(@IF_STACK,-2);
		} else {																		# currently assembling	
	        my($result);
    	    for (my($i)=0; $i<@OP_ARG; $i+=2) {
    	    	if ($i > 0) {
    	    		die("cannot decode .IFDEF (<@_> at input line $.)\n")
    	    			unless ($OP_ARG[$i-1] eq '||');
    	    	}
        		$ALIAS_REFD{$OP_ARG[$i]}++;
        		$result |= defined($ALIAS{$OP_ARG[$i]});
        	}
			push(@IF_STACK,$result ? 1 : -1);
        }
        printf(STDERR "%d: @_ -> [@IF_STACK]\n",$.) if defined($opt_C);
        return 1;
    }

    if ($OP eq '.IFNDEF' || $OP eq '.IFUNDEF') {                                        # .IFUNDEF
        die("Syntax: .IFUNDEF id (<@_> at input line $.)\n")
            unless (@OP_ARG == 1);
        $ALIAS_REFD{$OP_ARG[0]}++;
        if ($IF_STACK[$#IF_STACK] >= 0) {
            push(@IF_STACK,defined($ALIAS{$OP_ARG[0]}) ? -1 : 1);
        } else {
            push(@IF_STACK,-2);
        }
        printf(STDERR "%d: @_ -> [@IF_STACK]\n",$.) if defined($opt_C);
        return 1;
    }

    return 1 if ($IF_STACK[$#IF_STACK] < 0);                                            # conditional assembly is suspended 

	if ($OP eq '.ASSUME_DEFINED') { 													# .ASSUME_DEFINED
		die("Syntax: .ASSUME_DEFINED id[...] (<@_> at input line $.)\n")
			unless (@OP_ARG >= 1);
		for my $sym (@OP_ARG) {
			die("Undefined alias <$sym> assumed defined at input line $.\n")
				unless defined($ALIAS{$sym});
		}
		return 1;
	}

	if ($OP eq '.ASSUME_UNDEFINED') { 													# .ASSUME_UNDEFINED
		die("Syntax: .ASSUME_UNDEFINED id[...] (<@_> at input line $.)\n")
			unless (@OP_ARG >= 1);
		for my $sym (@OP_ARG) {
			die("Defined alias <$sym> assumed undefined at input line $.\n")
				if defined($ALIAS{$sym});
			$ALIAS_REFD{$sym} = -99;
		}
		return 1;
	}

    #-----------------------------------------
    # Defines (Aliases & Conditional Assembly)
    #-----------------------------------------

	if (match_pragma($OP,'.DEF','INE')) { 												# .DEFINE (define alias)
		die("Syntax: .DEF[INE] name [value...] (<@_> at input line $.)\n")
			unless (@OP_ARG >= 1);
		die if ($OP_ARG[0] eq 'DEFINED_ALIAS');
		$ALIAS_REFD{$OP_ARG[0]}++;
		if (@OP_ARG == 1) { 															# no argument (just define)
			$ALIAS{$OP_ARG[0]} = 'DEFINED_ALIAS';
		} elsif ($OP_ARG[1] =~ m{^'}) { 												# string argument (copy including quotes)
			($ALIAS{$OP_ARG[0]}) = m{('.*')};
		} else {																		# non-string arguments
			$ALIAS{$OP_ARG[0]} = "@OP_ARG[1..$#OP_ARG]";
		}
		return 1;
	}

	if (match_pragma($OP,'.UNDEF','INE')) {												# .UNDEF (undefine alias)
		die("Syntax: .UNDEF[INE] name [value...] (<@_> at input line $.)\n")			# using this prevents warnings of used but not defined defines  
			unless (@OP_ARG >= 1);
		die if ($OP_ARG[0] eq 'DEFINED_ALIAS');
		$ALIAS_REFD{$OP_ARG[0]} = -99;
		undef($ALIAS{$OP_ARG[0]});
		die if defined($ALIAS{$OP_ARG[0]});
		return 1;
	}

	if (match_pragma($OP,'.DECL','ARE')) {												# .DECLARE (undefine alias)
		die("Syntax: .DECL[ARE] name [...](<@_> at input line $.)\n") 					# using this prevents warnings but does not set value
			unless (@OP_ARG >= 1);
		foreach my $id (@OP_ARG) {
			die if ($id =~ m{^!.*!$});
			$ALIAS_REFD{$id} = -99;
		}
		return 1;
	}

	#--------
	# Labels 
	#--------

	if ($OP eq '.LBL' || $OP eq '.LABEL') { 											# .LBL/.LABEL (define label)
		die("Syntax: .LBL id value (<@_> at input line $.)\n")
			unless (@OP_ARG == 2);
		my($a) = $OP_ARG[1];
		$a = hex($a) if ($a =~ m{^\$([0-9a-fA-F]+)$});
		define_label($OP_ARG[0],$a);
		return 1;
	}

	if ($OP eq '.RELBL' || $OP eq '.RELABEL') { 										# .RELBL/.RELABEL (redefine label)
		die("Syntax: .LBL id value (<@_> at input line $.)\n")
			unless (@OP_ARG == 2);
		my($a) = $OP_ARG[1];
		$a = hex($a) if ($a =~ m{^\$([0-9a-fA-F]+)$});
		define_label($OP_ARG[0],$a,1);													# suppress overwrite warning
		return 1;
    }

    #--------
    # Data
    #--------

	if (($MODE == 0) || ($MODE == 3)) {		
		if ($OP eq '.DB') { 																# .DB (define bytes)
			die("Syntax: .DB byte-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 1);
			set_label_type(3);
			while (@OP_ARG > 0) {
				setROM($ADDR++,$OP_ARG[0]);
				shift(@OP_ARG);
			}
			return 1;
		}
	    
		if ($OP eq '.DW') { 																# .DW (define words)
			die("Syntax: .DW word-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 1);
			set_label_type(3);
			while (@OP_ARG > 0) {
				unless ($OP_ARG[0] =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {						# label
					printf("\$D711::Address = 0x%04X; &D711::def_ptr2lbl('$OP_ARG[0]');\n",$ADDR)
						if ($opt_x);
				}
				$ROM[$ADDR++] = $OP_ARG[0];
				$ROM[$ADDR++] = '16-BIT VALUE';
				shift(@OP_ARG);
			}
			return 1;
		}
	
		if ($OP eq '.DBW') {																# .DBW (define byte and words)
			die("Syntax: .DBW byte-val word-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 2);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0];
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				unless ($OP_ARG[0] =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {						# label
					printf("\$D711::Address = 0x%04X; &D711::def_ptr2lbl('$OP_ARG[0]');\n",$ADDR)
						if ($opt_x);
				}
				$ROM[$ADDR++] = $OP_ARG[0]; 
				$ROM[$ADDR++] = '16-BIT VALUE';
			}
			return 1;
		}
	
		if ($OP eq '.DBR') {																# .DBR (define byte followed by WPC ref)
			die("Syntax: .DBR byte-val WPC-ref (<@_> at input line $.)\n")
				unless (@OP_ARG == 3);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; $ROM[$ADDR++] = '16-BIT VALUE'; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			die(".DBR invalid WPC reference page (<@_> at input line $.)\n")
				unless ($ROM[$ADDR]<=0x3D) || ($ROM[$ADDR]==0xFF);
			return 1;
		}
	
		if ($OP eq '.DBRB') {																# .DBRB (define byte, WPC ref, followed by bytes)
			die("Syntax: .DBRB byte-val WPC-ref (<@_> at input line $.)\n")
				unless (@OP_ARG >= 5);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; $ROM[$ADDR++] = '16-BIT VALUE'; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			die(".DBR invalid WPC reference page (<@_> at input line $.)\n")
				unless ($ROM[$ADDR]<=0x3D) || ($ROM[$ADDR]==0xFF);
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				$ROM[$ADDR++] = $OP_ARG[0]; 
			}
			return 1;
		}
	
		if ($OP eq '.DBRWB') {																# .DBRWB (define byte, WPC ref, word, followed by bytes)
			die("Syntax: .DBRWB byte-val WPC-ref (<@_> at input line $.)\n")
				unless (@OP_ARG >= 6);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; $ROM[$ADDR++] = '16-BIT VALUE'; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			die(".DBR invalid WPC reference page (<@_> at input line $.)\n")
				unless ($ROM[$ADDR]<=0x3D) || ($ROM[$ADDR]==0xFF);
			$ROM[$ADDR++] = $OP_ARG[0]; $ROM[$ADDR++] = '16-BIT VALUE';
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				$ROM[$ADDR++] = $OP_ARG[0]; 
			}
			return 1;
		}
	
		if ($OP eq '.DBWB') {																# .DBW (define byte and words)
			die("Syntax: .DBW byte-val word-val byte-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 3);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; $ROM[$ADDR++] = '16-BIT VALUE';
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				unless ($OP_ARG[0] =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {						# label
					printf("\$D711::Address = 0x%04X; &D711::def_ptr2lbl('$OP_ARG[0]');\n",$ADDR)
						if ($opt_x);
				}
				$ROM[$ADDR++] = $OP_ARG[0]; 
			}
			return 1;
		}
	
		if ($OP eq '.DBBW') {																# .DBBW (define 2 bytes followed by words)
			die("Syntax: .DBBW byte-val byte-vale word-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 3);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; 
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				unless ($OP_ARG[0] =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {						# label
					printf("\$D711::Address = 0x%04X; &D711::def_ptr2lbl('$OP_ARG[0]');\n",$ADDR)
						if ($opt_x);
				}
				$ROM[$ADDR++] = $OP_ARG[0]; 
				$ROM[$ADDR++] = '16-BIT VALUE';
			}
			return 1;
		}
	
		if ($OP eq '.DBBRB') {																# .DBBRB (define 2 bytes, WPC ref, followed by bytes)
			die("Syntax: .DBBRB byte-val byte-vale WPC-ref byte-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 5);
			set_label_type(3);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; $ROM[$ADDR++] = '16-BIT VALUE'; shift(@OP_ARG);
			$ROM[$ADDR++] = $OP_ARG[0]; 
			die(".DBBRB invalid WPC reference page (<@_> at input line $.)\n")
				unless ($ROM[$ADDR-1]<=0x3D) || ($ROM[$ADDR-1]==0xFF);
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				$ROM[$ADDR++] = $OP_ARG[0];
			}
			return 1;
		}
	
		if ($OP eq '.DWB') {																# .DWB (define word and bytes)
			die("Syntax: .DWB word-val byte-val[...] (<@_> at input line $.)\n")
				unless (@OP_ARG >= 2);
			set_label_type(3);
			unless ($OP_ARG[0] =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {							# label
				printf("\$D711::Address = 0x%04X; &D711::def_ptr2lbl('$OP_ARG[0]');\n",$ADDR)
					if ($opt_x);
			}
			$ROM[$ADDR++] = $OP_ARG[0];
			$ROM[$ADDR++] = '16-BIT VALUE';
			for (shift(@OP_ARG); @OP_ARG > 0; shift(@OP_ARG)) {
				$ROM[$ADDR++] = $OP_ARG[0];
			}
			return 1;
	    }

	    #--------------------------------------------------
	    # 7-Segment Strings
	    #   - hard-coded font from the Internet somewhere
	    #--------------------------------------------------

		if ($OP eq '.S7R') {																# .S7R (define 7-segment string)
			my($str) = m{\.S7R\s+'(.*)'\s*$};												# extract string from original source line
			($str) = ($OP_ARG[0] =~ m{^'(.*)'$})											# possibly an ALIAS, in which case OP_ARG[0] is the substituted string
				if (length($str) == 0);     
			die("Syntax: .S7R '7-segment string' ((<'$str'> +$_+ at input line $.)\n")
				unless (@OP_ARG >= 1 && length($str) > 0);
			set_label_type(3);
			for (my($i)=my($j)=0; 1; $i++,$j++) {
				my($c) = substr($str,$i,1);
				last unless (ord($c) > 0);
				if ($c eq '0')					{ $ROM[$ADDR++] = 0x3F; }					# this defines the font
				elsif ($c eq '1' || $c eq  'I') { $ROM[$ADDR++] = 0x06; }
				elsif ($c eq '2' || $c eq  'Z') { $ROM[$ADDR++] = 0x5B; }
				elsif ($c eq '3')				{ $ROM[$ADDR++] = 0x4F; }
				elsif ($c eq '4')				{ $ROM[$ADDR++] = 0x66; }
				elsif ($c eq '5' || $c eq  'S') { $ROM[$ADDR++] = 0x6D; }
				elsif ($c eq '6')				{ $ROM[$ADDR++] = 0x7D; }
				elsif ($c eq '7')				{ $ROM[$ADDR++] = 0x07; }
				elsif ($c eq '8' || $c eq  'B') { $ROM[$ADDR++] = 0x7F; }
				elsif ($c eq '9')				{ $ROM[$ADDR++] = 0x6F; }
				elsif ($c eq 'A')				{ $ROM[$ADDR++] = 0x77; }
				elsif ($c eq 'b')				{ $ROM[$ADDR++] = 0x7C; }
				elsif ($c eq 'C' || $c eq  'K') { $ROM[$ADDR++] = 0x39; }
				elsif ($c eq 'c')				{ $ROM[$ADDR++] = 0x58; }
				elsif ($c eq 'd')				{ $ROM[$ADDR++] = 0x5E; }
				elsif ($c eq 'E')				{ $ROM[$ADDR++] = 0x79; }
				elsif ($c eq 'F')				{ $ROM[$ADDR++] = 0x71; }
				elsif ($c eq 'G')				{ $ROM[$ADDR++] = 0x3D; }
				elsif ($c eq 'H')				{ $ROM[$ADDR++] = 0x76; }
				elsif ($c eq 'h')				{ $ROM[$ADDR++] = 0x74; }
				elsif ($c eq 'i')				{ $ROM[$ADDR++] = 0x04; }
				elsif ($c eq 'J')				{ $ROM[$ADDR++] = 0x1E; }
				elsif ($c eq 'L')				{ $ROM[$ADDR++] = 0x38; }
				elsif ($c eq 'N')				{ $ROM[$ADDR++] = 0x37; }
				elsif ($c eq 'n')				{ $ROM[$ADDR++] = 0x54; }
				elsif ($c eq 'o')				{ $ROM[$ADDR++] = 0x5C; }
				elsif ($c eq 'P')				{ $ROM[$ADDR++] = 0x73; }
				elsif ($c eq 'q' || $c eq 'g')	{ $ROM[$ADDR++] = 0x67; }
				elsif ($c eq 'R')				{ $ROM[$ADDR++] = 0x31; }
				elsif ($c eq 'r')				{ $ROM[$ADDR++] = 0x50; }
				elsif ($c eq 't')				{ $ROM[$ADDR++] = 0x78; }
				elsif ($c eq 'U' || $c eq 'V')	{ $ROM[$ADDR++] = 0x3E; }
				elsif ($c eq 'u')				{ $ROM[$ADDR++] = 0x1C; }
				elsif ($c eq 'Y')				{ $ROM[$ADDR++] = 0x6E; }
				elsif ($c eq ' ')				{ $ROM[$ADDR++] = 0x00; }
				elsif ($c eq '-')				{ $ROM[$ADDR++] = 0x40; }
				elsif ($c eq '_')				{ $ROM[$ADDR++] = 0x08; }
				elsif ($c eq ']')				{ $ROM[$ADDR++] = 0x0F; }
				elsif ($c eq '~')				{ $ROM[$ADDR++] = 0x01; }
				elsif ($c eq '=')				{ $ROM[$ADDR++] = 0x48; }
				elsif ($c eq '"')				{ $ROM[$ADDR++] = 0x22; }
				elsif ($c eq '`')				{ $ROM[$ADDR++] = 0x02; }
				elsif ($c eq "'")				{ $ROM[$ADDR++] = 0x20; }
				elsif ($c eq '/')				{ $ROM[$ADDR++] = 0x52; }
				elsif ($c eq '|')				{ $ROM[$ADDR++] = 0x30; }
				elsif ($c eq ')')				{ $ROM[$ADDR++] = 0x43; }
				elsif ($c eq '(')				{ $ROM[$ADDR++] = 0x61; }
				elsif ($c eq '*')				{ $ROM[$ADDR++] = 0x63; }
				elsif ($c eq '&')				{ $ROM[$ADDR++] = 0x5F; }
				elsif ($c eq '^')				{ $ROM[$ADDR++] = 0x21; }
				elsif ($c eq '%')				{ $ROM[$ADDR++] = 0x3D; }
				elsif ($c eq '}')				{ $ROM[$ADDR++] = 0x46; }
				elsif ($c eq '{')				{ $ROM[$ADDR++] = 0x3D; }
				elsif ($c eq '?')				{ $ROM[$ADDR++] = 0x4B; }
				elsif ($c eq '<')				{ $ROM[$ADDR++] = 0x18; }
				elsif ($c eq '>')				{ $ROM[$ADDR++] = 0x0C; }
				elsif ($c eq '\\') {
					$i++;
					if (substr($str,$i,1) eq '\\') {
						$ROM[$ADDR++] = 0x64;
					} else {
						my($code) = substr($str,$i,2);
						die("Invalid string escape sequence <\\$code> at input line $.\n")
							unless (length($code)==2 && hex($code)>=0 && hex($code)<=0xFF);
						$ROM[$ADDR++] = hex($code);
						$i++;
					}
				} # if \\
				else {
					die("Invalid 7-segment string character <$c> at input line $.\n");
				}
			} # for
			return 1;
	    }

    #------------------------------------------------------------------------------------------
    # 14-Segment Strings / String Encoding / encode_string / encode_char
    #
    # Encoding:
    #   - bit-7 set:
    #       48-127                      add a period
    #   - bit-7 clear:
    #       $00-$2F 0-47                <space>                     NB: this includes ASCII space and tab, both used in Pinbot
    #       $30-$39 48-57   176-185     <0>-<9>                     7-segment font; ASCII compatible encoding
    #       $3A-$40 58-64               <space>     
    #       $41-$5A 65-90   193-218     <A>-<Z>                     ASCII compatible encoding
    #       $5B-$62 91-98   219-226     <0>-<3>,<5>-<7>,<9>         14-segment font (fancy)
    #       $63     99      227         <all segments lit>
    #       $64-$68 100-104 228-232     <<>,<=>,<>>,<?>,<@>         ASCII block; @ is 7-segment font
    #       $69-$6B 105-107 233-235     <$>,<%>,<&>                 ASCII block
    #       $6C-$71 108-113 236-241     <,>,<.>,<+>,<->,</>,<\>     
    #       $72-$74 114-116 242-244     <]>,<^>,<_>                 ASCII block
    #       $75-$77 117-119 245-247     <{>,<*>,<}>
    #       $78     120     248         <">                         quotation start (right-aligned)
    #       $79     121     249         <[>     
    #       $7A     122     250         <">                         quotation end (left-aligned)
    #       $7B     123     251         <@>                         14-segment font
    #       $7C     124     252         <8+|>
    #       $7D     125     253         <NE arrow>
    #       $7E     126     254         <SE arrow>
    #       $7F     127     255         <SW arrow>
    #       $80     128                 <NW arrow>
    #       $81     129                 <overline>
    #       $82     130                 <'>
    #       $83-$AF 131-175             <space>
    #       $B0-$FF 176-255             <0.>,<1.>,...,<SW arrow.>   period added after base symbol
    #-----------------------------------------------------------------------------------------

		if ($OP =~ m{^.STR}) {																# .STR[len] (define string)
			my($len) = $';
			die("Syntax: .STR[len] '14-segment string' at input line $.\n")
				if numberp($len) && $len<=0;
			my($str) = m{\.STR\d*\s+'(.*)'\s*$};											# extract string from original source line
			($str) = ($OP_ARG[0] =~ m{^'(.*)'$})											# possibly an ALIAS, in which case OP_ARG[0] is the substituted string
				if (length($str) == 0);
			die("Syntax: .STR[len] '14-segment string' (<'$str'> at input line $.)\n")		# not either
				unless (length($str) > 0);
			set_label_type(3);
			$str = $COMPILATION_TIMESTAMP													# @COMPILER VAR: compilation timestamp
				if ($str eq '@COMPILATION_TIMESTAMP');
			$str = $COMPILATION_INFO														# @COMPILER VAR: compilation info
				if ($str eq '@COMPILATION_INFO');
			$str = $COMPILATION_INFO77														# @COMPILER VAR: compilation info
				if ($str eq '@COMPILATION_INFO77');
			if ($str eq '@FREE_SP') {														# @COMPILER VAR: free space
				$FREE_SP_ADDR = $ADDR;
			}
			if ($len > 0) {
				my($nop) = $str;
				$nop =~ s/\.//g; 															# remove periods
				$nop =~ s/\\../X/g;															# remove octal chars
				die("Syntax: .STR$len '$len-long 14-segment string' (<'$str'> at input line $.)\n") # regular string
					unless (@OP_ARG >= 1 && length($nop) == $len);
			} else {
				die("Syntax: .STR '14-segment string' (<'$str'> at input line $.)\n")		# regular string
					unless (@OP_ARG >= 1 && length($str) > 0);
			}
			for (my($i)=0; $i<length($str); $i++) {
				my($c) = substr($str,$i,1);
				if ($c eq '.') {
					die("Invalid 14-segment string (<'$str'> at input line $.)\n")
						unless ($i > 0);
					$ROM[$ADDR-1] |= 0x80;
				} else {
					my($o) = ord($c);
					if ($o>=ord('0') && $o<=ord('9')) {
						$ROM[$ADDR++] = $o;
					} elsif ($o>=ord('A') && $o<=ord('Z')) {
						$ROM[$ADDR++] = $o;
					} elsif ($o>=ord('<') && $o<=ord('@')) {
						$ROM[$ADDR++] = $o - ord('<') + 100;
					} elsif ($o>=ord('$') && $o<=ord('&')) {
						$ROM[$ADDR++] = $o - ord('$') + 105;
					} elsif ($o>=ord(']') && $o<=ord('_')) {
						$ROM[$ADDR++] = $o - ord(']') + 114;
					} elsif ($c eq ' ') { $ROM[$ADDR++] = 32;
					} elsif ($c eq ',') { $ROM[$ADDR++] = 108;
					} elsif ($c eq '.') { $ROM[$ADDR++] = 109;
					} elsif ($c eq '+') { $ROM[$ADDR++] = 110;
					} elsif ($c eq '-') { $ROM[$ADDR++] = 111;
					} elsif ($c eq '/') { $ROM[$ADDR++] = 112;
					} elsif ($c eq '{') { $ROM[$ADDR++] = 117;
					} elsif ($c eq '*') { $ROM[$ADDR++] = 118;
					} elsif ($c eq '}') { $ROM[$ADDR++] = 119;
					} elsif ($c eq '[') { $ROM[$ADDR++] = 121;
					} elsif ($c eq '\\') {
						$i++;
						if (substr($str,$i,1) eq '\\') {
							$ROM[$ADDR++] = 113;
						} elsif (substr($str,$i,1) eq "'") { 
							$ROM[$ADDR++] = 130;
						} else {
							my($code) = substr($str,$i,2);
							die("Invalid string escape sequence <\\$code> at input line $.\n")
								unless (length($code)==2 && hex($code)>=0 && hex($code)<=0xFF);
							$ROM[$ADDR++] = hex($code);
							$i++;
						}
					} else {
						die("Invalid character (ord = $o) (<'$str'> at input line $.)\n");
						$ROM[$ADDR++] = $o;
					}
				}
			}
			return 1;
	    }

    #------------------------------------------------------------------------------------------
    # Compressed 14-Segment Strings (Z-Strings)
    #
    #	16-long character strings,
    #		consisting only of chacaters A-Z, space, 0, 1, 2, 3 and 5, 
    #		and having a space in the last position
	#	that are compressed into 10 bytes
	#
    # Encoding (before inverting):
    #       $00                         <space>
    #       $01-$1A                     <A>-<Z>     
    #       $1B-$1E                     <0>-<3>     fancy font
    #       $1F                         <5>         fancy font
    #
    # Notes:
    #   - encoding governed by unpacking efficiency
	#	- code is inverted to allow checking for space in last position (Z-Strings)
	#	- regular strings with periods in positions 5-10 are misinterpreted as Z-strings
	#	  and cannot be displayed
    #-----------------------------------------------------------------------------------------

		my($str);
		if ($OP eq '.ZSTR') {
			($str) = m{\.ZSTR\s+'(.*)'\s*$};											   # extract string from original source line
			($str) = ($OP_ARG[0] =~ m{^'(.*)'$})											# possibly an ALIAS, in which case OP_ARG[0] is the substituted string
				if (length($str) == 0);
			die("Syntax: .ZSTR '16-character string' (<'$str'> at input line $.)\n")    
				unless (length($str) == 16);
			die(sprintf("Invalid non-space character <%s> in last positon of z-string (<'$str'> at input line $.)\n",substr($str,15)))
				unless (substr($str,15) eq ' ');
	
			set_label_type(3);
	
		ENCODE_PART_2:
			my(@ZSbit);
			for (my($i)=0; $i<8; $i++) {
				my($c) = ($i >= length($str)) ? ' ' : substr($str,$i,1);
				my($o) = ord($c);
	
				if ($c eq ' ') {						$o = 0; }
				elsif ($o>=ord('0') && $o<=ord('3')) {	$o = $o - ord('0') + 0x1B; }
				elsif ($o==ord('5'))				 {	$o = ord('4') - ord('0') + 0x1B; }
				elsif ($o>=ord('A') && $o<=ord('Z')) {	$o = $o - ord('A') + 1; }
				else { die("Invalid z-string character <$c> (<'$str'> at input line $.)\n"); }
	
#			printf(STDERR "bit%d: %08b (%s)\n",$i,$o,$c);
	
				$ZSbit[0][$i] = 1 unless ($o>>4)&0x01;
				$ZSbit[1][$i] = 1 unless ($o>>3)&0x01;
				$ZSbit[2][$i] = 1 unless ($o>>2)&0x01;
				$ZSbit[3][$i] = 1 unless ($o>>1)&0x01;
				$ZSbit[4][$i] = 1 unless ($o>>0)&0x01;
			}
	
			for (my($i)=0; $i<5; $i++) {
				my($ZSB) = 0;
				$ZSB |= 0x01 if $ZSbit[$i][0];
				$ZSB |= 0x02 if $ZSbit[$i][1];
				$ZSB |= 0x04 if $ZSbit[$i][2];
				$ZSB |= 0x08 if $ZSbit[$i][3];
				$ZSB |= 0x10 if $ZSbit[$i][4];
				$ZSB |= 0x20 if $ZSbit[$i][5];
				$ZSB |= 0x40 if $ZSbit[$i][6];
				$ZSB |= 0x80 if $ZSbit[$i][7];
				$ROM[$ADDR++] = $ZSB;
			}
	
			if (length($str) > 8) {
				$str = substr($str,8);
				undef(@ZSbit);
				goto ENCODE_PART_2;
			}
	
			return 1;
	    }

	#---------------------------------------------------
	# ASCII String (used for clear-text messages in ROM)
	#---------------------------------------------------

		if ($OP eq '.ASCII') {															    
			my($str) = m{\.ASCII\s+'(.*)'\s*$}; 											# extract string from original source line
			($str) = ($OP_ARG[0] =~ m{^'(.*)'$})											# possibly an ALIAS, in which case OP_ARG[0] is the substituted string
				if (length($str) == 0);
			die("Syntax: .ASCII 'string' (<'$str'> at input line $.)\n")					# not either
				unless (length($str) > 0);
			set_label_type(3);
			die("Syntax: .ASCII 'string' (<'$str'> at input line $.)\n")					# regular string
				unless (@OP_ARG >= 1 && length($str) > 0);
			for (my($i)=0; $i<length($str); $i++) {
				$ROM[$ADDR++] = ord(substr($str,$i,1));
			}
			return 1;
	    }
	} # MODE == 1

	#-----------------------------------------------------------
	# Address Management
	# 	- do not move this to the beginning of the routine
	#-----------------------------------------------------------

    if ($OP eq '.ORG') {                                                               		# .ORG
    	$ADDR = $OP_ARG[0];
    	if ($WMS_System>=6 && $WMS_System<=11) {											# System 6-11: no ROM paging
			if ($ADDR =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {
				die("Syntax: .ORG ROM-addr (<@_> at input line $.)\n")
					unless defined($2);
				   if ($1 eq '$') { $ADDR = hex($2); }										# decimalize
				elsif ($1 eq '%') { $ADDR = eval('0b' . $2); }
				else			  { $ADDR = $2; }
				die("Cannot decode number <$OP_ARG[0]> at input line $.\n")
					unless numberp($ADDR);
				die(sprintf(".ORG address \$%04X out of range [\$%04X-\$%04X] at input line $.\n",$ADDR,$MIN_ROM_ADDR,$MAX_ROM_ADDR))
					unless ($ADDR >= $MIN_ROM_ADDR && $ADDR <= $MAX_ROM_ADDR);
			} else {
				die("Syntax: .ORG ROM-addr (<@_> at input line $.)\n");
	        }
	    } elsif ($WMS_System =~ /^WPC/) {
			if ($ADDR =~ m{^\$?([0-9A-Fa-f]{2}):\$?([0-9A-Fa-f]{4})$}) {
				die("Syntax: .ORG PG:ADDR (<@_> at input line $.)\n")
					unless defined($2);
				my($pg) = hex($1);
				my($ad) = hex($2);
				die("Cannot decode <$OP_ARG[0]> at input line $.\n")
					unless numberp($pg) && numberp($ad);
##				$FIRST_RPG = $pg unless defined($FIRST_RPG);								# first .ORG
				$RPG  = $pg;
				$ADDR = ($pg == 0xFF) ? $ad : ($pg*0x4000 + ($ad - 0x4000));
				die(sprintf(".ORG ROM address \$%05X out of valid range [\$%05X-\$%05X] at input line $.\n",$ADDR,$MIN_ROM_ADDR,$MAX_ROM_ADDR))
					unless ($ADDR >= $MIN_ROM_ADDR && $ADDR <= $MAX_ROM_ADDR);
			} else {
				die("Syntax: .ORG <PG:ADDR> (<@_> at input line $.)\n");
	        }
	    } else {
	    	die;
	    }

        $FIRST_ADDR = $ADDR if ($ADDR < $FIRST_ADDR);

		if (defined($ROM[$ADDR])) {
			my($nBytes) = 0;
			while (defined($ROM[$ADDR + ++$nBytes])) {}
			if ($opt_v || $opt_t) {
				printf(STDERR "%5d: WARNING: ROM overflow (<.ORG \$%04X>) at input line $.\n",$LINE[$ADDR],$ADDR);
			} else {
				die(sprintf("ROM overflow ($nBytes bytes; <.ORG \$%04X> replacing $ROM[$ADDR]) at input line $.\n",$ADDR))
					unless $opt_1;
			}
		}
        return 1;
    }

    if (isMember($OP,'.ASSUME_DP','.DP','.SET_DP')) {									# set direct page register for compiler
    	die("Invalid compiler pragma <$OP> for WMS System <$WMS_System> at input line $.\n")
    		unless defined($RPG);
		if ($OP_ARG[0] =~ m{^([\$%]?)([0-9A-Fa-f]+)$}) {
			   if ($1 eq '$') { $DP = hex($2); }										# decimalize
			elsif ($1 eq '%') { $DP = eval('0b' . $2); }
			else			  { $DP = $2; }
			die("Cannot decode number <$OP_ARG[0]> at input line $.\n")
	            unless numberp($DP);
	        return 1;
	    } else {
	    	die("Syntax: $OP addr-MSB (<$OP @OP_ARG> at input line $.)\n");
	    }
    }

	die("Unknown mode-$MODE .PRAGMA <@_> on line $.\n");
}
    
#----------------------------------------------------------------------
# Dump ROM
#	- for debugging code-output changes
#----------------------------------------------------------------------

sub dump_ROM()
{
	for (my($a)=$MIN_ROM_ADDR; $a<=$MAX_ROM_ADDR; $a++) {
#		printf("\n%s\n\$%04X:",$SRC[$a],$a) if (defined($SRC[$a]));
		printf("\n\$%04X:",$a) if (defined($SRC[$a]));
		if (numberp($ROM[$a])) {
			printf(" %02X",$ROM[$a]);
		} else {
			print(" $ROM[$a]");
		}
	}
}

