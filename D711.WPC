#======================================================================
#                    D 7 1 1 . W P C 
#                    doc: Thu Jul 18 06:34:49 2024
#                    dlm: Thu Jul 31 10:49:45 2025
#                    (c) 2024 idealjoker@mailbox.org
#                    uE-Info: 2163 0 NIL 0 0 72 10 2 4 NIL ofnI
#======================================================================

# WPC Disassembly 

# HISTORY:
#	Jul 18, 2024: - created; WMS CPU vectors disassemble correctly
#	Aug  9, 2024: - continued
#	Aug 10, 2024: - added support for ROM pages
#	Aug 11, 2024: - System Call Pointers disassemble correctly
#				  - BUG: WMS CPU vectors no longer disassemble correctly
#	Aug 12, 2024: - added support for system strings
#	Aug	14, 2024: - imported WPC specific code from [D711.pm]
#	Aug 15, 2024: - BUG: def_WPC_codePtr() did not define target labels
#	Aug 16, 2024: - many improvements; now switch table disassembles w/o errors
#	Aug 17, 2024: - many improvements
#	Aug 18, 2024: - BUG: API loaded before ROM
#	Aug 19, 2024: - added _skip
#				  - started adapting to ! WPC shortcut
#	Aug 21, 2024: - BUG: EXTRA_IND, EXTRA_BEFORE_LABEL and EXTRA_AFTER_OP where not
#						 paged in and out
#	Aug 23, 2024: - decimalized !*Sleep args
#	Aug 25, 2024: - renamed addScore because it was wrnog
#				  - BUG: substr used wrong length arg
#	Aug 27, 2024: - BUG: @DIVIDER was not swapped in and out
#				  - additions
#	Aug 28, 2024: - BUG: switchTable allowed labels for bytes
#				  - BUG: wrong page labels in set_WPC_ref
#	Aug 29, 2024: - moved extra lines after RTS, JMP, etc in here from [D711.M6809]
#	Aug 31, 2024: - moved API loading into disassemble_WPC_DMD
#				  - BUG: decimalization of sleep args did not work for lower case sleep
#	Sep  1, 2024: - added support for _IF_true and _IF_false "macros"
#	Sep  2, 2024: - made lamps decimal
#	Sep  4, 2024: - BUG: _IF_true did not work correctly with &skip
#	Sep  8, 2024: - added empty lines after tables
#				  - added def_WPC_lockTable()
#	Sep 10, 2024: - BUG: lock table has different structure
#	Sep 15, 2024: - new label syntax
#	Sep 21, 2024: - BUG: line spacing
#	Mar 11, 2025: - BUG: WCP_codeRef defined AUTO_LBL in wrong ROM page (difficult!)
#				  - BUG: lockTable had .DWBW instead of .DWB
#	Mar 14, 2025: - improved error message
#	Mar 15, 2025: - adapted to new interface w/o _DMD in function names
#				  - BUG: init_WPC() set _cur_RPG
#	Mar 16, 2025: - BUG: couple of label bugs
#	Mar 17, 2025: - merged from D711.WPC_DMD (mainly) and D711.WPC_Alphanumeric
#	Mar 18, 2025: - improved disassemble_syscalls()
#	Mar 19, 2025: - BUG: select_WPC_RPG() did not always return correct value
#				  - BUG: select_WPC_RPG() check of page ids did not work
#				  - added support for Game Event Hooks (@Hook)
#	Mar 21, 2025: - updated disassemble_MBD_system() to work with scanCode
#	Mar 23, 2025: - updated disassemble_MBD_system() to work with WPC_MBD.obj
#	Mar 24, 2025: - adapted to @OI (.obj output)
#	Mar 25, 2025: - BUG: &skip magic did not work correctly
#	Mar 26, 2025: - removed extra space after BRA and _ENDLOOP
#	Apr  3, 2025: - modified scan output
#	Apr  5, 2025: - modified scan output again
#				  - added support for -p
#				  - added produce_object_output() 
#				  - adapted scanCode() to work with prime area
#	Apr  6, 2025: - BUG: wrong labels set on -p
#				  - BUG: wrong number of defined labels reported
#				  - added support for obj file tags
#	Apr  7, 2025: - added gap info to obj files
#				  - added duplicate obj detection
#	Apr  8, 2025: - re-worked and debugged scanCode in prep for adaptation
#				    to multi-label matches
#	May 29, 2025: - replaced _skip by & _SKIP
#	May 30, 2025: - renamed _branchIfTrue, etc. ops
#	Jun  1, 2025: - improved disassembly of system pointers
#				  - BUG: def_WPC_ref() did not update $Address
#				  - added _SKIP macro
#				  - replaced a couple of .DWB by .DR
#	Jun  2, 2025: - re-wrote def_WPC_codeRef()
#				  - modify def_WPC_ref() to deal with pre-existing partial
#					analysis (munging)
#				  - cleaned up System Data Pointers with FH
#	Jun  9, 2025: - BUG: SKIP label removal was broken
#	Jun 10, 2025: - BUG: SKIP label removal was still broken
#				  - BUG: hard-coded page number used for debugging left in
#						 place
#	Jun 12, 2025: - BUG: disassemble_sycalls() did not set page
#				  - BUG: WPC reference +2 page labels were not created
#						 unless .DR came after .DB of this ref
#				  - BUG: define_syscall did not set correct page
#	Jun 13, 2025: - BUG: _SKIP labels not removed in case of two
#						 labels with same code addr in 2 different
#						 pages
#	Jun 15, 2025: - added support for __IF, etc.
#				  - greatly improved system pointer decoding
#	Jun 21, 2025: - added def_WPC_bitgroup_table
#	Jun 22, 2025: - made it work
#	Jun 23, 2025: - added def_WPC_FXtable()
#				  - re-added goood bitgroup table decoding
#				  - reduced WPC table indents to same as code
#	Jun 24, 2025: - added WPC stuff
#	Jun 25, 2025: - added =SOLCMD_TABLE
#				  - added more tables and a couple of lists
#	Jun 26, 2025: - added support for list tables in def_WPC_table()
#	Jun 27, 2025: - BUG fixes and improvements
#	Jun 29, 2025: - added gap warnings
#				  - added font and DMD tables
#	Jun 30, 2025: - improved gap ref warnings
#	Jul  3, 2025: - adapted to @CHECKSUM_INFO
#	Jul  4, 2025: - improved produce_gap_warnings to add data refs
#				  - added def_WPC_unknownSystem_table_1
#				  - removed .DxRy data definitions because they
#					mess up gap warnings
#	Jul  5, 2025: - further improved gap warning code
#				  - debugged and re-enabled def_WPC_unknownSystem_table_1
#	Jul  6, 2025: - added def_WPC_codeRef_nonPrime()
#				  - replaced byte between $81 in bitgroup definition with lamp
#				  - added FX type
#	Jul  7, 2025: - BUG: WPC tables started with Row 1
#				  - added custom labels for WPC tables
#				  - BUG: custom labels were broken
#	Jul  8, 2025: - BUG: lamp group range is too short
#	Jul 20, 2025: - added defSound()
#				  - added additional inCode refs
#	Jul 23, 2025: - adapted to change Sol# -> SolCmd#
#				  - adapted to change FX -> lampFX
#	Jul 27, 2025: - added LD operand labels for inCode_refs
#	Jul 28, 2025: - BUG: in-code refs were not immediate
#				  - removed unused rem assignment statements
#				  - BUG: in-code refs did not have PG prefix encoded
#	Jul 30, 2025: - changed FX# to LampFX#
#	Jul 31, 2025: - BUG: bitgroup def byte $81 $81 indicates Bitgroup, not Lamp
#				  - BUG: Bitgroup#00 was disallowed
# END OF HISTORY 

#----------------------------------------------------------------------
# Object File Disassembly 
#----------------------------------------------------------------------

sub produce_object_output($$$$)
{				  
	my($RPG,$fa,$la,$tag) = @_;
	$fa = 0 unless defined($fa);
	$la = $#ROM unless defined($la);

	my($objss,$rems) = (0,0);

	print("$tag\n");
	print("$RPG\n");														# PG id
	for (my($addr)=$fa; $addr<=$la; $addr++) {  

		my($nGap) = 0;														# handle gaps
		$nGap++ while !$decoded[$addr+$nGap] && $addr+$nGap<$la;;
		if ($nGap) {
			print("G$nGap\n");
			$addr += $nGap-1;
			next; 
        }

		next unless defined($OP[$addr]);									# skip inter-op addresses

		if (defined($LBL[$addr]) && !($LBL[$addr] =~ m{[\.~]})) {			# start next object (not on BRA labels)
			$objs++;
			print(">$LBL[$addr]\n");
			print(";[$tag]\n") unless defined($REM[$addr]);					# add a tag if there is no comment
        }

		if (defined($REM[$addr])) {											# add comment
			$rems++;
			print(";[$tag] $REM[$addr]\n") 
        }

		foreach my $oi (@{$OI[$addr]}) {									# process all object info for this op
			if ($oi =~ m{^:} && defined($LBL[hex($')])) {					# address with label
				printf(":%s ",$LBL[hex($')]);
			} else {														# anything else
				print("$oi ");
			}
		}
		print("\n");
	}
	printf(STDERR "ROM PG#%02X: $objs objects with $rems comments produced\n",$RPG);
}


sub scanCode(@)																# Code Scanner
{
##	print(STDERR "scanCode(@_)\n");
	my($allowedMismatches,$pg,$lbl,$fi,$li) = @_;

	select_WPC_RPG($pg);

	my($saddr) = ($pg == 0xFF) ? 0x7FFF : 0x3FFF;							# start of match minus 1
	my($eaddr) = ($pg == 0xFF) ? 0xFFFF : 0x7FFF;							# end of match area
	$Address = $saddr;

	my(@matchData,@matchLabel,@matchREM);									# data from successful match
	my($match_lbl,$match_Address,$match_saddr);								# multiple matches check

 RESTART_SCAN:																# jump target for failed matches and checking for multiple matches
## 	printf(STDERR "RESTART_SCAN (len = %d) at %04X\n",$Address - $saddr,$saddr);
	my($mismatches,$mi); 

 	$saddr++;																# try next
	if ($saddr > $eaddr) {													# MATCH FAILED
		goto SCANCODE_SUCCESS if defined($match_lbl);
		return 0;															# never matched
	}

	$mismatches = 0; $mi = $fi;												# reset scanner data
	undef(@matchData); 
	undef(@matchLabel);
	undef(@matchREM);

N:
	for ($Address=$saddr; $mi<$li; ) {
		goto RESTART_SCAN if $Address > 0xFFFF;
		$mi++;
##		printf(STDERR "od = $objData[$mi] (@matchData) addr = %04X\n",$Address);

		if (substr($objData[$mi],0,1) eq 'G') {							# gap
			$Address += substr($objData[$mi],1);
			next;
        }

		if (substr($objData[$mi],0,1) eq ';') {							# comment
			my($ro) = $Address-$saddr;
			$matchREM[$ro] = substr($objData[$mi],1)
				unless defined($matchRem[$ro]);
			next;
		}

		foreach my $ode (split(/ /,$objData[$mi])) {
		
			if (substr($ode,0,1) eq ':') { 						# WORD
				if (length($ode) > 1) {								# with label
					my($tlbl) = substr($ode,1);
					my($tval) = WORD($Address);
					push(@matchLabel,$tlbl);
					push(@matchData,$tval);
					$Address += 2;
					if (defined($Lbl{$tlbl}) && ($Lbl{$tlbl} != $tval)) {
						$mismatches++;
						goto RESTART_SCAN if ($mismatches > $allowedMismatches);
					}
				} else {														# anonymous
					$Address += 2;
				}
				next;
			}
	
			if (substr($ode,0,1) eq '.') { 						# BYTE
				if (length($ode) > 1) {
					my($tlbl) = substr($ode,1);
					my($tval) = BYTE($Address);
					push(@matchLabel,$tlbl);
					push(@matchData,$tval);
					$Address += 1;
					if (defined($Lbl{$tlbl}) && ($Lbl{$tlbl} != $tval)) {
						$mismatches++;
						goto RESTART_SCAN if ($mismatches > $allowedMismatches);
					}
				} else {
					$Address += 1;
				}
				next;
			}
	
			for (my($j)=0; $j<int(length($ode)/2); $j++,$Address++) {		# HEX
				die("scanCode: invalid objData #$j <$ode>\n")
					unless (substr($ode,2*$j,2) =~ m{^[0-9A-f]{2}});
##				printf(STDERR "%04X: %02X (<-%s) [$mismatches]\n",$Address,BYTE($Address),substr($ode,2*$j,2))
##					if $mi>5;
##				printf(STDERR "%s vs %02X\n",substr($ode,2*$j,2),BYTE($Address));
				if (hex(substr($ode,2*$j,2)) != BYTE($Address)) {
					$mismatches++; 
					goto RESTART_SCAN if ($mismatches > $allowedMismatches);
				}
	        }
        }
	}

	#-----------------
	# Successful Match
	#-----------------

##	print(STDERR "MATCH ($mismatches)\n");
	if ($mismatches == 0) {
		if (defined($match_lbl)) {											# duplicate match
			printf(STDERR "scanCode: $match_lbl matches multiple addresses (%04X, %04X, ...) -- skipped\n",
				$match_saddr,$saddr)
					unless $saddr == $match_saddr+1;
			return -1;														# multiple matches
        }
		$match_lbl	   = $lbl;
		$match_Address = $Address;											# record first match
		$match_saddr   = $saddr;
		goto RESTART_SCAN;													# try again
    }

SCANCODE_SUCCESS:															# jump target when there is no 2nd match
	if (defined($match_lbl)) {
		$lbl 	 = $match_lbl;
		$Address = $match_Address;
		$saddr	 = $match_saddr;
		$mismatches = 0;
    }
##	printf(STDERR "scanCode: $lbl found at %04X ($mismatches)\n",$saddr);

	my($labels_defined,$comments_defined) = (0,0);							

	if ((($Address-$saddr)-$mismatches > 15) && 							# exclude short code snippets with likely multiple matches...
#			($LBL[$saddr] ne $lbl) &&										# ... already  defined labels ...
			!($lbl =~ m{^GameHook#[0-9A-F]{2}_event$})) {					# ... and automatically generated labels (GameHook#XX_event)
		$labels_defined++;
##		printf("D711::setLabel('$lbl',0x%04X,0x%02X); \$D711::Address = 0x%04X; D711::def_code();\n",
##			$saddr,$pg,$saddr);
		for (my($i)=0; $i<@matchData; $i++) {
			next if ($matchLabel[$i] =~ m{^RAM_[0-9A-F]{2,4}$});			# "anonymous" labels (e.g. RAM_0384) are set automatically (no need to handle here)
			next if ($LBL[$matchData[$i]] eq $matchLabel[$i]);				# label already defined
			$labels_defined++;
			printf("D711::setLabel('$matchLabel[$i]',0x%04X,0x%02X);\n",$matchData[$i],$pg);
		}																	# by the disassembler and cannot migrate over
		for (my($i)=0; $i<@matchREM; $i++) {
			next unless defined($matchREM[$i]);
			$comments_defined++;
			printf("\$D711::REM[0x%04X] = '$matchREM[$i]';\n",$saddr+$i);
	    }
		return ($labels_defined,$comments_defined,$saddr);
	}
	return undef;															# not multiple matches (don't report)
}

sub scan(@)
{
	my($trace) = 0;
	my($ld,$cd,$addr) = scanCode(0,@_);
	if (defined($cd)) {
		printf(STDERR "scanCode($_[1]): exact match\n") if $trace;
		$exact++;
		$lbldefd += $ld;
		$remdefd += $cd;
	} elsif ($ld == 0) {
		printf(STDERR "scanCode($_[1]): exact match failure (not multiple)\n") if $trace;
		($ld,$cd,$addr) = scanCode(5,@_);
		if (defined($cd)) {
			printf(STDERR "scanCode($_[1]): FUZZY match at (%04X)\n",$addr); # if $trace;
			$fuzzy++;
			$lbldefd += $ld;
			$remdefd += $cd;
        } else {
			printf(STDERR "scanCode($_[1]): fuzzy match failure\n") if $trace;
        	$failed++;
        }
	} else {
		printf(STDERR "scanCode($_[1]): multiple match failure\n") if $trace;
		$failed++;
    }
}

sub process_object_file($)													# execute this early on, because it defines syscalls
{
	my($ofn) = @_;
	
	local(@objData);														# object file contents
	local($exact,$fuzzy,$failed) = (0,0,0);									# scan results
	local($lbldefd,$remdefd) = (0,0);

	open(OBJF,"$ofn") || die("$ofn: $!\n");									# open file and read PG id
	$_ = <OBJF>; chomp;														# tag
	$_ = <OBJF>; chomp;
	die("$ofn: page id missing\n")
		unless m/[0-9A-F]{2}/;
	my($RPG) = hex($_);
	select_WPC_RPG($RPG);

	while (<OBJF>) {														# read object data
		chop;
		next if /^#/;														# skip comments
		push(@objData,$_);
    }
	close(OBJF);	

	my($s) = 0;																# starting index
	die($objData[$s]) unless substr($objData[$s],0,1) eq '>';
	my($lbl) = substr($objData[$i],1);
	for (my($e)=1; $e<@objData; $e++) {
		if (substr($objData[$e],0,1) eq '>') {								# next label
			scan($RPG,$lbl,$s,$e-1);
			$s = $e;
			$lbl = substr($objData[$s],1);
#			print(STDERR "process_object_file: scanning for $lbl...\n");
        } 
	}
	scan($RPG,$lbl,$s,$e-1);
	print(STDERR "$ofn: $exact exact, $fuzzy fuzzy, $failed failed matches\n");
	print(STDERR "$ofn: $lbldefd labels defined, $remdefd comments added\n");
}


#======================================================================
# WPC Disassembly Routines
#======================================================================

#----------------------------------------------------------------------
# In-Code References
#
#	- this is done as a first step, before anything else has been
#	  disassembled
#
#	- references are assumed to point to data (no code following)
#
#	- patterns are derived from T2; it is quite likely that other
#	  programmers use additional patterns (e.g. LDX & LDA)
#
#	- patterns
#		1) LDY #<addr> & LDA #<page>	(creates new label if there is none)
#		2) LDX #<addr> & LDB #<page>	(creates new label if there is none)
#		3) LDY #<addr> & !longJSR <ref> (not matched unless label exists)
#		4) LDX #<addr> & !longJSR <ref> (not matched unless label exists)
#
#	- pattern order matters, because LDY has the same opcode as
#	  LDX but with a prefix byte
#		- the test for LDX will match both LDX and LDY; therefore
#		  LDY must come first
#		- however, the opcode for LDY is also equal to a possible 
#		  post-byte of PSH/PUL followed by an LDX; therefore
#		  false positives are possible for LDY, too; this is filtered
#		  by the check for VALID_ROMREF()
#----------------------------------------------------------------------

sub VALID_ROMREF(@)
{
	my($addr) = @_;
	$addr = $Address unless defined($addr);

	return 1 if (BYTE($addr+2)==0xFF && WORD($addr)>=0x8000 && WORD($addr)<=0xFFFF);
	return 1 if (BYTE($addr+2)>=$start_page && BYTE($addr+2)<=0x3D && WORD($addr)>=0x4000 && WORD($addr)<=0x7FFF);
}

sub disassemble_inCode_refs($$$)
{
	my($RPG,$fa,$la) = @_;
##	printf(STDERR "disassemble_inCode_refs(%02X,%04X,%04X)\n",@_);

	for (my($addr)=$fa; $addr<=$la-6; $addr++) {							# pattern 1
		next unless WORD($addr)   == 0x108E &&								# LDY #
					BYTE($addr+4) == 0x86 &&								# LDA #
					BYTE($addr+5)>=$start_page &&
						(BYTE($addr+5)==0xFF && WORD($addr+2)>=0x8000 &&  WORD($addr+2)<=0xFFFF ||
						 BYTE($addr+5)<=0x3D && WORD($addr+2)>=0x4000 &&  WORD($addr+2)<=0x7FFF);

		my($pointee_addr) = WORD($addr+2);
		my($pointee_pg)	  = BYTE($addr+5);
		my($type) 		  = ($pointee_addr>=0x8000) ? 'SYSTEM_YA' : 'GAME_YA';
		my($pointee_lbl)  = sprintf('%02X:UNKNOWN_%s_REF_%04X',$pointee_pg,$type,$pointee_addr);
		select_WPC_RPG($pointee_pg);
		my($usr_lbl) 	  = $LBL[$pointee_addr];
		$pointee_lbl 	  = $usr_lbl if defined($usr_lbl);
		setLabel($pointee_lbl,$pointee_addr,$pointee_pg);
		select_WPC_RPG($RPG);
		$OPA[$addr][0] = "#$pointee_lbl";
		$OPA[$addr+4][0] = "#${pointee_lbl}{ROMpage}";
    }

	for (my($addr)=$fa; $addr<=$la-5; $addr++) {							# pattern 2
		next unless BYTE($addr)   == 0x8E &&								# LDX #
					BYTE($addr+3) == 0xC6 &&								# LDB #
					BYTE($addr+4)>=$start_page &&
						(BYTE($addr+4)==0xFF && WORD($addr+1)>=0x8000 &&  WORD($addr+1)<=0xFFFF ||
						 BYTE($addr+4)<=0x3D && WORD($addr+1)>=0x4000 &&  WORD($addr+1)<=0x7FFF);
#		die if $_cur_RPG == 0x3B && $addr == 0x708E;

		my($pointee_addr) = WORD($addr+1);
		my($pointee_pg)	  = BYTE($addr+4);
		my($type) 		  = ($pointee_addr>=0x8000) ? 'SYSTEM_XB' : 'GAME_XB';
		my($pointee_lbl)  = sprintf('%02X:UNKNOWN_%s_REF_%04X',$pointee_pg,$type,$pointee_addr);
		select_WPC_RPG($pointee_pg);
		my($usr_lbl) 	  = $LBL[$pointee_addr];
		$pointee_lbl 	  = $usr_lbl if defined($usr_lbl);
		setLabel($pointee_lbl,$pointee_addr,$pointee_pg);
		select_WPC_RPG($RPG);
		$OPA[$addr][0] = "#$pointee_lbl";
		$OPA[$addr+3][0] = "#${pointee_lbl}{ROMpage}";
##		die("setLabel($pointee_lbl,$pointee_addr,$pointee_pg); $OP[$addr] @{$OPA[$addr]}") if $_cur_RPG == 0x3B && $addr == 0x708E;
    }

	for (my($addr)=$fa; $addr<=$la-9; $addr++) {							# pattern 3
		next unless WORD($addr)   == 0x108E &&								# LDY #
					BYTE($addr+4) == 0xBD && WORD($addr+5) == $Lbl{longJSR} && # !longJSR
					BYTE($addr+9)>=$start_page &&
						(BYTE($addr+9)==0xFF && WORD($addr+2)>=0x8000 &&  WORD($addr+2)<=0xFFFF ||
						 BYTE($addr+9)<=0x3D && WORD($addr+2)>=0x4000 &&  WORD($addr+2)<=0x7FFF);

		my($pointee_addr) = WORD($addr+2);
		my($pointee_pg)	  = BYTE($addr+9);
		select_WPC_RPG($pointee_pg);
		setLabel($LBL[$pointee_addr],$pointee_addr,$pointee_pg)
			if defined($LBL[$pointee_addr]);
		select_WPC_RPG($RPG);
		$WPC_INTERPAGE_REF[$_cur_RPG][$pointee_addr] = $pointee_pg;			# reference in current pg to pointee_addr in pointee_pg
    }

	for (my($addr)=$fa; $addr<=$la-8; $addr++) {							# pattern 4
		next unless BYTE($addr)   == 0x8E &&								# LDX #
					BYTE($addr+3) == 0xBD && WORD($addr+4) == $Lbl{longJSR} && # !longJSR
					BYTE($addr+8)>=$start_page &&
						(BYTE($addr+8)==0xFF && WORD($addr+1)>=0x8000 &&  WORD($addr+1)<=0xFFFF ||
						 BYTE($addr+8)<=0x3D && WORD($addr+1)>=0x4000 &&  WORD($addr+1)<=0x7FFF);
		my($pointee_addr) = WORD($addr+1);
        next if defined($WPC_INTERPAGE_REF[$_cur_RPG][$pointee_addr]);
        my($pointee_pg)   = BYTE($addr+8);
        select_WPC_RPG($pointee_pg);
		setLabel($LBL[$pointee_addr],$pointee_addr,$pointee_pg)
			if defined($LBL[$pointee_addr]);
		select_WPC_RPG($RPG);
        $WPC_INTERPAGE_REF[$_cur_RPG][$pointee_addr] = $pointee_pg;     	# reference in current pg to pointee_addr in pointee_pg
    }
}

#----------------------------------------------------------------------
# System Calls
#----------------------------------------------------------------------

sub disassemble_syscalls()												# execute this after all syscalls have been defined
{
	for (my($sc)=0; $sc<@SYSCALL; $sc++) {
		select_WPC_RPG(0x3B) if ($SC_NOTE[$sc] == 3);						# NOTE 3: syscall tied to PG#3B
		if ($decoded[$SC_ADDR[$sc]]) {
			my($pg) = ($SC_ADDR[$sc]>=0x4000 && $SC_ADDR[$sc]<0x8000)
					? $_cur_RPG
					: 0xFF;
			overwriteLabel($SYSCALL[$sc],$SC_ADDR[$sc],$pg);
		} else{ 
			disassemble_asm($code_base_indent,$SC_ADDR[$sc]);				# labels already defined
			if ($unclean) {
				print(STDERR "ERROR: $SYSCALL[$sc] did not disassemble cleanly\n")
					if $D711::verbose;
				$unclean = 0;
	        }
	    }
	}
}

#----------------------------------------------------------------------
# CPU Vectors
#----------------------------------------------------------------------

sub disassemble_CPU_vectors()
{
	$Address = 0xFFF0;														# CPU vectors
	insert_divider($Address,'CPU Vectors');
	
	def_code_ptr('RESERVED_vector','RESERVED_handler','CPU Vector Handler');    
	def_code_ptr('SWI3_vector','SWI3_handler','CPU Vector Handler');
	def_code_ptr('SWI2_vector','SWI2_handler','CPU Vector Handler');		    
	def_code_ptr('FIRQ_vector','FIRQ_handler','CPU Vector Handler');
	def_code_ptr('IRQ_vector','IRQ_handler','CPU Vector Handler');
	def_code_ptr('SWI_vector','SWI_handler','CPU Vector Handler');
	def_code_ptr('NMI_vector','NMI_handler','CPU Vector Handler');			    
	def_code_ptr('RST_vector','RST_handler','CPU Vector Handler');              
}

#----------------------------------------------------------------------
# System Pointers
#----------------------------------------------------------------------

sub disassemble_system_pointers()
{
	$Address = 0x8000;
	insert_divider($Address,'Bank Id');
	def_byte_hex('_ROMPG_SYS1_ID');
	
	insert_divider($Address,'Game Event Hooks');							# Game Event Hooks
	for (my($h)=0; $Address<0x812D; $h++) {
		my($taddr) = sprintf('%04X',WORD($Address));
		my($trpg) = sprintf('%02X',BYTE($Address+2));
		my($handler) = defined($Hook[$h])
				  	 ? $Hook[$h] . '_event'
				  	 : "GameHook#${h}_event";
		def_WPC_codeRef($handler,'Game Event Hook');
	}
	
	my($ubyte,$uword);
	
	#------------------------------
	# System Pointers
	#------------------------------

	$Address = 0x81A2; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=SOLCMD_TABLE');
		def_WPC_table(undef,'Solenoid Command Table');
	$Address = 0x81A5; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=SOLCMD_TABLE_ALT');
		def_WPC_table(undef,'Solenoid Command Table1');
	$Address = 0x81AB; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=FLASHER_TABLE_1'); 
		def_WPC_table(undef,'Flasher Command Table');
	$Address = 0x81B0; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=FLASHER_TABLE_2');
		def_WPC_table(undef,'Flasher Command Table');
	$Address = 0x81B3; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=UNKNOWN_BYTELIST_TABLE_%04X',$Address));
		def_WPC_byteList_table(undef,'Bytelist Table');
	$Address = 0x81B6; push(@skipAddr,$Address);					
	$Address = def_WPC_ref('=BITSHIFTER_LAMPMATRIX_LUT');
		def_byteblock_hex(65);
	$Address = 0x81C2; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=BITGROUP_TABLE');
		def_WPC_bitgroup_table(undef,'Bitgroup Table');
	$Address = 0x81C5; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table',1);				# label already defined, follow code
	$Address = 0x81CE; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=FX_TABLE');
		def_WPC_FXtable(undef,'FX Table');
	$Address = 0x81D1; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=UNKNOWN_SYSTEM_TABLE_%04X',$Address));
		def_WPC_unknownSystem_table_1(undef,'Unknown System Table');
	$Address = 0x81EC; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=UNKNOWN_SYSTEM_TABLE_%04X',$Address));
		def_WPC_unknownSystem_table(undef,'Unknown System Table');
	$Address = 0x81EF; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=UNKNOWN_SYSTEM_TABLE_%04X',$Address));
		def_WPC_unknownSystem_table(undef,'FX Table');
	$Address = 0x8216; push(@skipAddr,$Address);
	$Address = def_WPC_ref('SOLCMD_LIST_1');
		def_wordlist_hex(0x0000,undef);
	$Address = 0x8219; push(@skipAddr,$Address);
	$Address = def_WPC_ref('SOLCMD_LIST_2');
		def_wordlist_hex(0x0000,undef);
	$Address = 0x821C; push(@skipAddr,$Address);
	$Address = def_WPC_ref('=AUX_SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table',1)
	        if defined($Address);
	$Address = 0x821F; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=UNKNOWN_BYTE_TABLE_%04X',$Address));
		def_byteblock_hex(64,undef,'Byte Table');

	$Address = 0x8222; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_GAMESTRINGS_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8225; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_GAMESTRINGS_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8228; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_GAMESTRINGS_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x822B; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_SOLENOIDNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x822E; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_SOLENOIDNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8231; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_SOLENOIDNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8234; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_FLASHERNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8237; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_FLASHERNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x823A; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_FLASHERNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x823D; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_SWITCHNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8240; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_SWITCHNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8243; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_SWITCHNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8246; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_LAMPNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8249; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_LAMPNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x824C; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_LAMPNAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x824F; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_GAMEAUDIT_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8252; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_GAMEAUDIT_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8255; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_GAMEAUDIT_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8258; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_SYSAUDIT_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x825B; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_SYSAUDIT_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x825E; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_SYSAUDIT_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8261; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_GAMESETTINGS_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8264; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_GAMESETTINGS_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8267; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_GAMESETTINGS_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x826A; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_SYSSETTINGS_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x826D; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_SYSSETTINGS_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8270; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_SYSSETTINGS_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8273; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_GI_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8276; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_GI_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8279; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_GI_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x827C; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=ENGLISH_TUNE_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x827F; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=GERMAN_TUNE_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');
	$Address = 0x8282; push(@skipAddr,$Address);
	$Address = def_WPC_ref(sprintf('=FRENCH_TUNE_NAMES_%04X',$Address));
		def_WPC_stringTable(undef,'String Table');

	my(@strRef)   = (0x8133,0x8136,0x8139);							# String References
	my(@strRefL)  = ('GAME_NAME','GAME_NUMBER','RELEASE_DATE');

	my(@known)	  = (0x8151,0x8193);
	my(@knownL)	  = ('BALLSEARCH_TIMER','STARTBUTTON_LAMP');

	my(@tblRef) = (0x81A8,0x81B9,0x81BC,0x81BF,0x81C8,0x81CB,
				   0x81D4,0x81D7,0x81DA,0x81DD,0x81E0,0x81E3,0x81E6,
				   0x81E9,0x81F2,0x81F5,0x81F8,0x81FB,
				   0x81FE,0x8201,0x8204,0x8207,0x820A,0x820D,0x8210,
				   0x8213);
	my(@tblLbl) = (0x81A8,'=LAMP_INIT_MEM','=FLAGS_INIT_MEM','=USERDATA_INIT_MEM',
				   0x81C8,0x81CB,0x81D4,0x81D7,'=SCORE_TABLE',0x81DD,
				   0x81E0,0x81E3,0x81E6,0x81E9,0x81F2,0x81F5,0x81F8,0x81FB,
				   0x81FE,0x8201,0x8204,0x8207,0x820A,0x820D,0x8210,
				   0x8213);				   

	my(@ptr) 	  = (0x81AE);										# pointers (not refs)
	
	$Address = 0x812D;
	insert_divider($Address,'System Data Pointers');

	my($i);
	while ($Address < 0x828E) {
		if (isMember($Address,@skipAddr)) {
			$Address += 3;
		} elsif (isMember($Address,@ptr)) {
		    def_word_hex(sprintf('UNKNOWN_SYSTEM_PTR_%04X',$Address));
		} elsif ($i=isMember($Address,@strRef)) {
		    def_WPC_stringRef(sprintf(defined($strRefL[$i]) ? $strRefL[$i] : 'UNKNOWN_SYSTEM_STRREF_%04X',$Address));
		} elsif ($i=isMember($Address,@tblRef)) {
			my($sA) = $Address;
			my($lbl) = numberp($tblLbl[$i]) ? sprintf('UNKNOWN_WPC_TABLE_%04X',$Address)
								     		: $tblLbl[$i];
			$Address = def_WPC_ref($lbl);
		    def_WPC_table(undef,'Unknown System WPC Table');
		    $Address = $sA + 3;
		} elsif ($i=isMember($Address,@known)) {
		    def_WPC_ref($knownL[$i]);
		} else {
			def_WPC_ref(sprintf('UNKNOWN_SYSTEM_PARAM_%04X',$Address));
		}
    }

    while ($Address < 0x8296) {
	    def_ptr_hex_alt(sprintf('^UNKNOWN_SYSTEM_PARAM_%04X',$Address),sprintf('UNKNOWN_SYSTEM_PARAM_%04X',$Address));
	}

	def_ptr_hex('^=STATUS_AREA');
	insert_divider($Address,'System Code');

	$Address = 0xFFEC;													# checksum
    $OP[$Address] = '.DB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$OPA[$Address][0] = '@CHECKSUM_INFO';
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1; 
}

#======================================================================
# WPC Tables
#======================================================================

#----------------------------------------------------------------------
# Lock Table
#----------------------------------------------------------------------

sub disassemble_lock_table()
{
	select_WPC_RPG(0x3B);
	$Address = $Lbl{'3B:BYU=MBD_dataRefs[A]'};
	$Address = $Lbl{'BYU=MBD_dataRefs[A]'} unless defined($Address);	# needed for labelOverrides
	if ($Address =~ m{^([0-9A-F]{2}):}) {
		die("disassemble_lock_table(): wrong page ID $1\n")
			unless ($1 eq '3B');
		$Address = hex($');
    }
	printf(STDERR "WARNING: disassemble_lock_table: syscall BYU=MBD_dataRefs[A] not found ($Address,$Lbl{'BYU=MBD_dataRefs[A]'})\n"),return
		unless numberp($Address) && ($Address>0 && $Address<0x8000);
	my($taddr) = WORD($Address+25);
	my($tpg) = BYTE($Address+28);
	die("$Address,$taddr,$tpg") unless ($tpg>=0x20 && $tpg<=0x3D);
	select_WPC_RPG($tpg);
	$Address = $taddr;
	def_WPC_lockTable('=LOCKTABLE','Multiball Device Table',1);
}

#----------------------------------------------------------------------
# Font Table
#----------------------------------------------------------------------

sub disassemble_font_table()
{
	$Address = 0x8285;
	$Address = def_WPC_ref('=FONTS',undef,1);							# overwrite existing label
	my($nFonts) = (WORD(0x828B)-WORD(0x8285)) / 3;
	def_WPC_fontTable($nFonts,'=FONTS','Font Table');

	$Address = 0x828B;
	$Address = def_WPC_ref('=FONTS_ANCIL',undef,1);
	def_WPC_fontAncilTable('=FONTS_ANCIL','Font Ancillary Table');
}

#----------------------------------------------------------------------
# DMD Table
#----------------------------------------------------------------------

sub disassemble_DMD_table()
{
	$Address = 0x8288;
	my($pg) = BYTE($Address+2);
	$Address = def_WPC_ref('=DMD_ANIMATIONS',undef,1);
	my($opg) = select_WPC_RPG($pg);
	def_WPC_DMDtable('=DMD_ANIMATIONS','DMD Table');
	select_WPC_RPG($opg);
}

#======================================================================
# Post Disassembly Magic
#	- replace JMP *+3 by &skip postfix tag of preceding JSR instruction
#	- make sleep arguments decimal
#	- add empty lines after RTS, JMP, etc.
#	- handle WPC truth values (CC=true) after predicates marked with ?
#======================================================================

sub apply_magic_WPC($$)
{
	my($fa,$la) = @_;

	$systemAliases{_SKIP} = 'JMP .+3';											# _SKIP macro

	if ($la >= 0x8000) {
		die unless ($OP[0xFFEC] eq '.DB' && $OPA[0xFFEC][0] eq '@CHECKSUM_INFO');
		undef($LBL[0xFFEE]); undef($OP[0xFFEE]);
	}

	for (my($addr)=$fa; $addr<=$la-1; $addr++) {
		if ($OP[$addr] eq 'JMP' && $LBL[$addr+3] =~ m{^([0-9A-F]{2}:)?$OPA[$addr][0]$}) {	# 1) JMP *+3
			undef($OP[$addr]);													# generate postfix tag
			push(@{$OPA[$addr-3]},'& _SKIP');
			splice(@{$OPA[$addr]},0,1);
			my($l) = ($LBL[$addr+3] =~ m{^[0-9A-Fa-f]{2}:(.*)$});
			undef($Lbl{$LBL[$addr+3]}),undef($LBL[$addr+3]),undef($Lbl_refs{$l}),
				unless ($Lbl_refs{$l}+$Lbl_refs{$LBL[$addr+3]} > 1);			# (this is a hack; all refs should have prefix)
			undef(@{$OI[$addr]});
			push(@{$OI[$addr-3]},sprintf('7E%04X',$addr+3));
		} elsif ($OP[$addr] eq '!' && $OPA[$addr][0] =~ m{leep$}) {				# 2) decimalize sleep arguments
			$OPA[$addr][1] = hex(substr($OPA[$addr][1],1,4));
		} elsif ($IND[$addr] == $code_base_indent &&							# 3) add extra space after top-level "exit" instructions
				 (isMember($OP[$addr],'RTS','LBRA','JMP') ||
				  ($OP[$addr] eq '!' && $OPA[$addr][0] eq 'exitThread') ||
				  $REM[$addr] eq 'RTS')) {
			insert_empty_line($addr);
		} elsif ($OPA[$addr][0] =~ m{[^\?]\?$}) {								# 4) _IF_true / _IF_false
			my($noa) = $addr + 1;												#	 	execute when last arg ends with a ? but not with ??
			while (!defined($OP[$noa]) ||
				   ($OP[$noa] eq 'JMP' && $LBL[$noa+3] =~ m{^([0-9A-Z]{2}:)?$OPA[$noa][0]$})) {
				$noa++;
				die if $noa > 0xFFFF;
			}
			if    ($OP[$noa] eq '_IF_CC') { $OP[$noa] = '_IF_true'; }			# _IF_true
			elsif ($OP[$noa] eq '__IF_CC') { $OP[$noa] = '__IF_true'; }			# __IF_true
			elsif ($OP[$noa] eq '_IF_CS') { $OP[$noa] = '_IF_false'; }			# _IF_false
			elsif ($OP[$noa] eq '__IF_CS') { $OP[$noa] = '__IF_false'; }		# __IF_false
			elsif ($OP[$noa] eq 'BCC') { $OP[$noa] = 'Btrue'; }					# Btrue
			elsif ($OP[$noa] eq 'BCS') { $OP[$noa] = 'Bfalse'; }				# Bfalse
			elsif ($OP[$noa] eq 'LBCC') { $OP[$noa] = 'LBtrue'; }				# LBtrue
			elsif ($OP[$noa] eq 'LBCS') { $OP[$noa] = 'LBfalse'; }				# LBfalse
		}
	}
}

#----------------------------------------------------------------------
# Init Disassembly System
#----------------------------------------------------------------------

sub init_WPC(@)
{
	my(@linc) = @_;
	
	require 'WPC.API';														# load API after ROM has been loaded but before -i are processed
	while (@linc) {
##		print(STDERR "processing $linc[0]...\n");
		require './' . shift(@linc);
	}

	select_WPC_RPG($start_page,2);
}

#======================================================================
# WPC Disassembly Library (Utilities)
#======================================================================

#----------------------------------------------------------------------
# ROM Paging
#----------------------------------------------------------------------

our($_cur_RPG) = 0xFF;

sub select_WPC_RPG($@)
{
	my($RPG,$caller) = @_;
##	printf(STDERR "select_WPC_RPG(%02X) [caller=$caller, _cur_RPG=%02X]\n",$RPG,$_cur_RPG);
	
	if (!defined($RPG) || !numberp($RPG) || ($RPG != 0xFF && ($RPG<0 || $RPG>0x3D))) {
		if (numberp($RPG)) {
			die(sprintf("select_WPC_RPG(%02X): bad page id\n",$RPG))
		} else {
			die(sprintf("select_WPC_RPG($RPG): bad page id\n"))
		}
	}
		
	return $_cur_RPG if ($RPG == 0xFF || $RPG == $_cur_RPG);
	die unless defined($RPG);
	
	@{$OPPG[$_cur_RPG]} 	 	= @OP[0x4000..0x7FFF];									# swap out active page
	@{$INDPG[$_cur_RPG]}	 	= @IND[0x4000..0x7FFF]; 		    
	@{$TYPEPG[$_cur_RPG]}	 	= @TYPE[0x4000..0x7FFF];		    
	@{$OPAPG[$_cur_RPG]}	 	= @OPA[0x4000..0x7FFF]; 		    
	@{$OIPG[$_cur_RPG]}		 	= @OI[0x4000..0x7FFF]; 		    
	@{$REMPG[$_cur_RPG]}	 	= @REM[0x4000..0x7FFF]; 		    
	@{$EXTRAPG[$_cur_RPG]}	 	= @EXTRA[0x4000..0x7FFF]; 		    
	@{$EXTRA_INDPG[$_cur_RPG]}	= @EXTRA_IND[0x4000..0x7FFF]; 		    
	@{$EXTRA_BEFORE_LABELPG[$_cur_RPG]}	= @EXTRA_BEFORE_LABEL[0x4000..0x7FFF]; 		    
	@{$EXTRA_AFTER_OPPG[$_cur_RPG]}		= @EXTRA_AFTER_OP[0x4000..0x7FFF]; 		    
	@{$LBLPG[$_cur_RPG]}	 	= @LBL[0x4000..0x7FFF]; 		    
	@{$AUTO_LBLPG[$_cur_RPG]} 	= @AUTO_LBL[0x4000..0x7FFF]; 		    
	@{$decodedPG[$_cur_RPG]} 	= @decoded[0x4000..0x7FFF];
	@{$DIVIDERPG[$_cur_RPG]} 	= @DIVIDER[0x4000..0x7FFF];
	@{$ROMPG[$_cur_RPG]}	 	= @ROM[0x4000..0x7FFF]
		unless(@{$ROMPG[$_cur_RPG]});
    
	@OP[0x4000..0x7FFF]			= @{$OPPG[$RPG]};										# swap in new page
	@IND[0x4000..0x7FFF] 		= @{$INDPG[$RPG]};
	@TYPE[0x4000..0x7FFF]		= @{$TYPEPG[$RPG]};
	@OPA[0x4000..0x7FFF] 		= @{$OPAPG[$RPG]};
	@OI[0x4000..0x7FFF] 		= @{$OIPG[$RPG]};
	@REM[0x4000..0x7FFF] 		= @{$REMPG[$RPG]};
	@EXTRA[0x4000..0x7FFF] 		= @{$EXTRAPG[$RPG]};
	@EXTRA_IND[0x4000..0x7FFF]	= @{$EXTRA_INDPG[$RPG]};
	@EXTRA_BEFORE_LABEL[0x4000..0x7FFF] = @{$EXTRA_BEFORE_LABELPG[$RPG]};
	@EXTRA_AFTER_OP[0x4000..0x7FFF] 	= @{$EXTRA_AFTER_OPPG[$RPG]};
	@LBL[0x4000..0x7FFF] 		= @{$LBLPG[$RPG]};
	@AUTO_LBL[0x4000..0x7FFF] 	= @{$AUTO_LBLPG[$RPG]};
	@decoded[0x4000..0x7FFF] 	= @{$decodedPG[$RPG]};
	@DIVIDER[0x4000..0x7FFF] 	= @{$DIVIDERPG[$RPG]};
	if (@{$ROMPG[$RPG]}) {
		@ROM[0x4000..0x7FFF]	= @{$ROMPG[$RPG]};										# copy from page buffer
	} else {
		load_ROM($ARGV[0],0x4000,$RPG,16);												# load from file
	}
	
	my($oRPG) = $_cur_RPG;
    $_cur_RPG = $RPG;

	unless ($decoded[0x4000]) {															# decode page id first time a page is referenced
		my($oA) = $Address;
		$Address = 0x4000;
		def_byte_hex('_ROMPG_ID',sprintf('ROM PAGE %02X',$_cur_RPG));
		push(@{$OI[0x4000]},sprintf('%02X',BYTE(0x4000)));								# this should eventually move into def_byte_hex()
		$Address = $oA;
	}
	
    return $oRPG;
}

#======================================================================
# WPC Tables
#	- header:
#		- number of entries (word)
#		- number of bytes per entry (byte)
#======================================================================

#----------------------------------------------------------------------
# Generic Table
#----------------------------------------------------------------------

sub def_WPC_table($@)
{
	my($lbl,$divider_label) = @_;
#	print(STDERR "def_WPC_table(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of table rows, bytes per row' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	my($TSA) = $Address;												# Table Start Address

	if ($cols == 2) {													# check for list table
		my($okay) = !$decoded[WORD($TSA)] && (WORD($TSA) == $TSA+2*$rows);
		for (my($r)=1; $okay && $r<$rows; $r++) {
			$okay = (WORD($TSA+2*$r) >= WORD($TSA)) &&
					(WORD($TSA+2*$r)-WORD($TSA) <= 50*$rows);
		}
		if ($okay) {													# valid list table
			my($lbase) = defined($lbl) ? $lbl : $LBL[$TSA-3];
			$lbase = $' if ($lbase =~ m{^[0-9A-Fa-f]{2}:});
			for (my($r)=0; $r<$rows; $r++) {
				my($opaddr) = $Address;
				$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
				$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;
				$OP[$opaddr] = '.DW';
				push(@{$OPA[$opaddr]},sprintf('$%04X',WORD($Address)));
				$decoded[$Address++] = $decoded[$Address++] = 1;

				my($sA) = $Address;
				$Address = WORD($TSA+2*$r);
				def_byte_hex(sprintf('%s_%d',$lbase,$r));
				$Address = $sA;
			}
			return;
		}
	}

	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;
		if ($cols%2 == 0) {
			$OP[$opaddr] = '.DW';
			for (my($c)=0; $c<$cols; $c+=2) {
				push(@{$OPA[$opaddr]},sprintf('$%04X!',WORD($Address)));
				$decoded[$Address++] = $decoded[$Address++] = 1;
			}
		} else {
			$OP[$opaddr] = '.DB';
			for (my($c)=0; $c<$cols; $c++) {
				push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
			}
		}
	}
##	insert_empty_line($Address-11);
}

#----------------------------------------------------------------------
# Bytelist Table
#----------------------------------------------------------------------

sub def_WPC_byteList_table($@)
{
	my($lbl,$divider_label) = @_;
#	print(STDERR "def_WPC_byteList_table(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of table rows, bytes per row' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	my($TSA) = $Address;												# Table Start Address
	die unless $cols == 2;

	my($lbase) = defined($lbl) ? $lbl : $LBL[$TSA-3];
	$lbase = $' if ($lbase =~ m{^[0-9A-Fa-f]{2}:});
	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;
		$OP[$opaddr] = '.DW';
		push(@{$OPA[$opaddr]},sprintf('$%04X',WORD($Address)));
		$decoded[$Address++] = $decoded[$Address++] = 1;

		my($sA) = $Address;
		$Address = WORD($TSA+2*$r);
		def_bytelist_hex(0,sprintf('%s_%d',$lbase,$r));
		$Address = $sA;
	}
    return;

##	insert_empty_line($Address-2);
}

#----------------------------------------------------------------------
# Unknown System Tables with code refs
#----------------------------------------------------------------------

sub def_WPC_unknownSystem_table($@)
{
	my($lbl,$divider_label) = @_;
##	printf(STDERR "def_WPC_unknownSystem_table(@_) @%02X:%04X\n",$_cur_RPG,$Address);

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of table rows, bytes per row' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	my($TSA) = $Address;												# Table Start Address
	die unless $cols == 12;

	my($lbase) = defined($lbl) ? $lbl : $LBL[$TSA-3];
	$lbase = $' if ($lbase =~ m{^[0-9A-Fa-f]{2}:});
	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;
		$OP[$opaddr] = '.DB';
		for (my($i)=0; $i<6; $i++) {
			push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address)));
			$decoded[$Address++] = 1;
		}
		if (VALID_ROMREF()) {
			my($opaddr) = $Address;
			$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
	        $OP[$opaddr] = '.DR';
			push(@{$OPA[$opaddr]},label_address(WORD($Address),sprintf('%s_%d_1',$lbase,$r)));
			push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address+2)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

			my($sA) = $Address;
			my($sP) = $_cur_RPG;
			$Address = WORD($TSA+12*$r+6);
			if ($Address < 0x8000) {
				select_WPC_RPG(BYTE($TSA+12*$r+8));
			}
			def_word_hex(sprintf('%s_%d_1',$lbase,$r));
			select_WPC_RPG($sP);
	        $Address = $sA;

		} else {
			for (my($i)=0; $i<3; $i++) {
				push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address)));
				$decoded[$Address++] = 1;
	        }
	    }
		die unless VALID_ROMREF();
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
        $OP[$opaddr] = '.DR';
		push(@{$OPA[$opaddr]},label_address(WORD($Address),sprintf('%s_%d_2',$lbase,$r)));
		push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address+2)));
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		my($sA) = $Address;
		my($sP) = $_cur_RPG;
		$Address = WORD($TSA+12*$r+9);
		if ($Address < 0x8000) {
			select_WPC_RPG(BYTE($TSA+12*$r+11));
		}
##		printf(STDERR "@%02X:%04X: def_code('%s_%d_2')\n",$_cur_RPG,$Address,$lbase,$r);
		def_code(sprintf('%s_%d_2',$lbase,$r));
		select_WPC_RPG($sP);
		$Address = $sA;
	}
    return;

##	insert_empty_line($Address-2);
}

sub def_WPC_unknownSystem_table_1($@)
{
	my($lbl,$divider_label) = @_;
##	printf(STDERR "def_WPC_unknownSystem_table_1(@_) @%02X:%04X\n",$_cur_RPG,$Address);

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of table rows, bytes per row' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	my($TSA) = $Address;												# Table Start Address
	die unless $cols == 5;

	my($lbase) = defined($lbl) ? $lbl : $LBL[$TSA-3];
	$lbase = $' if ($lbase =~ m{^[0-9A-Fa-f]{2}:});
	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;
		$OP[$opaddr] = '.DB';
		for (my($i)=0; $i<2; $i++) {
			push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address)));
			$decoded[$Address++] = 1;
		}
		if (VALID_ROMREF()) {
			my($opaddr) = $Address;
			$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
	        $OP[$opaddr] = '.DR';
			push(@{$OPA[$opaddr]},label_address(WORD($Address),sprintf('%s_%d_1',$lbase,$r)));
			push(@{$OPA[$opaddr]},sprintf('$%02X',BYTE($Address+2)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

			my($sA) = $Address;
			my($sP) = $_cur_RPG;
			$Address = WORD($TSA+5*$r+2);
			
			select_WPC_RPG(BYTE($TSA+5*$r+4))
				if ($Address < 0x8000);
##			printf(STDERR "@%02X:%04X: def_word_hex('%s_%d_1')\n",$_cur_RPG,$Address,$lbase,$r);
##			def_word_hex(sprintf('%s_%d_1',$lbase,$r));
			def_code(sprintf('%s_%d_1',$lbase,$r));
			select_WPC_RPG($sP);
	        $Address = $sA;
		} else {
			for (my($i)=0; $i<3; $i++) {
				push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address)));
				$decoded[$Address++] = 1;
	        }
	    }
		my($sA) = $Address;
		my($sP) = $_cur_RPG;
		$Address = WORD($TSA+5*$r+2);
		select_WPC_RPG(BYTE($TSA+5*$r+4)) if ($Address < 0x8000);
##		printf(STDERR "@%02X:%04X: def_code('%s_%d_2')\n",$_cur_RPG,$Address,$lbase,$r);
		def_code(sprintf('%s_%d_2',$lbase,$r));
		select_WPC_RPG($sP);
		$Address = $sA;
	}
    return;

}

#----------------------------------------------------------------------
# String Table
#----------------------------------------------------------------------

sub def_WPC_stringTable($@)
{
	my($lbl,$divider_label) = @_;
#	print(STDERR "def_WPC_stringTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of table rows, bytes per row' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	my($TSA) = $Address;												# Table Start Address
	die unless $cols == 2;

	my($lbase) = defined($lbl) ? $lbl : $LBL[$TSA-3];
	$lbase = $' if ($lbase =~ m{^[0-9A-Fa-f]{2}:});
	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;
		$OP[$opaddr] = '.DW';
		push(@{$OPA[$opaddr]},sprintf('$%04X',WORD($Address)));
		$decoded[$Address++] = $decoded[$Address++] = 1;

		my($sA) = $Address;
		$Address = WORD($TSA+2*$r);
		def_WPC_string(sprintf('%s_%d',$lbase,$r));
		$Address = $sA;
	}
    return;
}

#----------------------------------------------------------------------
# Bitgroup Table
#----------------------------------------------------------------------

sub dasm_bitgroup_def($$$)
{
	my($lbl,$opa,$a) = @_;

	if (BYTE($a) == 0xFA) { 												# def (Range|??? ...)
		push(@{$OPA[$opa]},'$FA'); $decoded[$a++] = 1;
		while (BYTE($a) != 0xFA) {
			($opa,$a) = dasm_bitgroup_def($lbl,$opa,$a);
		}
		push(@{$OPA[$opa]},'$FA'); $decoded[$a++] = 1;
		return ($opa,$a);
	}

	if (BYTE($a) == 0x85) { 												# Range (from lamp, to lamp)
		push(@{$OPA[$opa]},'$85'); $decoded[$a++] = 1;
		push(@{$OPA[$opa]},sprintf("Lamp#%d",BYTE($a))); $decoded[$a++] = 1;
		push(@{$OPA[$opa]},sprintf("Lamp#%d",BYTE($a))); $decoded[$a++] = 1;
		die unless BYTE($a) == 0x85;
		push(@{$OPA[$opa]},'$85'); $decoded[$a++] = 1;
		return ($opa,$a);
	}
		    
	if (BYTE($a) == 0x81) { 												# Bitgroup (single byte)
		push(@{$OPA[$opa]},'$81'); $decoded[$a++] = 1;
		push(@{$OPA[$opa]},sprintf("Bitgroup#%02X",BYTE($a))); $decoded[$a++] = 1;
		die unless BYTE($a) == 0x81;
		push(@{$OPA[$opa]},'$81'); $decoded[$a++] = 1;
		return ($opa,$a);
	}

	if (BYTE($a) == 0xF8) { 												# ??? (followed by address, bytes, and F9)
		$opa = $a;
		$IND[$opa] = $code_base_indent; $TYPE[$opa] =  $CodeType_data;
		$OP[$opa] = '.DBWB';
		push(@{$OPA[$opa]},'$F8'); $decoded[$a++] = 1;
		my($trga) = WORD($a);
		setLabel(sprintf("${lbl}_%04X",$trga),$trga);
		push(@{$OPA[$opa]},sprintf('$%04X',WORD($a)));
		$decoded[$a++] = $decoded[$a++] = 1;
		while (BYTE($a) != 0xF9) {
			push(@{$OPA[$opa]},sprintf('$%02X!',BYTE($a))); $decoded[$a++] = 1;
		}
		push(@{$OPA[$opa]},'$F9'); $decoded[$a++] = 1;
		return ($opa,$a);
	}
		    
	if (BYTE($a) >= 0x80) {
		push(@{$OPA[$opa]},sprintf('$%02X!',BYTE($a))); $decoded[$a++] = 1;
	} else {
		push(@{$OPA[$opa]},sprintf("Lamp#%d",BYTE($a))); $decoded[$a++] = 1;
	}
	return ($opa,$a);
}


sub def_WPC_bitgroup_table(@)
{
	my($lbl,$divider_label) = @_;
#	print(STDERR "def_bitgroup_table(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]); 										    
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 							    
		setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	die("Invalid number of bytes <$cols> per Bitgroup table entry\n") unless ($cols == 2);
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of bitgroups, bytes per bitgroup' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =	$CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r) if $r%10==0;

		$OP[$opaddr] = '.DW';
		my($ta) = WORD($Address);
		push(@{$OPA[$opaddr]},sprintf('$%04X',$ta));
		$decoded[$Address++] = $decoded[$Address++] = 1;

		my($tl) = $LBL[$ta];
		$tl = sprintf('.Bitgroup#%02X',$r) unless defined($tl);
		setLabel($tl,$ta);

		$IND[$ta] = $code_base_indent; $TYPE[$ta] =	$CodeType_data;
		$OP[$ta] = '.DWB';
		my($nextDta) = WORD($ta);
		push(@{$OPA[$ta]},sprintf('$%04X',WORD($ta)));
		$decoded[$ta] = $decoded[$ta+1] = 1;

		dasm_bitgroup_def($tl,$ta,$ta+2);
	}
	insert_empty_line($Address);
}   

#----------------------------------------------------------------------
# Lock Table / Multiball Device Table
#----------------------------------------------------------------------

sub def_WPC_lockTable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_lockTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of locks, bytes per lock' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($lck)=0; $lck<$rows; $lck++) {
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DW';
		my($daddr) = WORD($Address);
			my($dlbl) = $LBL[$daddr];
			$dlbl = sprintf('Lock#%02X_data',$lck) unless defined($dlbl);
		    setLabel($dlbl,$daddr);
		push(@{$OPA[$Address]},sprintf('$%04X',$daddr));
		$REM[$Address] = 'pointer to lock definition data (4-10 bytes)' if !defined($REM[$Address]) && $lck==0;
	    $decoded[$Address++] = $decoded[$Address++] = 1;

	    my($sa) = $Address;
	    $Address = $daddr;

		my($taddr,$trpg);
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$REM[$Address] = sprintf('Lock#%02X',$lck) if !defined($REM[$Address]);
		$OP[$Address] = '.DB';
		push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address)));
		$decoded[$Address++] = 1;
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DR';
		push(@{$OPA[$Address]},sprintf('$%04X',$taddr=WORD($Address)));
		push(@{$OPA[$Address]},sprintf('$%02X',$trpg=BYTE($Address+2)));
	    $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
		if ($lck == 1) {
		  	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
			$OP[$Address] = '.DWB';
			push(@{$OPA[$Address]},sprintf('$%04X',WORD($Address)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+2)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+3)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+4)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+5)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+6)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = 1;
		} elsif ($lck > 1) {
		  	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
			$OP[$Address] = '.DB';
			push(@{$OPA[$Address]},sprintf('Switch#%02X',BYTE($Address)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+1)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+2)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+3)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+4)));
			push(@{$OPA[$Address]},sprintf('$%02X!',BYTE($Address+5)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
		}

	    if ($follow_code) {
	    	my($srpg) = select_WPC_RPG($trpg,8);
	    	insert_divider($taddr,'Lock Event Handler');
			my($tlbl) = $LBL[$taddr];
			$tlbl = sprintf('Lock#%02X_handler',$lck) unless defined($tlbl);
		    setLabel($tlbl,$taddr);
			disassemble_asm($code_base_indent,$taddr,$tlbl,undef,$follow_code);
			select_WPC_RPG($srpg,9);
	    }

	    $Address = $sa;
    }
    insert_empty_line($Address-2);
}

#----------------------------------------------------------------------
# Font Table / Sprite Table
#----------------------------------------------------------------------

sub def_WPC_fontTable(@)
{
	my($nFonts,$lbl,$divider_label) = @_;
##	print(STDERR "def_WPC_fontTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	for (my($fnt)=0; $fnt<$nFonts; $fnt++) {
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DR';
		my($daddr) = WORD($Address);
		my($dpg) = BYTE($Address+2);
			my($opg) = select_WPC_RPG($dpg);
			my($dlbl) = $LBL[$daddr];
			$dlbl = sprintf('%02X:Font#%02X_data',BYTE($Address+2),$fnt) unless defined($dlbl);
		    setLabel($dlbl,$daddr);
		    select_WPC_RPG($opg);
		push(@{$OPA[$Address]},sprintf('$%04X',$daddr));
		push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
		$REM[$Address] = 'pointer to font/sprite definition data' if !defined($REM[$Address]) && $fnt==0;
	    $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
    }

    insert_empty_line($Address-3);
}

sub def_WPC_fontAncilTable(@)
{
	my($lbl,$divider_label) = @_;
##	print(STDERR "def_WPC_fontAncilTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	for (my($fnt)=0; WORD($Address)>=0x4000 && WORD($Address)<0x8000 &&
					 (BYTE($Address+2)==0xFF || (BYTE($Address+2)>=$start_page&&BYTE($Address+2)<=0x3D)); $fnt++) {
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DR';
		my($daddr) = WORD($Address);
		my($dpg) = BYTE($Address+2);
			my($opg) = select_WPC_RPG($dpg);
			my($dlbl) = $LBL[$daddr];
			$dlbl = sprintf('%02X:FontAncil#%02X_data',BYTE($Address+2),$fnt) unless defined($dlbl);
		    setLabel($dlbl,$daddr);
		    unless ($decoded[$daddr]) {
				my($oa) = $Address;
				$Address = $daddr;
				my($pa) = def_ptr_hex();
				setLabel(sprintf('FontAncil#%02X_ptr',$fnt),$pa)
					unless defined($LBL[$pa]);
				def_byteblock_hex(2,undef,undef,'unknown length');
	            $Address = $oa;
	        }
		    select_WPC_RPG($opg);
		push(@{$OPA[$Address]},sprintf('$%04X',$daddr));
		push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
		$REM[$Address] = 'pointer to font/sprite definition data' if !defined($REM[$Address]) && $fnt==0;
	    $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
    }

    insert_empty_line($Address-3);
}

#----------------------------------------------------------------------
# DMD Table
#----------------------------------------------------------------------

sub def_WPC_DMDtable(@)
{
	my($lbl,$divider_label) = @_;
##	print(STDERR "def_WPC_DMDtable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	for (my($DMD)=0; WORD($Address)!=0xFFFF; $DMD++) {
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DR';
		my($daddr) = WORD($Address);
		my($dpg) = BYTE($Address+2);
			my($opg) = select_WPC_RPG($dpg);
			my($dlbl) = $LBL[$daddr];
			$dlbl = sprintf('%02X:DMD#%02X_data',BYTE($Address+2),$DMD) unless defined($dlbl);
		    setLabel($dlbl,$daddr);
		    select_WPC_RPG($opg);
		push(@{$OPA[$Address]},sprintf('$%04X',$daddr));
		push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
		$REM[$Address] = 'pointer to DMD animation data' if !defined($REM[$Address]) && $DMD==0;
	    $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
    }

    insert_empty_line($Address-3);
}

#----------------------------------------------------------------------
# Switch Table
#----------------------------------------------------------------------

sub def_WPC_switchTable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_switchTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of switches, bytes per switch' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($sw)=0; $sw<$rows; $sw++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
#		$OP[$opaddr] = '.DBBRB';
		$OP[$opaddr] = '.DB';
		$REM[$opaddr] = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;

		$opaddr = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DR';
		my($ta,$tp) = (WORD($Address),BYTE($Address+2));
		my($swn) = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},label_address($ta,$swn.'_handler',1));						# suppress address suffix in label
		push(@{$OPA[$opaddr]},sprintf('$%02X',$tp));
		WPC_codeRef($swn.'_handler',"Switch Handler ($swn)",$follow_code);
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		$opaddr = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DB';
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	}
    insert_empty_line($Address-11);
}   
		    
#----------------------------------------------------------------------
# FX Table
#----------------------------------------------------------------------

sub def_WPC_FXtable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_FXTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($LampFX)=1; $LampFX<=$rows; $LampFX++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = defined($LampFX[$LampFX]) ? $LampFX[$LampFX] : sprintf('LampFX#%02X',$LampFX);
		$OP[$opaddr] = '.DB';
		for (my($i)=0; $i<7; $i++) {
			push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	    }

		$opaddr += 7;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DR';
		my($ta,$tp) = (WORD($Address),BYTE($Address+2));
		my($LampFXn) = defined($LampFX[$LampFX]) ? $LampFX[$LampFX] : sprintf('LampFX#%02X',$LampFX);
		push(@{$OPA[$opaddr]},label_address($ta,$LampFXn.'_handler',1));						# suppress address suffix in label
		push(@{$OPA[$opaddr]},sprintf('$%02X',$tp));
		WPC_codeRef($LampFXn.'_handler',"FX Handler ($LampFXn)",$follow_code);
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		$opaddr += 3;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DB';
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	}
    insert_empty_line($Address);
}   
		    
#======================================================================
# References
#	- loads RPG
#	- needs to deal with partially decoded references
#======================================================================

sub def_WPC_ref($@)														# DOES NOT MAINTAIN RPG
{																			
	my($pointee_lbl,$rem,$overwrite_existing_label) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die(sprintf("def_WPC_ref(%04X,$pointee_lbl): addresses below 0x8000 not supported (implementation restriction)",$Address))
    	unless ($Address >= 0x8000);

	my($pointee_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
##	printf(STDERR "%04X: def_WPC_ref($pointee_lbl) -> %02X:%04X\n",$Address,$RPG,$pointee_addr);
	select_WPC_RPG($RPG,3)
		unless ($RPG == 0x00);																# NULL ref

	if (($decoded[$Address] || $decoded[$Address+2]) &&										# already decoded
		$OP[$Address] ne '.DR') {
##		printf(STDERR "\t%04X: def_WPC_ref($pointee_lbl): munging pre-existing analysis $OP[$Address]/$OP[$Address+2]\n",$Address);
		if ($decoded[$Address]) {
			die($OP[$Address]) unless ($OP[$Address] eq '.DW');
		}
		if ($decoded[$Address+2]) {
 			die unless ($OP[$Address+2] eq '.DB');
			undef($OP[$Address+2]);
			undef(@{$OPA[$Address+2]});
			die unless defined($AUTO_LBL[$Address+2]);
        }
    }

	die,$pointee_lbl = $` if ($pointee_lbl =~ m{\[[0-9A-F]{2}\]$});            				# remove previous RPG if there is one
	setLabel("^$pointee_lbl",$Address);
	undef($LBL[$Address+2]);
	$AUTO_LBL[$Address+2] = sprintf("^$pointee_lbl+2");
##	print(STDERR "AUTO_LBL[$Address+2] = $AUTO_LBL[$Address+2] <$LBL[$Address+2]>\n");
	
	$OP[$Address] = '.DR'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	if ($pointee_addr == 0x0000) {															# FH.WPC $FF:821C
		$OPA[$Address][0] = '$0000';
		$OPA[$Address][1] = '$00';
	} else {
		unless ($overwrite_existing_label) {
			my($usr_lbl) = $LBL[$pointee_addr];
			$pointee_lbl = $usr_lbl if defined($usr_lbl);
		}
		setLabel($pointee_lbl,$pointee_addr);
		$OPA[$Address][0] = $LBL[$pointee_addr]; #$pointee_lbl; 
		$OPA[$Address][1] = sprintf('$%02X',$RPG);
    }
##  printf(STDERR "\t%04X: $OP[$Address] @{$OPA[$Address]} [setLabel($pointee_lbl,%04X);]\n",$Address,$pointee_addr);

	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	$Address += 3;

	return $pointee_addr;
}

sub def_WPC_codeRef_nonPrime($@)															# MAINTAINS RPG, WORKS IN NON PRIME RE
{																			
	my($pointee_lbl,$rem,$overwrite_existing_label) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);

	my($pointee_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);

	if (($decoded[$Address] || $decoded[$Address+2]) &&										# already decoded
		$OP[$Address] ne '.DR') {
		if ($decoded[$Address]) {
			die($OP[$Address]) unless ($OP[$Address] eq '.DW');
		}
		if ($decoded[$Address+2]) {
 			die unless ($OP[$Address+2] eq '.DB');
			undef($OP[$Address+2]);
			undef(@{$OPA[$Address+2]});
			die unless defined($AUTO_LBL[$Address+2]);
        }
    }

	$OP[$Address] = '.DR'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	if ($pointee_addr == 0x0000) {															# FH.WPC $FF:821C
		$OPA[$Address][0] = '$0000';
		$OPA[$Address][1] = '$00';
	} else {
		my($orpg) = select_WPC_RPG($RPG);
		unless ($overwrite_existing_label) {
			my($usr_lbl) = $LBL[$pointee_addr];
			$pointee_lbl = $usr_lbl if defined($usr_lbl);
		}
		setLabel($pointee_lbl,$pointee_addr);
		disassemble_asm($code_base_indent,$pointee_addr,$pointee_lbl,undef,1);
		select_WPC_RPG($orpg);
		$pointee_lbl = $' if ($pointee_lbl =~ m{^[0-9A-Fa-f]{2}:});            				# remove previous RPG if there is one
		$OPA[$Address][0] = sprintf("%02X:$pointee_lbl",$RPG); 
		$OPA[$Address][1] = sprintf('$%02X',$RPG);
    }

	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	$Address += 3;
}

#======================================================================
# Strings
#======================================================================

sub decode_WPC_STR_char($)
{
	my($c) = BYTE($_[0]);

	if ($c == 92) {																# escape
		return '\\\\';
	} elsif ($c >= 32 && $c < 127) {
		return sprintf('%c',$c);												# printable ASCII
	} else {
		return sprintf('\\%02X',$c);											# non-printable
	}
}

sub def_WPC_string(@)
{
	my($lbl,$divider_label,$rem,$maxlen) = @_;
	$maxlen = 9e99 unless defined($maxlen);

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	insert_divider($Address,$divider_label);
	$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	setLabel($lbl,$Address);
    return unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);

	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$OP[$Address] = ($maxlen < 9e99) ? sprintf('.STR%d',$maxlen) : '.STR';
	my($o);
	$OPA[$Address][0] = "'";
	for ($o=0; BYTE($Address+$o)!=0 && $o<$maxlen; $o++) {
		$OPA[$Address][0] .= decode_WPC_STR_char($Address+$o);
		$decoded[$Address+$o] = 1;
	}
	$decoded[$Address+$o] = 1;
	$OPA[$Address][0] .= "'";
	$Address += $o;
}   
		    
sub def_WPC_stringRef($@)														# DOES NOT MAINTAIN RPG
{																			
	my($str_lbl,$divider_title,$rem) = @_;

	my($str_addr) = def_WPC_ref($str_lbl,$rem);
	my($oAddr) = $Address;
	$Address = $str_addr;
	def_WPC_string($str_lbl,$divider_title);
	$Address = $oAddr;
}

#======================================================================
# Code
#======================================================================

sub WPC_codeRef($@)															# label and disassemble 3-byte code reference
{
	my($code_lbl,$divider_title,$follow_code) = @_;							# (optional) code_label page prefix ignored

	my($code_addr) = WORD($Address);										# extract address components and swap-in correct ROM page
	my($RPG) = BYTE($Address+2);
	my($orpg) = select_WPC_RPG($RPG,5);

	label_address($code_addr,$code_lbl,1);									# label this address (without _addr suffix)

	my($usr_lbl) = $LBL[$code_addr];										# set label, using pre-existing (external) label when available
	$code_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($code_lbl,$code_addr);

	disassemble_asm($code_base_indent,$code_addr,$code_lbl,$divider_title,$follow_code);
#	die if $unclean;														# disassemble referenced code

	select_WPC_RPG($orpg,6);												# return to original ROM page
}


sub def_WPC_codeRef($@)
{
	my($code_lbl,$divider_title,$rem) = @_;

	my($ra) = $Address;
	def_WPC_ref($code_lbl,$rem);
	my($na) = $Address;

	$Address = $ra;
	WPC_codeRef($code_lbl,$divider_title,1);

	$Address = $na;
}


#======================================================================
# Gap Warnings
#======================================================================

sub produce_gap_warnings($$)
{
	my($fa,$la) = @_;

	my($lwa);
	for (my($a)=$fa; $a<=$la; $a++) {
		next if WORD($a)==0xFFFF && BYTE($a+2)==0xFF;
##		next if $OP[$a] eq '.DR';
		if ($decoded[$a]) {												# potential data reference
			my($oa) = $a;
			$oa-- while !defined($OP[$oa]);
			die(sprintf("%02X:%04X ($OP[$oa]/$TYPE[$oa])",$_cur_RPG,$oa)) unless defined($TYPE[$oa]);
			next unless $TYPE[$oa] == $CodeType_data;					# not a data reference
			next if $OP[$oa] =~ m{^\.STR};								# ignore potential refs in strings
			next if $OP[$oa] =~ m{^\.DR};								# ignore potential refs in strings
		} else {
			next if $decoded[$a+1] || $decoded[$a+2];					# ignore partially decoded ref candidates
		}
		my($pg) = ($a>=0x8000) ? 0xFF : $_cur_RPG;
    	my($ta) = WORD($a);
    	my($tp) = BYTE($a+2);
		if (($tp==0xFF 					   && $ta>=0x8000 && $ta<=0xFFFF) ||
		    ($tp>=$start_page && $tp<=0x3D && $ta>=0x4000 && $ta<=0x7FFF)) {
		    	my($lbl);
		    	if ($tp==0xFF || $ta>=0x8000) {
		    		$lbl = $LBL[$ta];
		    		next if !defined($lbl) && $decoded[$ta];
		    	} else {
		    		my($oRPG) = select_WPC_RPG($tp);
		    		$lbl = $LBL[$ta];
		    		if (!defined($lbl) && ($decoded[$ta] || WORD($ta)==0xFFFF)) {
		    			select_WPC_RPG($oRPG);
						next;
					}
		    		select_WPC_RPG($oRPG);
		    	}
		    	$lbl = sprintf('%02X:%04X',$tp,$ta)
		    		unless defined($lbl);
		    	my($tl) = ($decoded[$a]) ? 'data' : 'gap';
		    	if ($a-$lwa < 30) {
			   		printf(STDERR "<%02X:%04X> $tl reference to $lbl (+ %d)\n",
			   			$pg,$a,$a-$lwa);
		    	} else {
			   		printf(STDERR "<%02X:%04X> $tl reference to $lbl\n",
			   			$pg,$a);
			   	}
			   	$lwa = $a;
		}
	}
}


#======================================================================
# Utilities
#	- used in .defs files to define game-specific ids
#	- .def file is loaded during init_WPC()
#======================================================================

$Switch[0] = 'SW_UNUSED';

sub defSwitch($$)
{
	my($no,$name) = @_;

	die("defSwitch: invalid switch number $no\n")
		unless ($no>=1 && $no<=64);
	$Switch[$no] = $name;
}

sub defLamp($$)
{
	my($no,$name) = @_;

	die("defLamp: invalid lamp number $no\n")
		unless ($no>0 && $no<=64);
	$Lamp[$no] = $name;
}

sub defGroup($$)
{
	my($no,$name) = @_;

	die("defGroup: invalid group number $no\n")
		unless ($no>=0 && $no<=255);
	$BitGroup[$no] = $name;
}

sub defFlag($$)
{
	my($no,$name) = @_;

	die("defFlag: invalid flag number $no\n")
		unless ($no>0 && $no<=0x80);
	$Flag[$no] = $name;
}

if (0) {
sub defSolenoid($$)
{
	my($no,$name) = @_;

	die("defSolenoid: invalid solenoid number $no\n")
		unless ($no>0 && $no<=0x65);
	my($no,$name) = @_;
	$Sol[$no] = $name;
}
}

sub defSolCmd($$)
{
	my($no,$name) = @_;

	die("defSolCmd: invalid solenoid command number $no\n")
		unless ($no>=0 && $no<=0xFF);
	my($no,$name) = @_;
	$SolCmd[$no] = $name;
}

sub defLabel($$$)
{
	my($pg,$addr,$lbl) = @_;

	select_WPC_RPG($pg,7);
	define_label($lbl,$addr);
}

sub defAdjustment($$)
{
	my($no,$name) = @_;

	die("defAdjustment: invalid adjustment number $no\n")
		unless ($no>0 && $no<=0xFFFF);
	$Adj[$no] = $name;
}

sub defAudit($$)
{
	my($no,$name) = @_;

	die("defAudit: invalid audit number $no\n")
		unless ($no>=0 && $no<65);
	$Audit[$no] = $name;
}

sub defThread($$)
{
	my($no,$name) = @_;

	die("defThread: invalid thread id\n")
		unless ($no>0 && $no<=0xFFFF);
	$Thread[$no] = $name;
}

sub defDMD($$)
{
	my($no,$name) = @_;

	die("defDMD: invalid DMD animation\n")
		unless ($no>0 && $no<=0xFFFF);
	$DMD[$no] = $name;
}

sub defLampFX($$)
{
	my($no,$name) = @_;

	die("defLampFX: invalid lampFX number\n")
		unless ($no>0 && $no<=0xFF);
	$LampFX[$no] = $name;
}

sub defSound($$)
{
	my($no,$name) = @_;

	die("defSound: invalid Sound number\n")
		unless ($no>0 && $no<=0xFFFF);
	$Sound[$no] = $name;
}

#----------------------------------------------------------------------
#	Define System Calls
#
# 	$note ARGUMENTS:
#		1: routine does not return
#----------------------------------------------------------------------

sub define_syscall($$@)
{
	my($lbl,$addr,$args,$note) = @_;
	$args = '' unless defined($args);

	my($pg,$nm) = ($lbl =~ m{^([0-9A-Fa-f]{2}):(.*)$});
	select_WPC_RPG(hex($pg))
		if defined($pg);
	define_label($lbl,$addr);
	
	push(@SYSCALL,$lbl);
	$SC_ADDR[$#SYSCALL] = $addr;
	$SC_ARGS[$#SYSCALL] = $args;
	$SC_NOTE[$#SYSCALL] = $note;
}

1; 																# return true

