#======================================================================
#                    D 7 1 1 . W P C 
#                    doc: Thu Jul 18 06:34:49 2024
#                    dlm: Wed Jun 25 17:08:37 2025
#                    (c) 2024 idealjoker@mailbox.org
#                    uE-Info: 102 39 NIL 0 0 72 10 2 4 NIL ofnI
#======================================================================

# WPC Disassembly 

# HISTORY:
#	Jul 18, 2024: - created; WMS CPU vectors disassemble correctly
#	Aug  9, 2024: - continued
#	Aug 10, 2024: - added support for ROM pages
#	Aug 11, 2024: - System Call Pointers disassemble correctly
#				  - BUG: WMS CPU vectors no longer disassemble correctly
#	Aug 12, 2024: - added support for system strings
#	Aug	14, 2024: - imported WPC specific code from [D711.pm]
#	Aug 15, 2024: - BUG: def_WPC_codePtr() did not define target labels
#	Aug 16, 2024: - many improvements; now switch table disassembles w/o errors
#	Aug 17, 2024: - many improvements
#	Aug 18, 2024: - BUG: API loaded before ROM
#	Aug 19, 2024: - added _skip
#				  - started adapting to ! WPC shortcut
#	Aug 21, 2024: - BUG: EXTRA_IND, EXTRA_BEFORE_LABEL and EXTRA_AFTER_OP where not
#						 paged in and out
#	Aug 23, 2024: - decimalized !*Sleep args
#	Aug 25, 2024: - renamed addScore because it was wrnog
#				  - BUG: substr used wrong length arg
#	Aug 27, 2024: - BUG: @DIVIDER was not swapped in and out
#				  - additions
#	Aug 28, 2024: - BUG: switchTable allowed labels for bytes
#				  - BUG: wrong page labels in set_WPC_ref
#	Aug 29, 2024: - moved extra lines after RTS, JMP, etc in here from [D711.M6809]
#	Aug 31, 2024: - moved API loading into disassemble_WPC_DMD
#				  - BUG: decimalization of sleep args did not work for lower case sleep
#	Sep  1, 2024: - added support for _IF_true and _IF_false "macros"
#	Sep  2, 2024: - made lamps decimal
#	Sep  4, 2024: - BUG: _IF_true did not work correctly with &skip
#	Sep  8, 2024: - added empty lines after tables
#				  - added def_WPC_lockTable()
#	Sep 10, 2024: - BUG: lock table has different structure
#	Sep 15, 2024: - new label syntax
#	Sep 21, 2024: - BUG: line spacing
#	Mar 11, 2025: - BUG: WCP_codeRef defined AUTO_LBL in wrong ROM page (difficult!)
#				  - BUG: lockTable had .DWBW instead of .DWB
#	Mar 14, 2025: - improved error message
#	Mar 15, 2025: - adapted to new interface w/o _DMD in function names
#				  - BUG: init_WPC() set _cur_RPG
#	Mar 16, 2025: - BUG: couple of label bugs
#	Mar 17, 2025: - merged from D711.WPC_DMD (mainly) and D711.WPC_Alphanumeric
#	Mar 18, 2025: - improved disassemble_syscalls()
#	Mar 19, 2025: - BUG: select_WPC_RPG() did not always return correct value
#				  - BUG: select_WPC_RPG() check of page ids did not work
#				  - added support for Game Event Hooks (@Hook)
#	Mar 21, 2025: - updated disassemble_MBD_system() to work with scanCode
#	Mar 23, 2025: - updated disassemble_MBD_system() to work with WPC_MBD.obj
#	Mar 24, 2025: - adapted to @OI (.obj output)
#	Mar 25, 2025: - BUG: &skip magic did not work correctly
#	Mar 26, 2025: - removed extra space after BRA and _ENDLOOP
#	Apr  3, 2025: - modified scan output
#	Apr  5, 2025: - modified scan output again
#				  - added support for -p
#				  - added produce_object_output() 
#				  - adapted scanCode() to work with prime area
#	Apr  6, 2025: - BUG: wrong labels set on -p
#				  - BUG: wrong number of defined labels reported
#				  - added support for obj file tags
#	Apr  7, 2025: - added gap info to obj files
#				  - added duplicate obj detection
#	Apr  8, 2025: - re-worked and debugged scanCode in prep for adaptation
#				    to multi-label matches
#	May 29, 2025: - replaced _skip by & _SKIP
#	May 30, 2025: - renamed _branchIfTrue, etc. ops
#	Jun  1, 2025: - improved disassembly of system pointers
#				  - BUG: def_WPC_ref() did not update $Address
#				  - added _SKIP macro
#				  - replaced a couple of .DWB by .DR
#	Jun  2, 2025: - re-wrote def_WPC_codeRef()
#				  - modify def_WPC_ref() to deal with pre-existing partial
#					analysis (munging)
#				  - cleaned up System Data Pointers with FH
#	Jun  9, 2025: - BUG: SKIP label removal was broken
#	Jun 10, 2025: - BUG: SKIP label removal was still broken
#				  - BUG: hard-coded page number used for debugging left in
#						 place
#	Jun 12, 2025: - BUG: disassemble_sycalls() did not set page
#				  - BUG: WPC reference +2 page labels were not created
#						 unless .DR came after .DB of this ref
#				  - BUG: define_syscall did not set correct page
#	Jun 13, 2025: - BUG: _SKIP labels not removed in case of two
#						 labels with same code addr in 2 different
#						 pages
#	Jun 15, 2025: - added support for __IF, etc.
#				  - greatly improved system pointer decoding
#	Jun 21, 2025: - added def_WPC_bitgroup_table
#	Jun 22, 2025: - made it work
#	Jun 23, 2025: - added def_WPC_FXtable()
#				  - re-added goood bitgroup table decoding
#				  - reduced WPC table indents to same as code
#	Jun 24, 2025: - added WPC stuff
#	Jun 25, 2025: - added =SOLCMD_TABLE
# END OF HISTORY 

#----------------------------------------------------------------------
# Object File Disassembly 
#----------------------------------------------------------------------

sub produce_object_output($$$$)
{				  
	my($RPG,$fa,$la,$tag) = @_;
	$fa = 0 unless defined($fa);
	$la = $#ROM unless defined($la);

	my($objss,$rems) = (0,0);

	print("$tag\n");
	print("$RPG\n");														# PG id
	for (my($addr)=$fa; $addr<=$la; $addr++) {  

		my($nGap) = 0;														# handle gaps
		$nGap++ while !$decoded[$addr+$nGap] && $addr+$nGap<$la;;
		if ($nGap) {
			print("G$nGap\n");
			$addr += $nGap-1;
			next; 
        }

		next unless defined($OP[$addr]);									# skip inter-op addresses

		if (defined($LBL[$addr]) && !($LBL[$addr] =~ m{[\.~]})) {			# start next object (not on BRA labels)
			$objs++;
			print(">$LBL[$addr]\n");
			print(";[$tag]\n") unless defined($REM[$addr]);					# add a tag if there is no comment
        }

		if (defined($REM[$addr])) {											# add comment
			$rems++;
			print(";[$tag] $REM[$addr]\n") 
        }

		foreach my $oi (@{$OI[$addr]}) {									# process all object info for this op
			if ($oi =~ m{^:} && defined($LBL[hex($')])) {					# address with label
				printf(":%s ",$LBL[hex($')]);
			} else {														# anything else
				print("$oi ");
			}
		}
		print("\n");
	}
	printf(STDERR "ROM PG#%02X: $objs objects with $rems comments produced\n",$RPG);
}


sub scanCode(@)																# Code Scanner
{
##	print(STDERR "scanCode(@_)\n");
	my($allowedMismatches,$pg,$lbl,$fi,$li) = @_;

	select_WPC_RPG($pg);

	my($saddr) = ($pg == 0xFF) ? 0x7FFF : 0x3FFF;							# start of match minus 1
	my($eaddr) = ($pg == 0xFF) ? 0xFFFF : 0x7FFF;							# end of match area
	$Address = $saddr;

	my(@matchData,@matchLabel,@matchREM);									# data from successful match
	my($match_lbl,$match_Address,$match_saddr);								# multiple matches check

 RESTART_SCAN:																# jump target for failed matches and checking for multiple matches
## 	printf(STDERR "RESTART_SCAN (len = %d) at %04X\n",$Address - $saddr,$saddr);
	my($mismatches,$mi); 

 	$saddr++;																# try next
	if ($saddr > $eaddr) {													# MATCH FAILED
		goto SCANCODE_SUCCESS if defined($match_lbl);
		return 0;															# never matched
	}

	$mismatches = 0; $mi = $fi;												# reset scanner data
	undef(@matchData); 
	undef(@matchLabel);
	undef(@matchREM);

N:
	for ($Address=$saddr; $mi<$li; ) {
		goto RESTART_SCAN if $Address > 0xFFFF;
		$mi++;
##		printf(STDERR "od = $objData[$mi] (@matchData) addr = %04X\n",$Address);

		if (substr($objData[$mi],0,1) eq 'G') {							# gap
			$Address += substr($objData[$mi],1);
			next;
        }

		if (substr($objData[$mi],0,1) eq ';') {							# comment
			my($ro) = $Address-$saddr;
			$matchREM[$ro] = substr($objData[$mi],1)
				unless defined($matchRem[$ro]);
			next;
		}

		foreach my $ode (split(/ /,$objData[$mi])) {
		
			if (substr($ode,0,1) eq ':') { 						# WORD
				if (length($ode) > 1) {								# with label
					my($tlbl) = substr($ode,1);
					my($tval) = WORD($Address);
					push(@matchLabel,$tlbl);
					push(@matchData,$tval);
					$Address += 2;
					if (defined($Lbl{$tlbl}) && ($Lbl{$tlbl} != $tval)) {
						$mismatches++;
						goto RESTART_SCAN if ($mismatches > $allowedMismatches);
					}
				} else {														# anonymous
					$Address += 2;
				}
				next;
			}
	
			if (substr($ode,0,1) eq '.') { 						# BYTE
				if (length($ode) > 1) {
					my($tlbl) = substr($ode,1);
					my($tval) = BYTE($Address);
					push(@matchLabel,$tlbl);
					push(@matchData,$tval);
					$Address += 1;
					if (defined($Lbl{$tlbl}) && ($Lbl{$tlbl} != $tval)) {
						$mismatches++;
						goto RESTART_SCAN if ($mismatches > $allowedMismatches);
					}
				} else {
					$Address += 1;
				}
				next;
			}
	
			for (my($j)=0; $j<int(length($ode)/2); $j++,$Address++) {		# HEX
				die("scanCode: invalid objData #$j <$ode>\n")
					unless (substr($ode,2*$j,2) =~ m{^[0-9A-f]{2}});
##				printf(STDERR "%04X: %02X (<-%s) [$mismatches]\n",$Address,BYTE($Address),substr($ode,2*$j,2))
##					if $mi>5;
##				printf(STDERR "%s vs %02X\n",substr($ode,2*$j,2),BYTE($Address));
				if (hex(substr($ode,2*$j,2)) != BYTE($Address)) {
					$mismatches++; 
					goto RESTART_SCAN if ($mismatches > $allowedMismatches);
				}
	        }
        }
	}

	#-----------------
	# Successful Match
	#-----------------

##	print(STDERR "MATCH ($mismatches)\n");
	if ($mismatches == 0) {
		if (defined($match_lbl)) {											# duplicate match
			printf(STDERR "scanCode: $match_lbl matches multiple addresses (%04X, %04X, ...) -- skipped\n",
				$match_saddr,$saddr)
					unless $saddr == $match_saddr+1;
			return -1;														# multiple matches
        }
		$match_lbl	   = $lbl;
		$match_Address = $Address;											# record first match
		$match_saddr   = $saddr;
		goto RESTART_SCAN;													# try again
    }

SCANCODE_SUCCESS:															# jump target when there is no 2nd match
	if (defined($match_lbl)) {
		$lbl 	 = $match_lbl;
		$Address = $match_Address;
		$saddr	 = $match_saddr;
		$mismatches = 0;
    }
##	printf(STDERR "scanCode: $lbl found at %04X ($mismatches)\n",$saddr);

	my($labels_defined,$comments_defined) = (0,0);							

	if ((($Address-$saddr)-$mismatches > 15) && 							# exclude short code snippets with likely multiple matches...
#			($LBL[$saddr] ne $lbl) &&										# ... already  defined labels ...
			!($lbl =~ m{^GameHook#[0-9A-F]{2}_event$})) {					# ... and automatically generated labels (GameHook#XX_event)
		$labels_defined++;
##		printf("D711::setLabel('$lbl',0x%04X,0x%02X); \$D711::Address = 0x%04X; D711::def_code();\n",
##			$saddr,$pg,$saddr);
		for (my($i)=0; $i<@matchData; $i++) {
			next if ($matchLabel[$i] =~ m{^RAM_[0-9A-F]{2,4}$});			# "anonymous" labels (e.g. RAM_0384) are set automatically (no need to handle here)
			next if ($LBL[$matchData[$i]] eq $matchLabel[$i]);				# label already defined
			$labels_defined++;
			printf("D711::setLabel('$matchLabel[$i]',0x%04X,0x%02X);\n",$matchData[$i],$pg);
		}																	# by the disassembler and cannot migrate over
		for (my($i)=0; $i<@matchREM; $i++) {
			next unless defined($matchREM[$i]);
			$comments_defined++;
			printf("\$D711::REM[0x%04X] = '$matchREM[$i]';\n",$saddr+$i);
	    }
		return ($labels_defined,$comments_defined,$saddr);
	}
	return undef;															# not multiple matches (don't report)
}

sub scan(@)
{
	my($trace) = 0;
	my($ld,$cd,$addr) = scanCode(0,@_);
	if (defined($cd)) {
		printf(STDERR "scanCode($_[1]): exact match\n") if $trace;
		$exact++;
		$lbldefd += $ld;
		$remdefd += $cd;
	} elsif ($ld == 0) {
		printf(STDERR "scanCode($_[1]): exact match failure (not multiple)\n") if $trace;
		($ld,$cd,$addr) = scanCode(5,@_);
		if (defined($cd)) {
			printf(STDERR "scanCode($_[1]): FUZZY match at (%04X)\n",$addr); # if $trace;
			$fuzzy++;
			$lbldefd += $ld;
			$remdefd += $cd;
        } else {
			printf(STDERR "scanCode($_[1]): fuzzy match failure\n") if $trace;
        	$failed++;
        }
	} else {
		printf(STDERR "scanCode($_[1]): multiple match failure\n") if $trace;
		$failed++;
    }
}

sub process_object_file($)													# execute this early on, because it defines syscalls
{
	my($ofn) = @_;
	
	local(@objData);														# object file contents
	local($exact,$fuzzy,$failed) = (0,0,0);									# scan results
	local($lbldefd,$remdefd) = (0,0);

	open(OBJF,"$ofn") || die("$ofn: $!\n");									# open file and read PG id
	$_ = <OBJF>; chomp;														# tag
	$_ = <OBJF>; chomp;
	die("$ofn: page id missing\n")
		unless m/[0-9A-F]{2}/;
	my($RPG) = hex($_);
	select_WPC_RPG($RPG);

	while (<OBJF>) {														# read object data
		chop;
		next if /^#/;														# skip comments
		push(@objData,$_);
    }
	close(OBJF);	

	my($s) = 0;																# starting index
	die($objData[$s]) unless substr($objData[$s],0,1) eq '>';
	my($lbl) = substr($objData[$i],1);
	for (my($e)=1; $e<@objData; $e++) {
		if (substr($objData[$e],0,1) eq '>') {								# next label
			scan($RPG,$lbl,$s,$e-1);
			$s = $e;
			$lbl = substr($objData[$s],1);
#			print(STDERR "process_object_file: scanning for $lbl...\n");
        } 
	}
	scan($RPG,$lbl,$s,$e-1);
	print(STDERR "$ofn: $exact exact, $fuzzy fuzzy, $failed failed matches\n");
	print(STDERR "$ofn: $lbldefd labels defined, $remdefd comments added\n");
}


#======================================================================
# WPC Disassembly Routines
#======================================================================

sub disassemble_inCode_refs($$$)
{
	my($RPG,$fa,$la) = @_;
##	printf(STDERR "disassemble_inCode_refs(%02X,%04X,%04X)\n",@_);

	for (my($addr)=$fa; $addr<=$la-5; $addr++) {
		next unless BYTE($addr)   == 0x8E &&								# LDX #
					BYTE($addr+3) == 0xC6 &&								# LDB #
					BYTE($addr+4)>=$start_page &&
						(BYTE($addr+4)==0xFF && WORD($addr+1)>=0x8000 &&  WORD($addr+1)<=0xFFFF ||
						 BYTE($addr+4)<=0x3D && WORD($addr+1)>=0x4000 &&  WORD($addr+1)<=0x7FFF);

		my($pointee_addr) = WORD($addr+1);
		my($pointee_pg)	  = BYTE($addr+4);
		my($type) 		  = ($pointee_addr>=0x8000) ? 'SYSTEM_XB' : 'GAME_XB';
		my($pointee_lbl)  = sprintf('UNKNOWN_%s_REF_%04X',$type,$addr);
		select_WPC_RPG($pointee_pg);
		my($usr_lbl) 	  = $LBL[$pointee_addr];
		$pointee_lbl 	  = $usr_lbl if defined($usr_lbl);
		setLabel($pointee_lbl,$pointee_addr,$pointee_pg);
		$REM[$addr] = $rem unless defined($REM[$addr]);
		select_WPC_RPG($RPG);
    }

	for (my($addr)=$fa; $addr<=$la-5; $addr++) {
		next unless WORD($addr)   == 0x108E &&								# LDY #
					BYTE($addr+4) == 0x86 &&								# LDA #
					BYTE($addr+5)>=$start_page &&
						(BYTE($addr+5)==0xFF && WORD($addr+2)>=0x8000 &&  WORD($addr+2)<=0xFFFF ||
						 BYTE($addr+5)<=0x3D && WORD($addr+2)>=0x4000 &&  WORD($addr+2)<=0x7FFF);

		my($pointee_addr) = WORD($addr+2);
		my($pointee_pg)	  = BYTE($addr+5);
		my($type) 		  = ($pointee_addr>=0x8000) ? 'SYSTEM_YA' : 'GAME_YA';
		my($pointee_lbl)  = sprintf('UNKNOWN_%s_REF_%04X',$type,$addr);
		select_WPC_RPG($pointee_pg);
		my($usr_lbl) 	  = $LBL[$pointee_addr];
		$pointee_lbl 	  = $usr_lbl if defined($usr_lbl);
		setLabel($pointee_lbl,$pointee_addr,$pointee_pg);
		$REM[$addr] = $rem unless defined($REM[$addr]);
		select_WPC_RPG($RPG);
    }
}


sub disassemble_syscalls()													# execute this after all syscalls have been defined
{
	for (my($sc)=0; $sc<@SYSCALL; $sc++) {
		select_WPC_RPG(0x3B) if ($SC_NOTE[$sc] == 3);						# NOTE 3: syscall tied to PG#3B
		if ($decoded[$SC_ADDR[$sc]]) {
			my($pg) = ($SC_ADDR[$sc]>=0x4000 && $SC_ADDR[$sc]<0x8000)
					? $_cur_RPG
					: 0xFF;
			overwriteLabel($SYSCALL[$sc],$SC_ADDR[$sc],$pg);
		} else{ 
			disassemble_asm($code_base_indent,$SC_ADDR[$sc]);				# labels already defined
			if ($unclean) {
				print(STDERR "ERROR: $SYSCALL[$sc] did not disassemble cleanly\n")
					if $D711::verbose;
				$unclean = 0;
	        }
	    }
	}
}


sub disassemble_CPU_vectors()
{
	$Address = 0xFFF0;														# CPU vectors
	insert_divider($Address,'CPU Vectors');
	
	def_code_ptr('RESERVED_vector','RESERVED_handler','CPU Vector Handler');    
	def_code_ptr('SWI3_vector','SWI3_handler','CPU Vector Handler');
	def_code_ptr('SWI2_vector','SWI2_handler','CPU Vector Handler');		    
	def_code_ptr('FIRQ_vector','FIRQ_handler','CPU Vector Handler');
	def_code_ptr('IRQ_vector','IRQ_handler','CPU Vector Handler');
	def_code_ptr('SWI_vector','SWI_handler','CPU Vector Handler');
	def_code_ptr('NMI_vector','NMI_handler','CPU Vector Handler');			    
	def_code_ptr('RST_vector','RST_handler','CPU Vector Handler');              
}


sub disassemble_system_pointers()
{
	$Address = 0x8000;
	insert_divider($Address,'Bank Id');
	def_byte_hex('_ROMPG_SYS1_ID');
	
	insert_divider($Address,'Game Event Hooks');
	for (my($h)=0; $Address<0x812D; $h++) {
		my($taddr) = sprintf('%04X',WORD($Address));
		my($trpg) = sprintf('%02X',BYTE($Address+2));
		my($handler) = defined($Hook[$h])
				  	 ? $Hook[$h] . '_event'
				  	 : "GameHook#${h}_event";
		def_WPC_codeRef($handler,'Game Event Hook');
	}
	
	my($ubyte,$uword);
	
	#------------------------------
	# Exceptions
	#------------------------------

	my(@skipAddr) = (0x81A2,0x81B6,0x81C2,0x81C5,0x81CE,0x821C);	# System Tables

	$Address = 0x81A2;
	$Address = def_WPC_ref('=SOLCMD_TABLE');
		def_WPC_table(undef,'Solenoid Command Table',1);
	$Address = 0x81B6;												# first, the exceptions
	$Address = def_WPC_ref('=BITSHIFTER_LAMPMATRIX_LOOKUPTABLE');
		def_byteblock_hex(65);
	$Address = 0x81C2;
	$Address = def_WPC_ref('=BITGROUP_TABLE');
		def_WPC_bitgroup_table(undef,'Bitgroup Table');
	$Address = 0x81C5;
	$Address = def_WPC_ref('=SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table',1);				# label already defined, follow code
	$Address = 0x81CE;
	$Address = def_WPC_ref('=FX_TABLE');
		def_WPC_FXtable(undef,'FX Table',1);
	$Address = 0x821C;
	$Address = def_WPC_ref('=AUX_SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table',1)
	        if defined($Address);

	my(@strRef)   = (0x8133,0x8136,0x8139);							# String References
	my(@strRefL)  = ('GAME_NAME','GAME_NUMBER','RELEASE_DATE');

	my(@known)	  = (0x8151);
	my(@knownL)	  = ('BALLSEARCH_TIMER');

	my(@ptr) 	  = (0x81AE);										# pointers (not refs)
	
	$Address = 0x812D;
	insert_divider($Address,'System Data Pointers');

	my($i);
	while ($Address < 0x828E) {
		if (isMember($Address,@skipAddr)) {
			$Address += 3;
		} elsif (isMember($Address,@ptr)) {
		    def_word_hex(sprintf('UNKNOWN_SYSTEM_PTR_%04X',$Address));
		} elsif ($i=isMember($Address,@strRef)) {
		    def_WPC_stringRef(sprintf(defined($strRefL[$i]) ? $strRefL[$i] : 'UNKNOWN_SYSTEM_STRREF_%04X',$Address));
		} elsif ($i=isMember($Address,@known)) {
		    def_WPC_ref($knownL[$i]);
		} else {
			def_WPC_ref(sprintf('UNKNOWN_SYSTEM_PARAM_%04X',$Address));
		}
    }

    while ($Address < 0x8296) {
	    def_ptr_hex_alt(sprintf('^UNKNOWN_SYSTEM_PARAM_%04X',$Address),sprintf('UNKNOWN_SYSTEM_PARAM_%04X',$Address));
	}

	def_ptr_hex('^=STATUS_AREA');
	insert_divider($Address,'System Code');
}


sub disassemble_lock_table()
{
	select_WPC_RPG(0x3B);
	$Address = $Lbl{'3B:BYU=MBD_dataRefs[A]'};
	$Address = $Lbl{'BYU=MBD_dataRefs[A]'} unless defined($Address);	# needed for labelOverrides
	if ($Address =~ m{^([0-9A-F]{2}):}) {
		die("disassemble_lock_table(): wrong page ID $1\n")
			unless ($1 eq '3B');
		$Address = hex($');
    }
	printf(STDERR "WARNING: disassemble_lock_table: syscall BYU=MBD_dataRefs[A] not found ($Address,$Lbl{'BYU=MBD_dataRefs[A]'})\n"),return
		unless numberp($Address) && ($Address>0 && $Address<0x8000);
	my($taddr) = WORD($Address+25);
	my($tpg) = BYTE($Address+28);
	die("$Address,$taddr,$tpg") unless ($tpg>=0x20 && $tpg<=0x3D);
	select_WPC_RPG($tpg);
	$Address = $taddr;
	def_WPC_lockTable('=LOCKTABLE','Multiball Device Table',1);
}

sub disassemble_font_table()
{
	die("disassemble_font_table(): not yet implemented\n");
	$Address = 0x8285;
	my($addr) = def_ptr('^sys_fontTable');
	def_WPC_fontTable('sys_fontTable','Font Table');
}


sub disassemble_DMD_table()
{
	die("disassemble_DMD_table(): not yet implemented\n");
	$Address = 0x8288;
	my($addr) = def_ptr('^sys_DMDtable');
	def_WPC_DMDTable('sys_DMDtable','DMD Table');
}

#======================================================================
# Post Disassembly Magic
#	- replace JMP *+3 by &skip postfix tag of preceding JSR instruction
#	- make sleep arguments decimal
#	- add empty lines after RTS, JMP, etc.
#	- handle WPC truth values (CC=true) after predicates marked with ?
#======================================================================

sub apply_magic_WPC($$)
{
	my($fa,$la) = @_;

	$systemAliases{_SKIP} = 'JMP .+3';											# _SKIP macro
##	$systemAliases{'Lamp#0'} = '$00';											# invalid Lamp#0

	for (my($addr)=$fa; $addr<=$la-1; $addr++) {
		if ($OP[$addr] eq 'JMP' && $LBL[$addr+3] =~ m{^([0-9A-F]{2}:)?$OPA[$addr][0]$}) {	# 1) JMP *+3
			undef($OP[$addr]);													# generate postfix tag
			push(@{$OPA[$addr-3]},'& _SKIP');
			splice(@{$OPA[$addr]},0,1);
			my($l) = ($LBL[$addr+3] =~ m{^[0-9A-Fa-f]{2}:(.*)$});
			undef($Lbl{$LBL[$addr+3]}),undef($LBL[$addr+3]),undef($Lbl_refs{$l}),
				unless ($Lbl_refs{$l}+$Lbl_refs{$LBL[$addr+3]} > 1);			# (this is a hack; all refs should have prefix)
			undef(@{$OI[$addr]});
			push(@{$OI[$addr-3]},sprintf('7E%04X',$addr+3));
		} elsif ($OP[$addr] eq '!' && $OPA[$addr][0] =~ m{leep$}) {				# 2) decimalize sleep arguments
			$OPA[$addr][1] = hex(substr($OPA[$addr][1],1,4));
		} elsif ($IND[$addr] == $code_base_indent &&							# 3) add extra space after top-level "exit" instructions
				 (isMember($OP[$addr],'RTS','LBRA','JMP') ||
				  ($OP[$addr] eq '!' && $OPA[$addr][0] eq 'exitThread') ||
				  $REM[$addr] eq 'RTS')) {
			insert_empty_line($addr);
		} elsif ($OPA[$addr][0] =~ m{[^\?]\?$}) {								# 4) _IF_true / _IF_false
			my($noa) = $addr + 1;												#	 	execute when last arg ends with a ? but not with ??
			while (!defined($OP[$noa]) ||
				   ($OP[$noa] eq 'JMP' && $LBL[$noa+3] =~ m{^([0-9A-Z]{2}:)?$OPA[$noa][0]$})) {
				$noa++;
				die if $noa > 0xFFFF;
			}
			if    ($OP[$noa] eq '_IF_CC') { $OP[$noa] = '_IF_true'; }			# _IF_true
			elsif ($OP[$noa] eq '__IF_CC') { $OP[$noa] = '__IF_true'; }			# __IF_true
			elsif ($OP[$noa] eq '_IF_CS') { $OP[$noa] = '_IF_false'; }			# _IF_false
			elsif ($OP[$noa] eq '__IF_CS') { $OP[$noa] = '__IF_false'; }		# __IF_false
			elsif ($OP[$noa] eq 'BCC') { $OP[$noa] = 'Btrue'; }					# Btrue
			elsif ($OP[$noa] eq 'BCS') { $OP[$noa] = 'Bfalse'; }				# Bfalse
			elsif ($OP[$noa] eq 'LBCC') { $OP[$noa] = 'LBtrue'; }				# LBtrue
			elsif ($OP[$noa] eq 'LBCS') { $OP[$noa] = 'LBfalse'; }				# LBfalse
		}
	}
}

#----------------------------------------------------------------------
# Init Disassembly System
#----------------------------------------------------------------------

sub init_WPC(@)
{
	my(@linc) = @_;
	
	require 'WPC.API';														# load API after ROM has been loaded but before -i are processed
	while (@linc) {
##		print(STDERR "processing $linc[0]...\n");
		require './' . shift(@linc);
	}

	select_WPC_RPG($start_page,2);
}

#======================================================================
# WPC Disassembly Library
#======================================================================

#----------------------------------------------------------------------
# ROM Paging
#----------------------------------------------------------------------

our($_cur_RPG) = 0xFF;

sub select_WPC_RPG($@)
{
	my($RPG,$caller) = @_;
##	printf(STDERR "select_WPC_RPG(%02X) [caller=$caller, _cur_RPG=%02X]\n",$RPG,$_cur_RPG);
	
	if (!defined($RPG) || !numberp($RPG) || ($RPG != 0xFF && ($RPG<0 || $RPG>0x3D))) {
		if (numberp($RPG)) {
			die(sprintf("select_WPC_RPG(%02X): bad page id\n",$RPG))
		} else {
			die(sprintf("select_WPC_RPG($RPG): bad page id\n"))
		}
	}
		
	return $_cur_RPG if ($RPG == 0xFF || $RPG == $_cur_RPG);
	die unless defined($RPG);
	
	@{$OPPG[$_cur_RPG]} 	 	= @OP[0x4000..0x7FFF];									# swap out active page
	@{$INDPG[$_cur_RPG]}	 	= @IND[0x4000..0x7FFF]; 		    
	@{$TYPEPG[$_cur_RPG]}	 	= @TYPE[0x4000..0x7FFF];		    
	@{$OPAPG[$_cur_RPG]}	 	= @OPA[0x4000..0x7FFF]; 		    
	@{$OIPG[$_cur_RPG]}		 	= @OI[0x4000..0x7FFF]; 		    
	@{$REMPG[$_cur_RPG]}	 	= @REM[0x4000..0x7FFF]; 		    
	@{$EXTRAPG[$_cur_RPG]}	 	= @EXTRA[0x4000..0x7FFF]; 		    
	@{$EXTRA_INDPG[$_cur_RPG]}	= @EXTRA_IND[0x4000..0x7FFF]; 		    
	@{$EXTRA_BEFORE_LABELPG[$_cur_RPG]}	= @EXTRA_BEFORE_LABEL[0x4000..0x7FFF]; 		    
	@{$EXTRA_AFTER_OPPG[$_cur_RPG]}		= @EXTRA_AFTER_OP[0x4000..0x7FFF]; 		    
	@{$LBLPG[$_cur_RPG]}	 	= @LBL[0x4000..0x7FFF]; 		    
	@{$AUTO_LBLPG[$_cur_RPG]} 	= @AUTO_LBL[0x4000..0x7FFF]; 		    
	@{$decodedPG[$_cur_RPG]} 	= @decoded[0x4000..0x7FFF];
	@{$DIVIDERPG[$_cur_RPG]} 	= @DIVIDER[0x4000..0x7FFF];
	@{$ROMPG[$_cur_RPG]}	 	= @ROM[0x4000..0x7FFF]
		unless(@{$ROMPG[$_cur_RPG]});
    
	@OP[0x4000..0x7FFF]			= @{$OPPG[$RPG]};										# swap in new page
	@IND[0x4000..0x7FFF] 		= @{$INDPG[$RPG]};
	@TYPE[0x4000..0x7FFF]		= @{$TYPEPG[$RPG]};
	@OPA[0x4000..0x7FFF] 		= @{$OPAPG[$RPG]};
	@OI[0x4000..0x7FFF] 		= @{$OIPG[$RPG]};
	@REM[0x4000..0x7FFF] 		= @{$REMPG[$RPG]};
	@EXTRA[0x4000..0x7FFF] 		= @{$EXTRAPG[$RPG]};
	@EXTRA_IND[0x4000..0x7FFF]	= @{$EXTRA_INDPG[$RPG]};
	@EXTRA_BEFORE_LABEL[0x4000..0x7FFF] = @{$EXTRA_BEFORE_LABELPG[$RPG]};
	@EXTRA_AFTER_OP[0x4000..0x7FFF] 	= @{$EXTRA_AFTER_OPPG[$RPG]};
	@LBL[0x4000..0x7FFF] 		= @{$LBLPG[$RPG]};
	@AUTO_LBL[0x4000..0x7FFF] 	= @{$AUTO_LBLPG[$RPG]};
	@decoded[0x4000..0x7FFF] 	= @{$decodedPG[$RPG]};
	@DIVIDER[0x4000..0x7FFF] 	= @{$DIVIDERPG[$RPG]};
	if (@{$ROMPG[$RPG]}) {
		@ROM[0x4000..0x7FFF]	= @{$ROMPG[$RPG]};										# copy from page buffer
	} else {
		load_ROM($ARGV[0],0x4000,$RPG,16);												# load from file
	}
	
	my($oRPG) = $_cur_RPG;
    $_cur_RPG = $RPG;

	unless ($decoded[0x4000]) {															# decode page id first time a page is referenced
		my($oA) = $Address;
		$Address = 0x4000;
		def_byte_hex('_ROMPG_ID',sprintf('ROM PAGE %02X',$_cur_RPG));
		push(@{$OI[0x4000]},sprintf('%02X',BYTE(0x4000)));								# this should eventually move into def_byte_hex()
		$Address = $oA;
	}
	
    return $oRPG;
}

#======================================================================
# WPC Tables
#	- header:
#		- number of entries (word)
#		- number of bytes per entry (byte)
#======================================================================

#----------------------------------------------------------------------
# Generic Table
#----------------------------------------------------------------------

sub def_WPC_table(@)
{
	my($lbl,$divider_label) = @_;
#	print(STDERR "def_WPC_table(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of table rows, bytes per row' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r+1) if ($r+1)==1 || ($r+1)%10==0;
		if ($cols%2 == 0) {
			$OP[$opaddr] = '.DW';
			for (my($c)=0; $c<$cols; $c+=2) {
				push(@{$OPA[$opaddr]},sprintf('$%04X!',WORD($Address)));
				$decoded[$Address++] = $decoded[$Address++] = 1;
	        }
		} else {
			$OP[$opaddr] = '.DB';
			for (my($c)=0; $c<$cols; $c++) {
				push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	        }
	    }
	}
    insert_empty_line($Address-11);
}

#----------------------------------------------------------------------
# Bitgroup Table
#----------------------------------------------------------------------

sub dasm_bitgroup_def($$$)
{
	my($lbl,$opa,$a) = @_;

	if (BYTE($a) == 0xFA) { 												# def (Range|??? ...)
		push(@{$OPA[$opa]},'$FA'); $decoded[$a++] = 1;
		while (BYTE($a) != 0xFA) {
			($opa,$a) = dasm_bitgroup_def($lbl,$opa,$a);
		}
		push(@{$OPA[$opa]},'$FA'); $decoded[$a++] = 1;
		return ($opa,$a);
	}

	if (BYTE($a) == 0x85) { 												# Range (from lamp, to lamp)
		push(@{$OPA[$opa]},'$85'); $decoded[$a++] = 1;
		push(@{$OPA[$opa]},sprintf("Lamp#%d",BYTE($a))); $decoded[$a++] = 1;
		push(@{$OPA[$opa]},sprintf("Lamp#%d",BYTE($a))); $decoded[$a++] = 1;
		die unless BYTE($a) == 0x85;
		push(@{$OPA[$opa]},'$85'); $decoded[$a++] = 1;
		return ($opa,$a);
	}
		    
	if (BYTE($a) == 0x81) { 												# ??? (single byte)
		push(@{$OPA[$opa]},'$81'); $decoded[$a++] = 1;
		push(@{$OPA[$opa]},sprintf('$%02X!',BYTE($a))); $decoded[$a++] = 1;
		die unless BYTE($a) == 0x81;
		push(@{$OPA[$opa]},'$81'); $decoded[$a++] = 1;
		return ($opa,$a);
	}

	if (BYTE($a) == 0xF8) { 												# ??? (followed by address, bytes, and F9)
		$opa = $a;
		$IND[$opa] = $code_base_indent; $TYPE[$opa] =  $CodeType_data;
		$OP[$opa] = '.DBWB';
		push(@{$OPA[$opa]},'$F8'); $decoded[$a++] = 1;
		my($trga) = WORD($a);
		setLabel(sprintf("${lbl}_%04X",$trga),$trga);
		push(@{$OPA[$opa]},sprintf('$%04X',WORD($a)));
		$decoded[$a++] = $decoded[$a++] = 1;
		while (BYTE($a) != 0xF9) {
			push(@{$OPA[$opa]},sprintf('$%02X!',BYTE($a))); $decoded[$a++] = 1;
		}
		push(@{$OPA[$opa]},'$F9'); $decoded[$a++] = 1;
		return ($opa,$a);
	}
		    
	if (BYTE($a) >= 0x80) {
		push(@{$OPA[$opa]},sprintf('$%02X!',BYTE($a))); $decoded[$a++] = 1;
	} else {
		push(@{$OPA[$opa]},sprintf("Lamp#%d",BYTE($a))); $decoded[$a++] = 1;
	}
	return ($opa,$a);
}


sub def_WPC_bitgroup_table(@)
{
	my($lbl,$divider_label) = @_;
#	print(STDERR "def_bitgroup_table(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]); 										    
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 							    
		setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	die("Invalid number of bytes <$cols> per Bitgroup table entry\n") unless ($cols == 2);
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of bitgroups, bytes per bitgroup' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($r)=0; $r<$rows; $r++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =	$CodeType_data;
		$REM[$opaddr] = sprintf('Row#%d',$r+1) if ($r+1)==1 || ($r+1)%10==0;

		$OP[$opaddr] = '.DW';
		my($ta) = WORD($Address);
		push(@{$OPA[$opaddr]},sprintf('$%04X',$ta));
		$decoded[$Address++] = $decoded[$Address++] = 1;

		my($tl) = $LBL[$ta];
		$tl = sprintf('.bitgroup#%02X',$r) unless defined($tl);
		setLabel($tl,$ta);

		$IND[$ta] = $code_base_indent; $TYPE[$ta] =	$CodeType_data;
		$OP[$ta] = '.DWB';
		my($nextDta) = WORD($ta);
		push(@{$OPA[$ta]},sprintf('$%04X',WORD($ta)));
		$decoded[$ta] = $decoded[$ta+1] = 1;

		dasm_bitgroup_def($tl,$ta,$ta+2);
	}
	insert_empty_line($Address);
}   

#----------------------------------------------------------------------
# Lock Table / Multiball Device Table
#----------------------------------------------------------------------

sub def_WPC_lockTable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_lockTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of locks, bytes per lock' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($lck)=0; $lck<$rows; $lck++) {
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DW';
		my($daddr) = WORD($Address);
			my($dlbl) = $LBL[$daddr];
			$dlbl = sprintf('Lock#%02X_data',$lck) unless defined($dlbl);
		    setLabel($dlbl,$daddr);
		push(@{$OPA[$Address]},sprintf('$%04X',$daddr));
		$REM[$Address] = 'pointer to lock definition data (4-10 bytes)' if !defined($REM[$Address]) && $lck==0;
	    $decoded[$Address++] = $decoded[$Address++] = 1;

	    my($sa) = $Address;
	    $Address = $daddr;

		my($taddr,$trpg);
		$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
		$REM[$Address] = sprintf('Lock#%02X',$lck) if !defined($REM[$Address]);
		$OP[$Address] = '.DBR';
		push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address)));
		push(@{$OPA[$Address]},sprintf('$%04X',$taddr=WORD($Address+1)));
		push(@{$OPA[$Address]},sprintf('$%02X',$trpg=BYTE($Address+3)));
	    $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
		if ($lck == 1) {
			$OP[$Address-4] = '.DBRWB';
			push(@{$OPA[$Address-4]},sprintf('$%04X',WORD($Address)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+2)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+3)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+4)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+5)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+6)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = 1;
		} elsif ($lck > 1) {
			$OP[$Address-4] = '.DBRB';
			push(@{$OPA[$Address-4]},sprintf('Switch#%02X',BYTE($Address)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+1)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+2)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+3)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+4)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+5)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
		}

	    if ($follow_code) {
	    	my($srpg) = select_WPC_RPG($trpg,8);
	    	insert_divider($taddr,'Lock Event Handler');
			my($tlbl) = $LBL[$taddr];
			$tlbl = sprintf('Lock#%02X_handler',$lck) unless defined($tlbl);
		    setLabel($tlbl,$taddr);
			disassemble_asm($code_base_indent,$taddr,$tlbl,undef,$follow_code);
			select_WPC_RPG($srpg,9);
	    }

	    $Address = $sa;
    }
    insert_empty_line($Address-2);
}

#----------------------------------------------------------------------
# Switch Table
#----------------------------------------------------------------------

sub def_WPC_switchTable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_switchTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of switches, bytes per switch' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($sw)=0; $sw<$rows; $sw++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DBBRB';
		$REM[$opaddr] = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;

		my($ta,$tp) = (WORD($Address),BYTE($Address+2));
		my($swn) = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},label_address($ta,$swn.'_handler',1));						# suppress address suffix in label
		push(@{$OPA[$opaddr]},sprintf('$%02X',$tp));
		WPC_codeRef($swn.'_handler',"Switch Handler ($swn)",$follow_code);
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
##		push(@{$OPA[$opaddr]},sprintf('Lamp#%d',BYTE($Address))); $decoded[$Address++] = 1;			# incorrect in FH at least
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	}
    insert_empty_line($Address-11);
}   
		    
#----------------------------------------------------------------------
# FX Table
#----------------------------------------------------------------------

sub def_WPC_FXtable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_FXTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $code_base_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($FX)=1; $FX<=$rows; $FX++) {
		my($opaddr) = $Address;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$REM[$opaddr] = defined($FX[$FX]) ? $FX[$FX] : sprintf('FX#%02X',$FX);
		$OP[$opaddr] = '.DB';
		for (my($i)=0; $i<7; $i++) {
			push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	    }

		$opaddr += 7;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DR';
		my($ta,$tp) = (WORD($Address),BYTE($Address+2));
		my($FXn) = defined($FX[$FX]) ? $FX[$FX] : sprintf('FX#%02X',$FX);
		push(@{$OPA[$opaddr]},label_address($ta,$FXn.'_handler',1));						# suppress address suffix in label
		push(@{$OPA[$opaddr]},sprintf('$%02X',$tp));
		WPC_codeRef($FXn.'_handler',"FX Handler ($FXn)",$follow_code);
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		$opaddr += 3;
		$IND[$opaddr] = $code_base_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DB';
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	}
    insert_empty_line($Address);
}   
		    
#----------------------------------------------------------------------
# References
#	- loads RPG
#	- needs to deal with partially decoded references
#----------------------------------------------------------------------

sub def_WPC_ref($@)														# DOES NOT MAINTAIN RPG
{																			
	my($pointee_lbl,$rem) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die(sprintf("def_WPC_ref(%04X,$lbl): addresses below 0x8000 not supported (implementation restriction)",$Address))
    	unless ($Address >= 0x8000);

	my($pointee_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
##	printf(STDERR "%04X: def_WPC_ref($pointee_lbl) -> %02X:%04X\n",$Address,$RPG,$pointee_addr);
	select_WPC_RPG($RPG,3)
		unless ($RPG == 0x00);																# NULL ref

	if (($decoded[$Address] || $decoded[$Address+2]) &&										# already decoded
		$OP[$Address] ne '.DR') {
##		printf(STDERR "%04X: def_WPC_ref($pointee_lbl): munging pre-existing analysis $OP[$Address]/$OP[$Address+2]\n",$Address);
		if ($decoded[$Address]) {
			die($OP[$Address]) unless ($OP[$Address] eq '.DW');
		}
		if ($decoded[$Address+2]) {
 			die unless ($OP[$Address+2] eq '.DB');
			undef($OP[$Address+2]);
			undef(@{$OPA[$Address+2]});
			die unless defined($AUTO_LBL[$Address+2]);
##			undef($AUTO_LBL[$Address+2]);													# maybe LBL should be cleared as well?
##			$AUTO_LBL[$Address+2] = sprintf("^$pointee_lbl+2");
        }
    }

	die,$pointee_lbl = $` if ($pointee_lbl =~ m{\[[0-9A-F]{2}\]$});            				# remove previous RPG if there is one
	setLabel("^$pointee_lbl",$Address);
	undef($LBL[$Address+2]);
	$AUTO_LBL[$Address+2] = sprintf("^$pointee_lbl+2");
##	print(STDERR "AUTO_LBL[$Address+2] = $AUTO_LBL[$Address+2] <$LBL[$Address+2]>\n");
	
	$OP[$Address] = '.DR'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $codeType_data;
	if ($pointee_addr == 0x0000) {															# FH.WPC $FF:821C
		$OPA[$Address][0] = '$0000';
		$OPA[$Address][1] = '$00';
	} else {
		my($usr_lbl) = $LBL[$pointee_addr];
		$pointee_lbl = $usr_lbl if defined($usr_lbl);
		setLabel($pointee_lbl,$pointee_addr);
		$OPA[$Address][0] = $LBL[$pointee_addr]; #$pointee_lbl; 
		$OPA[$Address][1] = sprintf('$%02X',$RPG);
    }
##    printf(STDERR "%04X: $OP[$Address] @{$OPA[$Address]}\n",$Address);

	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	$Address += 3;

	return $pointee_addr;
}

#----------------------------------------------------------------------
# Strings
#----------------------------------------------------------------------

sub decode_WPC_STR_char($)
{
	my($c) = BYTE($_[0]);

	return sprintf('%c',$c)																		# printable ASCII
		if ($c >= 32 && $c < 127);
	return sprintf('\\%02X',$c);																# non-printable
}

sub def_WPC_string(@)
{
	my($lbl,$divider_label,$rem) = @_;

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	insert_divider($Address,$divider_label);
	$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	setLabel($lbl,$Address);
    $Address+=$len,return unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    
	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$OP[$Address] = '.STR';
	my($o);
	$OPA[$Address][0] = "'";
	for ($o=0; BYTE($Address+$o)!=0; $o++) {
		$OPA[$Address][0] .= decode_WPC_STR_char($Address+$o);
		$decoded[$Address+$o] = 1;
	}
	$decoded[$Address+$o] = 1;
	$OPA[$Address][0] .= "'";
	$Address += $o;
}   
		    
sub def_WPC_stringRef($@)														# DOES NOT MAINTAIN RPG
{																			
	my($str_lbl,$divider_title,$rem) = @_;

	my($str_addr) = def_WPC_ref($str_lbl,$rem);
	my($oAddr) = $Address;
	$Address = $str_addr;
	def_WPC_string($str_lbl,$divider_title);
	$Address = $oAddr;
}

#----------------------------------------------------------------------
# Code
#----------------------------------------------------------------------

sub WPC_codeRef($@)															# label and disassemble 3-byte code reference
{
	my($code_lbl,$divider_title,$follow_code) = @_;							# (optional) code_label page prefix ignored

	my($code_addr) = WORD($Address);										# extract address components and swap-in correct ROM page
	my($RPG) = BYTE($Address+2);
	my($orpg) = select_WPC_RPG($RPG,5);

	label_address($code_addr,$code_lbl,1);									# label this address (without _addr suffix)

	my($usr_lbl) = $LBL[$code_addr];										# set label, using pre-existing (external) label when available
	$code_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($code_lbl,$code_addr);

	disassemble_asm($code_base_indent,$code_addr,$code_lbl,$divider_title,$follow_code);
#	die if $unclean;														# disassemble referenced code

	select_WPC_RPG($orpg,6);												# return to original ROM page
}


sub def_WPC_codeRef($@)
{
	my($code_lbl,$divider_title,$rem) = @_;

	my($ra) = $Address;
	def_WPC_ref($code_lbl,$rem);
	my($na) = $Address;

	$Address = $ra;
	WPC_codeRef($code_lbl,$divider_title,1);

	$Address = $na;
}


#======================================================================
# Utilities
#	- used in .defs files to define game-specific ids
#	- .def file is loaded during init_WPC()
#======================================================================

$Switch[0] = 'SW_UNUSED';

sub defSwitch($$)
{
	my($no,$name) = @_;

	die("defSwitch: invalid switch number $no\n")
		unless ($no>=1 && $no<=64);
	$Switch[$no] = $name;
}

sub defLamp($$)
{
	my($no,$name) = @_;

	die("defLamp: invalid lamp number $no\n")
		unless ($no>0 && $no<=64);
	$Lamp[$no] = $name;
}

sub defGroup($$)
{
	my($no,$name) = @_;

	die("defGroup: invalid group number $no\n")
		unless ($no>0 && $no<=64);
	$BitGroup[$no] = $name;
}

sub defFlag($$)
{
	my($no,$name) = @_;

	die("defFlag: invalid flag number $no\n")
		unless ($no>0 && $no<=0x80);
	$Flag[$no] = $name;
}

if (0) {
sub defSolenoid($$)
{
	my($no,$name) = @_;

	die("defSolenoid: invalid solenoid number $no\n")
		unless ($no>0 && $no<=0x65);
	my($no,$name) = @_;
	$Sol[$no] = $name;
}
}

sub defSolCmd($$)
{
	my($no,$name) = @_;

	die("defSolCmd: invalid solenoid command number $no\n")
		unless ($no>=0 && $no<=0xFF);
	my($no,$name) = @_;
	$Sol[$no] = $name;
}

sub defLabel($$$)
{
	my($pg,$addr,$lbl) = @_;

	select_WPC_RPG($pg,7);
	define_label($lbl,$addr);
}

sub defAdjustment($$)
{
	my($no,$name) = @_;

	die("defAdjustment: invalid adjustment number $no\n")
		unless ($no>0 && $no<=0xFFFF);
	$Adj[$no] = $name;
}

sub defAudit($$)
{
	my($no,$name) = @_;

	die("defAudit: invalid audit number $no\n")
		unless ($no>=0 && $no<65);
	$Audit[$no] = $name;
}

sub defThread($$)
{
	my($no,$name) = @_;

	die("defThread: invalid thread id\n")
		unless ($no>0 && $no<=0xFFFF);
	$Thread[$no] = $name;
}

sub defDMD($$)
{
	my($no,$name) = @_;

	die("defDMD: invalid DMD animation\n")
		unless ($no>0 && $no<=0xFFFF);
	$DMD[$no] = $name;
}

#----------------------------------------------------------------------
#	Define System Calls
#
# 	$note ARGUMENTS:
#		1: routine does not return
#----------------------------------------------------------------------

sub define_syscall($$@)
{
	my($lbl,$addr,$args,$note) = @_;
	$args = '' unless defined($args);

	my($pg,$nm) = ($lbl =~ m{^([0-9A-Fa-f]{2}):(.*)$});
	select_WPC_RPG(hex($pg))
		if defined($pg);
	define_label($lbl,$addr);
	
	push(@SYSCALL,$lbl);
	$SC_ADDR[$#SYSCALL] = $addr;
	$SC_ARGS[$#SYSCALL] = $args;
	$SC_NOTE[$#SYSCALL] = $note;
}

1; 																# return true

