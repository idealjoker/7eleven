#======================================================================
#                    D 7 1 1 . W P C 
#                    doc: Thu Jul 18 06:34:49 2024
#                    dlm: Tue Apr  8 12:06:59 2025
#                    (c) 2024 idealjoker@mailbox.org
#                    uE-Info: 72 42 NIL 0 0 72 8 2 4 NIL ofnI
#======================================================================

# WPC Disassembly 

# HISTORY:
#	Jul 18, 2024: - created; WMS CPU vectors disassemble correctly
#	Aug  9, 2024: - continued
#	Aug 10, 2024: - added support for ROM pages
#	Aug 11, 2024: - System Call Pointers disassemble correctly
#				  - BUG: WMS CPU vectors no longer disassemble correctly
#	Aug 12, 2024: - added support for system strings
#	Aug	14, 2024: - imported WPC specific code from [D711.pm]
#	Aug 15, 2024: - BUG: def_WPC_codePtr() did not define target labels
#	Aug 16, 2024: - many improvements; now switch table disassembles w/o errors
#	Aug 17, 2024: - many improvements
#	Aug 18, 2024: - BUG: API loaded before ROM
#	Aug 19, 2024: - added _skip
#				  - started adapting to ! WPC shortcut
#	Aug 21, 2024: - BUG: EXTRA_IND, EXTRA_BEFORE_LABEL and EXTRA_AFTER_OP where not
#						 paged in and out
#	Aug 23, 2024: - decimalized !*Sleep args
#	Aug 25, 2024: - renamed addScore because it was wrnog
#				  - BUG: substr used wrong length arg
#	Aug 27, 2024: - BUG: @DIVIDER was not swapped in and out
#				  - additions
#	Aug 28, 2024: - BUG: switchTable allowed labels for bytes
#				  - BUG: wrong page labels in set_WPC_ref
#	Aug 29, 2024: - moved extra lines after RTS, JMP, etc in here from [D711.M6809]
#	Aug 31, 2024: - moved API loading into disassemble_WPC_DMD
#				  - BUG: decimalization of sleep args did not work for lower case sleep
#	Sep  1, 2024: - added support for _IF_true and _IF_false "macros"
#	Sep  2, 2024: - made lamps decimal
#	Sep  4, 2024: - BUG: _IF_true did not work correctly with &skip
#	Sep  8, 2024: - added empty lines after tables
#				  - added def_WPC_lockTable()
#	Sep 10, 2024: - BUG: lock table has different structure
#	Sep 15, 2024: - new label syntax
#	Sep 21, 2024: - BUG: line spacing
#	Mar 11, 2025: - BUG: WCP_codeRef defined AUTO_LBL in wrong ROM page (difficult!)
#				  - BUG: lockTable had .DWBW instead of .DWB
#	Mar 14, 2025: - improved error message
#	Mar 15, 2025: - adapted to new interface w/o _DMD in function names
#				  - BUG: init_WPC() set _cur_RPG
#	Mar 16, 2025: - BUG: couple of label bugs
#	Mar 17, 2025: - merged from D711.WPC_DMD (mainly) and D711.WPC_Alphanumeric
#	Mar 18, 2025: - improved disassemble_syscalls()
#	Mar 19, 2025: - BUG: select_WPC_RPG() did not always return correct value
#				  - BUG: select_WPC_RPG() check of page ids did not work
#				  - added support for Game Event Hooks (@Hook)
#	Mar 21, 2025: - updated disassemble_MBD_system() to work with scanCode
#	Mar 23, 2025: - updated disassemble_MBD_system() to work with WPC_MBD.obj
#	Mar 24, 2025: - adapted to @OI (.obj output)
#	Mar 25, 2025: - BUG: &skip magic did not work correctly
#	Mar 26, 2025: - removed extra space after BRA and _ENDLOOP
#	Apr  3, 2025: - modified scan output
#	Apr  5, 2025: - modified scan output again
#				  - added support for -p
#				  - added produce_object_output() 
#				  - adapted scanCode() to work with prime area
#	Apr  6, 2025: - BUG: wrong labels set on -p
#				  - BUG: wrong number of defined labels reported
#				  - added support for obj file tags
#	Apr  7, 2025: - added gap info to obj files
#				  - added duplicate obj detection
#	Apr  8, 2025: - re-worked and debugged scanCode in prep for adaptation
#				    to multi-label matches
# END OF HISTORY 

#----------------------------------------------------------------------
# Object File Disassembly 
#----------------------------------------------------------------------

sub produce_object_output($$$$)
{				  
	my($RPG,$fa,$la,$tag) = @_;
	$fa = 0 unless defined($fa);
	$la = $#ROM unless defined($la);

	my($objss,$rems) = (0,0);

	print("$tag\n");
	print("$RPG\n");														# PG id
	for (my($addr)=$fa; $addr<=$la; $addr++) {  

		my($nGap) = 0;														# handle gaps
		$nGap++ while !$decoded[$addr+$nGap] && $addr+$nGap<$la;;
		if ($nGap) {
			print("G$nGap\n");
			$addr += $nGap-1;
			next; 
        }

		next unless defined($OP[$addr]);									# skip inter-op addresses

		if (defined($LBL[$addr]) && !($LBL[$addr] =~ m{[\.~]})) {			# start next object (not on BRA labels)
			$objs++;
			print(">$LBL[$addr]\n");
			print(";[$tag]\n") unless defined($REM[$addr]);					# add a tag if there is no comment
        }

		if (defined($REM[$addr])) {											# add comment
			$rems++;
			print(";[$tag] $REM[$addr]\n") 
        }

		foreach my $oi (@{$OI[$addr]}) {									# process all object info for this op
			if ($oi =~ m{^:} && defined($LBL[hex($')])) {					# address with label
				printf(":%s ",$LBL[hex($')]);
			} else {														# anything else
				print("$oi ");
			}
		}
		print("\n");
	}
	printf(STDERR "ROM PG#%02X: $objs objects with $rems comments produced\n",$RPG);
}


sub scanCode(@)																# Code Scanner
{
##	print(STDERR "scanCode(@_)\n");
	my($allowedMismatches,$pg,$lbl,$fi,$li) = @_;

	select_WPC_RPG($pg);

	my($saddr) = ($pg == 0xFF) ? 0x7FFF : 0x3FFF;							# start of match minus 1
	my($eaddr) = ($pg == 0xFF) ? 0xFFFF : 0x7FFF;							# end of match area
	$Address = $saddr;

	my(@matchData,@matchLabel,@matchREM);									# data from successful match
	my($match_lbl,$match_Address,$match_saddr);								# multiple matches check

 RESTART_SCAN:																# jump target for failed matches and checking for multiple matches
## 	printf(STDERR "RESTART_SCAN (len = %d) at %04X\n",$Address - $saddr,$saddr);
	my($mismatches,$mi); 

 	$saddr++;																# try next
	if ($saddr > $eaddr) {													# MATCH FAILED
		goto SCANCODE_SUCCESS if defined($match_lbl);
		return 0;															# never matched
	}

	$mismatches = 0; $mi = $fi;												# reset scanner data
	undef(@matchData); 
	undef(@matchLabel);
	undef(@matchREM);

N:
	for ($Address=$saddr; $mi<$li; ) {
		goto RESTART_SCAN if $Address > 0xFFFF;
		$mi++;
##		printf(STDERR "od = $objData[$mi] (@matchData) addr = %04X\n",$Address);

		if (substr($objData[$mi],0,1) eq 'G') {							# gap
			$Address += substr($objData[$mi],1);
			next;
        }

		if (substr($objData[$mi],0,1) eq ';') {							# comment
			my($ro) = $Address-$saddr;
			$matchREM[$ro] = substr($objData[$mi],1)
				unless defined($matchRem[$ro]);
			next;
		}

		foreach my $ode (split(/ /,$objData[$mi])) {
		
			if (substr($ode,0,1) eq ':') { 						# WORD
				if (length($ode) > 1) {								# with label
					my($tlbl) = substr($ode,1);
					my($tval) = WORD($Address);
					push(@matchLabel,$tlbl);
					push(@matchData,$tval);
					$Address += 2;
					if (defined($Lbl{$tlbl}) && ($Lbl{$tlbl} != $tval)) {
						$mismatches++;
						goto RESTART_SCAN if ($mismatches > $allowedMismatches);
					}
				} else {														# anonymous
					$Address += 2;
				}
				next;
			}
	
			if (substr($ode,0,1) eq '.') { 						# BYTE
				if (length($ode) > 1) {
					my($tlbl) = substr($ode,1);
					my($tval) = BYTE($Address);
					push(@matchLabel,$tlbl);
					push(@matchData,$tval);
					$Address += 1;
					if (defined($Lbl{$tlbl}) && ($Lbl{$tlbl} != $tval)) {
						$mismatches++;
						goto RESTART_SCAN if ($mismatches > $allowedMismatches);
					}
				} else {
					$Address += 1;
				}
				next;
			}
	
			for (my($j)=0; $j<int(length($ode)/2); $j++,$Address++) {		# HEX
				die("scanCode: invalid objData #$j <$ode>\n")
					unless (substr($ode,2*$j,2) =~ m{^[0-9A-f]{2}});
##				printf(STDERR "%04X: %02X (<-%s) [$mismatches]\n",$Address,BYTE($Address),substr($ode,2*$j,2))
##					if $mi>5;
##				printf(STDERR "%s vs %02X\n",substr($ode,2*$j,2),BYTE($Address));
				if (hex(substr($ode,2*$j,2)) != BYTE($Address)) {
					$mismatches++; 
					goto RESTART_SCAN if ($mismatches > $allowedMismatches);
				}
	        }
        }
	}

	#-----------------
	# Successful Match
	#-----------------

##	print(STDERR "MATCH ($mismatches)\n");
	if ($mismatches == 0) {
		if (defined($match_lbl)) {											# duplicate match
			printf(STDERR "scanCode: $match_lbl matches multiple addresses (%04X, %04X, ...) -- skipped\n",
				$match_saddr,$saddr)
					unless $saddr == $match_saddr+1;
			return -1;														# multiple matches
        }
		$match_lbl	   = $lbl;
		$match_Address = $Address;											# record first match
		$match_saddr   = $saddr;
		goto RESTART_SCAN;													# try again
    }

SCANCODE_SUCCESS:															# jump target when there is no 2nd match
	if (defined($match_lbl)) {
		$lbl 	 = $match_lbl;
		$Address = $match_Address;
		$saddr	 = $match_saddr;
		$mismatches = 0;
    }
##	printf(STDERR "scanCode: $lbl found at %04X ($mismatches)\n",$saddr);

	my($labels_defined,$comments_defined) = (0,0);							

	if ((($Address-$saddr)-$mismatches > 15) && 				# exclude short code snippets with likely multiple matches...
#			($LBL[$saddr] ne $lbl) &&									# ... already  defined labels ...
			!($lbl =~ m{^GameHook#[0-9A-F]{2}_event$})) {					# ... and automatically generated labels (GameHook#XX_event)
		$labels_defined++;
		printf("D711::setLabel('$lbl',0x%04X,0x%02X); \$D711::Address = 0x%04X; D711::def_code();\n",
			$saddr,$pg,$saddr);
		for (my($i)=0; $i<@matchData; $i++) {
			next if ($matchLabel[$i] =~ m{^RAM_[0-9A-F]{2,4}$});			# "anonymous" labels (e.g. RAM_0384) are set automatically (no need to handle here)
			next if ($LBL[$matchData[$i]] eq $matchLabel[$i]);				# label already defined
			$labels_defined++;
			printf("D711::setLabel('$matchLabel[$i]',0x%04X,0x%02X);\n",$matchData[$i],$pg);
		}																	# by the disassembler and cannot migrate over
		for (my($i)=0; $i<@matchREM; $i++) {
			next unless defined($matchREM[$i]);
			$comments_defined++;
			printf("\$D711::REM[0x%04X] = '$matchREM[$i]';\n",$saddr+$i);
	    }
	}

	return ($labels_defined,$comments_defined);
}

sub scan(@)
{
	my($trace) = 0;
	my($ld,$cd) = scanCode(0,@_);
	if (defined($cd)) {
		printf(STDERR "scanCode($_[1]): exact match\n") if $trace;
		$exact++;
		$lbldefd += $ld;
		$remdefd += $cd;
	} elsif ($ld == 0) {
		printf(STDERR "scanCode($_[1]): exact match failure (not multiple)\n") if $trace;
		($ld,$cd) = scanCode(5,@_);
		if (defined($cd)) {
			printf(STDERR "scanCode($_[1]): fuzzy match\n") if $trace;
			$fuzzy++;
			$lbldefd += $ld;
			$remdefd += $cd;
        } else {
			printf(STDERR "scanCode($_[1]): fuzzy match failure\n") if $trace;
        	$failed++;
        }
	} else {
		printf(STDERR "scanCode($_[1]): multiple match failure\n") if $trace;
		$failed++;
    }
}

sub process_object_file($)													# execute this early on, because it defines syscalls
{
	my($ofn) = @_;
	
	local(@objData);														# object file contents
	local($exact,$fuzzy,$failed) = (0,0,0);									# scan results
	local($lbldefd,$remdefd) = (0,0);

	open(OBJF,"$ofn") || die("$ofn: $!\n");									# open file and read PG id
	$_ = <OBJF>; chomp;														# tag
	$_ = <OBJF>; chomp;
	die("$ofn: page id missing\n")
		unless m/[0-9A-F]{2}/;
	my($RPG) = hex($_);
	select_WPC_RPG($RPG);

	while (<OBJF>) {														# read object data
		chop;
		next if /^#/;														# skip comments
		push(@objData,$_);
    }
	close(OBJF);	

	my($s) = 0;																# starting index
	die($objData[$s]) unless substr($objData[$s],0,1) eq '>';
	my($lbl) = substr($objData[$i],1);
	for (my($e)=1; $e<@objData; $e++) {
		if (substr($objData[$e],0,1) eq '>') {								# next label
			scan($RPG,$lbl,$s,$e-1);
			$s = $e;
			$lbl = substr($objData[$s],1);
#			print(STDERR "process_object_file: scanning for $lbl...\n");
        } 
	}
	scan($RPG,$lbl,$s,$e-1);
	print(STDERR "$ofn: $exact exact, $fuzzy fuzzy, $failed failed matches\n");
	print(STDERR "$ofn: $lbldefd labels defined, $remdefd comments added\n");
}


#----------------------------------------------------------------------
# WPC Disassembly Routines
#----------------------------------------------------------------------

sub disassemble_syscalls()													# execute this after all syscalls have been defined
{
	for (my($sc)=0; $sc<@SYSCALL; $sc++) {
		select_WPC_RPG(0x3B) if ($SC_NOTE[$sc] == 3);						# NOTE 3: syscall tied to PG#3B
		if ($decoded[$SC_ADDR[$sc]]) {
			overwriteLabel($SYSCALL[$sc],$SC_ADDR[$sc]);
		} else{ 
			disassemble_asm($code_base_indent,$SC_ADDR[$sc]);				# labels already defined
			if ($unclean) {
				print(STDERR "ERROR: $SYSCALL[$sc] did not disassemble cleanly\n")
					if $D711::verbose;
				$unclean = 0;
	        }
	    }
	}
}


sub disassemble_CPU_vectors()
{
	$Address = 0xFFF0;														# CPU vectors
	insert_divider($Address,'CPU Vectors');
	
	def_code_ptr('RESERVED_vector','RESERVED_handler','CPU Vector Handler');    
	def_code_ptr('SWI3_vector','SWI3_handler','CPU Vector Handler');
	def_code_ptr('SWI2_vector','SWI2_handler','CPU Vector Handler');		    
	def_code_ptr('FIRQ_vector','FIRQ_handler','CPU Vector Handler');
	def_code_ptr('IRQ_vector','IRQ_handler','CPU Vector Handler');
	def_code_ptr('SWI_vector','SWI_handler','CPU Vector Handler');
	def_code_ptr('NMI_vector','NMI_handler','CPU Vector Handler');			    
	def_code_ptr('RST_vector','RST_handler','CPU Vector Handler');              
}


sub disassemble_system_pointers()
{
	$Address = 0x8000;
	insert_divider($Address,'Bank Id');
	def_byte_hex('_ROMPG_SYS1_ID');
	
	insert_divider($Address,'Game Event Hooks');
	for (my($h)=0; $Address<0x812D; $h++) {
		my($taddr) = sprintf('%04X',WORD($Address));
		my($trpg) = sprintf('%02X',BYTE($Address+2));
		my($handler) = defined($Hook[$h])
				  	 ? $Hook[$h] . '_event'
				  	 : "GameHook#${h}_event";
		def_WPC_codeRef($handler,'Game Event Hook');
	}
	
	my($ubyte,$uword);
	
	$Address = 0x812D;
	insert_divider($Address,'System Data Pointers');
	$Address = def_WPC_ref('_RAM_04AF_INIT_VALUE');
		def_byte_hex();
	
	$Address = 0x813C;
	def_WPC_stringRef('sysstr_gameName','System String');
	def_WPC_stringRef('sysstr_gameNumber','System String');
	def_WPC_stringRef('sysstr_buildDate','System String');
	
	$Address = 0x813C;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x813F;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x8142;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x8145;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x814E;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x8151;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x8157;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x815A;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x8166;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_WORD_%d',++$uword));
		def_word_hex();
	
	$Address = 0x8184;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_WORD_%d',++$uword));
		def_word_hex();
	
	$Address = 0x8187;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_WORD_%d',++$uword));
		def_word_hex();
	
	$Address = 0x818A;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_WORD_%d',++$uword));
		def_word_hex();
	
	$Address = 0x8190;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_WORD_%d',++$uword));
		def_word_hex();
	
	$Address = 0x8193;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x8199;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x819C;
	$Address = def_WPC_ref('=UNKNOWN_SYSTEM_TABLE_1');
		def_wordblock_hex(8,'=UNKNOWN_SYSTEM_TABLE_1','System Table');
	
	$Address = 0x819F;
	$Address = def_WPC_ref(sprintf('_UNKNOWN_SYSTEM_BYTE_%d',++$ubyte));
		def_byte_hex();
	
	$Address = 0x81B6;
	$Address = def_WPC_ref('=BITSHIFTER_LAMPMATRIX_LOOKUPTABLE');
		def_byteblock_hex(65);
	
	$Address = 0x8296;
	def_ptr_hex('^=STATUS_AREA');
	insert_divider($Address,'System Code');
}


sub disassemble_switch_tables()
{
	$Address = 0x81C5;
	$Address = def_WPC_ref('=SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table',1);				# label already defined, follow code
	$Address = 0x821C;
	$Address = def_WPC_ref('=AUX_SWITCHTABLE');
		def_WPC_switchTable(undef,'Switch Table',1)
	        if defined($Address);
}


sub disassemble_lock_table()
{
	select_WPC_RPG(0x3B);
	$Address = $Lbl{'3B:BYU=MBD_dataRefs[A]'};
	$Address = $Lbl{'BYU=MBD_dataRefs[A]'} unless defined($Address);	# needed for labelOverrides
	if ($Address =~ m{^([0-9A-F]{2}):}) {
		die("disassemble_lock_table(): wrong page ID $1\n")
			unless ($1 eq '3B');
		$Address = hex($');
    }
	printf(STDERR "WARNING: disassemble_lock_table: syscall BYU=MBD_dataRefs[A] not found ($Address,$Lbl{'BYU=MBD_dataRefs[A]'})\n"),return
		unless numberp($Address) && ($Address>0 && $Address<0x8000);
	my($taddr) = WORD($Address+25);
	my($tpg) = BYTE($Address+28);
	die("$Address,$taddr,$tpg") unless ($tpg>=0x20 && $tpg<=0x3D);
	select_WPC_RPG($tpg);
	$Address = $taddr;
	def_WPC_lockTable('=LOCKTABLE','Multiball Device Table',1);
}

sub disassemble_font_table()
{
	die("disassemble_font_table(): not yet implemented\n");
	$Address = 0x8285;
	my($addr) = def_ptr('^sys_fontTable');
	def_WPC_fontTable('sys_fontTable','Font Table');
}


sub disassemble_DMD_table()
{
	die("disassemble_DMD_table(): not yet implemented\n");
	$Address = 0x8288;
	my($addr) = def_ptr('^sys_DMDtable');
	def_WPC_DMDTable('sys_DMDtable','DMD Table');
}

#----------------------------------------------------------------------
# Post Disassembly Magic
#	- replace JMP *+3 by &skip postfix tag of preceding JSR instruction
#	- make sleep arguments decimal
#	- add empty lines after RTS, JMP, etc.
#	- handle WPC truth values (CC=true) after predicates marked with ?
#----------------------------------------------------------------------

sub apply_magic_WPC($$)
{
	my($fa,$la) = @_;

	for (my($addr)=$fa; $addr<=$la-1; $addr++) {
		if ($OP[$addr] eq 'JMP' && $LBL[$addr+3] =~ m{^([0-9A-F]{2}:)?$OPA[$addr][0]$}) {			# 1) JMP *+3 
			undef($OP[$addr]);													# 		generate postfix tag
			push(@{$OPA[$addr-3]},'&skip');
			splice(@{$OPA[$addr]},0,1);
			undef($LBL[$addr+3])												# 		should probably also undef Lbl!
				if ($Lbl_refs{$LBL[$addr+3]} == 1);
			undef(@{$OI[$addr]});
			push(@{$OI[$addr-3]},sprintf('7E%04X',$addr+3));
		} elsif ($OP[$addr] eq '!' && $OPA[$addr][0] =~ m{leep$}) {				# 2) decimalize sleep arguments
			$OPA[$addr][1] = hex(substr($OPA[$addr][1],1,4));
		} elsif ($IND[$addr] == $code_base_indent &&							# 3) add extra space after top-level "exit" instructions
##				 (isMember($OP[$addr],'RTS','BRA','LBRA','JMP','_ENDLOOP') ||
				 (isMember($OP[$addr],'RTS','LBRA','JMP') ||
				  ($OP[$addr] eq '!' && $OPA[$addr][0] eq 'exitThread') ||
				  $REM[$addr] eq 'RTS')) {
			insert_empty_line($addr);
		} elsif ($OPA[$addr][0] =~ m{[^\?]\?$}) {								# 4) _IF_true / _IF_false
			my($noa) = $addr + 1;												#	 	execute when last arg ends with a ? but not with ??
			while (!defined($OP[$noa]) ||
				   ($OP[$noa] eq 'JMP' && $LBL[$noa+3] =~ m{^([0-9A-Z]{2}:)?$OPA[$noa][0]$})) {
				$noa++;
				die if $noa > 0xFFFF;
			}
			if    ($OP[$noa] eq '_IF_CC') { $OP[$noa] = '_IF_true'; }			# _IF_true
			elsif ($OP[$noa] eq '_IF_CS') { $OP[$noa] = '_IF_false'; }			# _IF_false
			elsif ($OP[$noa] eq 'BCC') { $OP[$noa] = '_branchIfTrue'; }			# _branchIfTrue
			elsif ($OP[$noa] eq 'BCS') { $OP[$noa] = '_branchIfFalse'; }		# _branchIfFalse
		}
	}
}

#----------------------------------------------------------------------
# Init Disassembly System
#----------------------------------------------------------------------

sub init_WPC(@)
{
	my(@linc) = @_;
	
	require 'WPC.API';														# load API after ROM has been loaded but before -i are processed
	while (@linc) {
		require './' . shift(@linc);
	}

	select_WPC_RPG($start_page,2);
}

#======================================================================
# WPC Disassembly Library
#======================================================================

#----------------------------------------------------------------------
# ROM Paging
#----------------------------------------------------------------------

sub select_WPC_RPG($@)
{
	my($RPG,$caller) = @_;
##	printf(STDERR "select_WPC_RPG(%02X) [caller=$caller, _cur_RPG=%02X]\n",$RPG,$_cur_RPG);
	
	if (!defined($RPG) || !numberp($RPG) || ($RPG != 0xFF && ($RPG<0 || $RPG>0x3D))) {
		if (numberp($RPG)) {
			die(sprintf("select_WPC_RPG(%02X): bad page id\n",$RPG))
		} else {
			die(sprintf("select_WPC_RPG($RPG): bad page id\n"))
		}
	}
		
	return $_cur_RPG if ($RPG == 0xFF || $RPG == $_cur_RPG);
	die unless defined($RPG);
	
	@{$OPPG[$_cur_RPG]} 	 	= @OP[0x4000..0x7FFF];									# swap out active page
	@{$INDPG[$_cur_RPG]}	 	= @IND[0x4000..0x7FFF]; 		    
	@{$TYPEPG[$_cur_RPG]}	 	= @TYPE[0x4000..0x7FFF];		    
	@{$OPAPG[$_cur_RPG]}	 	= @OPA[0x4000..0x7FFF]; 		    
	@{$OIPG[$_cur_RPG]}		 	= @OI[0x4000..0x7FFF]; 		    
	@{$REMPG[$_cur_RPG]}	 	= @REM[0x4000..0x7FFF]; 		    
	@{$EXTRAPG[$_cur_RPG]}	 	= @EXTRA[0x4000..0x7FFF]; 		    
	@{$EXTRA_INDPG[$_cur_RPG]}	= @EXTRA_IND[0x4000..0x7FFF]; 		    
	@{$EXTRA_BEFORE_LABELPG[$_cur_RPG]}	= @EXTRA_BEFORE_LABEL[0x4000..0x7FFF]; 		    
	@{$EXTRA_AFTER_OPPG[$_cur_RPG]}		= @EXTRA_AFTER_OP[0x4000..0x7FFF]; 		    
	@{$LBLPG[$_cur_RPG]}	 	= @LBL[0x4000..0x7FFF]; 		    
	@{$AUTO_LBLPG[$_cur_RPG]} 	= @AUTO_LBL[0x4000..0x7FFF]; 		    
	@{$decodedPG[$_cur_RPG]} 	= @decoded[0x4000..0x7FFF];
	@{$DIVIDERPG[$_cur_RPG]} 	= @DIVIDER[0x4000..0x7FFF];
	@{$ROMPG[$_cur_RPG]}	 	= @ROM[0x4000..0x7FFF]
		unless(@{$ROMPG[$_cur_RPG]});
    
	@OP[0x4000..0x7FFF]			= @{$OPPG[$RPG]};										# swap in new page
	@IND[0x4000..0x7FFF] 		= @{$INDPG[$RPG]};
	@TYPE[0x4000..0x7FFF]		= @{$TYPEPG[$RPG]};
	@OPA[0x4000..0x7FFF] 		= @{$OPAPG[$RPG]};
	@OI[0x4000..0x7FFF] 		= @{$OIPG[$RPG]};
	@REM[0x4000..0x7FFF] 		= @{$REMPG[$RPG]};
	@EXTRA[0x4000..0x7FFF] 		= @{$EXTRAPG[$RPG]};
	@EXTRA_IND[0x4000..0x7FFF]	= @{$EXTRA_INDPG[$RPG]};
	@EXTRA_BEFORE_LABEL[0x4000..0x7FFF] = @{$EXTRA_BEFORE_LABELPG[$RPG]};
	@EXTRA_AFTER_OP[0x4000..0x7FFF] 	= @{$EXTRA_AFTER_OPPG[$RPG]};
	@LBL[0x4000..0x7FFF] 		= @{$LBLPG[$RPG]};
	@AUTO_LBL[0x4000..0x7FFF] 	= @{$AUTO_LBLPG[$RPG]};
	@decoded[0x4000..0x7FFF] 	= @{$decodedPG[$RPG]};
	@DIVIDER[0x4000..0x7FFF] 	= @{$DIVIDERPG[$RPG]};
	if (@{$ROMPG[$RPG]}) {
		@ROM[0x4000..0x7FFF]	= @{$ROMPG[$RPG]};										# copy from page buffer
	} else {
		load_ROM($ARGV[0],0x4000,$RPG,16);												# load from file
	}
	
	my($oRPG) = $_cur_RPG;
    $_cur_RPG = $RPG;

	unless ($decoded[0x4000]) {															# decode page id first time a page is referenced
		my($oA) = $Address;
		$Address = 0x4000;
		def_byte_hex('_ROMPG_ID',sprintf('ROM PAGE %02X',$_cur_RPG));
		push(@{$OI[0x4000]},sprintf('%02X',BYTE(0x4000)));								# this should eventually move into def_byte_hex()
		$Address = $oA;
	}
	
    return $oRPG;
}

#----------------------------------------------------------------------
# Lock Table / Multiball Device Table
#----------------------------------------------------------------------

sub def_WPC_lockTable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_lockTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of locks, bytes per lock' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($lck)=0; $lck<$rows; $lck++) {
		$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
		$OP[$Address] = '.DW';
		my($daddr) = WORD($Address);
			my($dlbl) = $LBL[$daddr];
			$dlbl = sprintf('Lock#%02X_data',$lck) unless defined($dlbl);
		    setLabel($dlbl,$daddr);
		push(@{$OPA[$Address]},sprintf('$%04X',$daddr));
		$REM[$Address] = 'pointer to lock definition data (4-10 bytes)' if !defined($REM[$Address]) && $lck==0;
	    $decoded[$Address++] = $decoded[$Address++] = 1;

	    my($sa) = $Address;
	    $Address = $daddr;

		my($taddr,$trpg);
		$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
		$REM[$Address] = sprintf('Lock#%02X',$lck) if !defined($REM[$Address]);
		$OP[$Address] = '.DBR';
		push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address)));
		push(@{$OPA[$Address]},sprintf('$%04X',$taddr=WORD($Address+1)));
		push(@{$OPA[$Address]},sprintf('$%02X',$trpg=BYTE($Address+3)));
	    $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
		if ($lck == 1) {
			$OP[$Address-4] = '.DBRWB';
			push(@{$OPA[$Address-4]},sprintf('$%04X',WORD($Address)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+2)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+3)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+4)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+5)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+6)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = 1;
		} elsif ($lck > 1) {
			$OP[$Address-4] = '.DBRB';
			push(@{$OPA[$Address-4]},sprintf('Switch#%02X',BYTE($Address)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+1)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+2)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+3)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+4)));
			push(@{$OPA[$Address-4]},sprintf('$%02X!',BYTE($Address+5)));
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
			$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;
		}

	    if ($follow_code) {
	    	my($srpg) = select_WPC_RPG($trpg,8);
	    	insert_divider($taddr,'Lock Event Handler');
			my($tlbl) = $LBL[$taddr];
			$tlbl = sprintf('Lock#%02X_handler',$lck) unless defined($tlbl);
		    setLabel($tlbl,$taddr);
			disassemble_asm($code_base_indent,$taddr,$tlbl,undef,$follow_code);
			select_WPC_RPG($srpg,9);
	    }

	    $Address = $sa;
    }
    insert_empty_line($Address-2);
}

#----------------------------------------------------------------------
# Switch Table
#----------------------------------------------------------------------

sub def_WPC_switchTable(@)
{
	my($lbl,$divider_label,$follow_code) = @_;
#	print(STDERR "def_WPC_switchTable(@_)\n");

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	if (defined($lbl)) {
		$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$}); 								
	    setLabel($lbl,$Address);
	}
    
	insert_divider($Address,$divider_label);

	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$OP[$Address] = '.DWB';
	my($rows,$cols) = (WORD($Address),BYTE($Address+2));
	push(@{$OPA[$Address]},$rows);
	push(@{$OPA[$Address]},$cols);
	$REM[$Address] = 'number of switches, bytes per switch' unless defined($REM[$Address]);
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

	for (my($sw)=0; $sw<$rows; $sw++) {
#		print(STDERR "sw = $sw\n");
		my($opaddr) = $Address;
		$IND[$opaddr] = $data_indent; $TYPE[$opaddr] =  $CodeType_data;
		$OP[$opaddr] = '.DBBRB';
		$REM[$opaddr] = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;

		my($ta,$tp) = (WORD($Address),BYTE($Address+2));
		my($swn) = defined($Switch[$sw]) ? $Switch[$sw] : sprintf('Switch#%02X',$sw);
		push(@{$OPA[$opaddr]},label_address($ta,$swn.'_handler',1));		# suppress address suffix in label
		push(@{$OPA[$opaddr]},sprintf('$%02X',$tp));
		WPC_codeRef($swn.'_handler',"Switch Handler ($swn)",$follow_code);
		$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('Lamp#%d',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
		push(@{$OPA[$opaddr]},sprintf('$%02X!',BYTE($Address))); $decoded[$Address++] = 1;
	}
    insert_empty_line($Address-11);
}   
		    
#----------------------------------------------------------------------
# References
#	- loads RPG
#----------------------------------------------------------------------

sub def_WPC_ref($@)														# DOES NOT MAINTAIN RPG
{																			
	my($pointee_lbl,$rem) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die(sprintf("def_WPC_ref(%04X,$lbl): addresses below 0x8000 not supported (implementation restriction)",$Address))
    	unless ($Address >= 0x8000);

	my($pointee_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
#	printf(STDERR "def_WPC_ref: %02X:%04X\n",$RPG,$pointee_addr);
	select_WPC_RPG($RPG,3)
		unless ($RPG == 0x00);																# NULL ref

	$pointee_lbl = $` if ($pointee_lbl =~ m{\[[0-9A-F]{2}\]$});            					# remove previous RPG if there is one
	setLabel("^$pointee_lbl",$Address);
	
	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $codeType_data;
	if ($pointee_addr == 0x0000) {
		$OPA[$Address][0] = '$0000';
		$OPA[$Address][1] = '$00';
	} else {
		my($usr_lbl) = $LBL[$pointee_addr];
		$pointee_lbl = $usr_lbl if defined($usr_lbl);
		setLabel($pointee_lbl,$pointee_addr);
		$OPA[$Address][0] = $pointee_lbl; 
		$OPA[$Address][1] = sprintf('$%02X',$RPG);
	}
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	return $pointee_addr;
}

#----------------------------------------------------------------------
# Strings
#----------------------------------------------------------------------

sub decode_WPC_STR_char($)
{
	my($c) = BYTE($_[0]);

	return sprintf('%c',$c)																		# printable ASCII
		if ($c >= 32 && $c < 127);
	return sprintf('\\%02X',$c);																# non-printable
}

sub def_WPC_string(@)
{
	my($lbl,$divider_label,$rem) = @_;

	die unless defined($Address);
	return if ($decoded[$Address]);												
	return if defined($OP[$Address]);

	insert_divider($Address,$divider_label);
	$lbl = $` if ($lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one
	setLabel($lbl,$Address);
    $Address+=$len,return unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    
	$IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$OP[$Address] = '.STR';
	my($o);
	$OPA[$Address][0] = "'";
	for ($o=0; BYTE($Address+$o)!=0; $o++) {
		$OPA[$Address][0] .= decode_WPC_STR_char($Address+$o);
		$decoded[$Address+$o] = 1;
	}
	$decoded[$Address+$o] = 1;
	$OPA[$Address][0] .= "'";
	$Address += $o;
}   
		    
sub def_WPC_stringRef($@)														# DOES NOT MAINTAIN RPG
{																			
	my($str_lbl,$divider_title,$rem) = @_;
	die unless defined($Address);

    die unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);
    die(sprintf("def_WPC_stringRef(%04X,$str_lbl): addresses below 0x8000 not supported (implementation restriction)"))
    	unless ($Address >= 0x8000);

	my($str_addr) = WORD($Address);
	my($RPG) = BYTE($Address+2);
	select_WPC_RPG($RPG,4);

	$str_lbl = $` if ($str_lbl =~ m{\[[0-9A-F]{2}\]$});            					# remove previous RPG if there is one
	setLabel("^$str_lbl",$Address);
	
	my($usr_lbl) = $LBL[$str_addr];
	$str_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($str_lbl,$str_addr);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $codeType_data;
	#$OPA[$Address][0] = $str_lbl;
	push(@{$OPA[$Address]},label_address(WORD($Address),$str_lbl,1));        # suppress address suffix in label
    push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
	$REM[$Address] = $rem unless defined($REM[$Address]); 
	$decoded[$Address] = $decoded[$Address+1] = $decoded[$Address+2] = 1;

	my($sAddr) = $Address;
	$Address = $str_addr;
	def_WPC_string($str_lbl,$divider_title);
	$Address = $sAddr + 3;
}

#----------------------------------------------------------------------
# Code
#----------------------------------------------------------------------

sub WPC_codeRef($@)
{
	my($code_lbl,$divider_label,$follow_code) = @_;
	my($code_addr) = WORD($Address);

	my($RPG) = BYTE($Address+2);
	my($orpg) = select_WPC_RPG($RPG,5);

	label_address($code_addr,$code_lbl,1);												# suppress address suffix in label

	$code_lbl = $` if ($code_lbl =~ m{\[[0-9A-F]{2}\]$});             					# remove previous RPG if there is one

	my($usr_lbl) = $LBL[$code_addr];
	$code_lbl = $usr_lbl if defined($usr_lbl);
	setLabel($code_lbl,$code_addr);

	disassemble_asm($code_base_indent,$code_addr,$code_lbl,$divider_label,$follow_code);
#	die if $unclean;

	select_WPC_RPG($orpg,6);
#	return $Address-3;
}

sub def_WPC_codeRef($@)																	# ROUTINE DOES NOT MAINTAIN RPG
{
	my($code_lbl,$divider_title,$rem) = @_;
	die unless defined($Address);

	setLabel("^$code_lbl",$Address);
    die(sprintf("def_WPC_codeRef: address \$%04X outside valid ROM range (\$%04X-\$%04X)\n",
    	$Address,$MIN_ROM_ADDR,$MAX_ROM_ADDRESS))
			unless ($Address>=$MIN_ROM_ADDR && $Address<=$MAX_ROM_ADDR);

	$OP[$Address] = '.DWB'; $IND[$Address] = $data_indent; $TYPE[$Address] =  $CodeType_data;
#	push(@{$OPA[$Address]},label_address(WORD($Address),$code_lbl,1));        			# suppress address suffix in label
	push(@{$OPA[$Address]},sprintf('$%04X',WORD($Address)));        			# suppress address suffix in label
    push(@{$OPA[$Address]},sprintf('$%02X',BYTE($Address+2)));
	$REM[$Address] = $rem unless defined($REM[$Address]);

	WPC_codeRef($code_lbl,$divider_title);    
	$decoded[$Address++] = $decoded[$Address++] = $decoded[$Address++] = 1;

}

#======================================================================
# Utilities
#	- used in .defs files to define game-specific ids
#	- .def file is loaded during init_WPC()
#======================================================================

$Switch[0] = 'SW_UNUSED';

sub defSwitch($$)
{
	my($no,$name) = @_;

	die("defSwitch: invalid switch number $no\n")
		unless ($no>=1 && $no<=64);
	$Switch[$no] = $name;
}

sub defLamp($$)
{
	my($no,$name) = @_;

	die("defLamp: invalid lamp number $no\n")
		unless ($no>0 && $no<=64);
	$Lamp[$no] = $name;
}

sub defGroup($$)
{
	my($no,$name) = @_;

	die("defGroup: invalid group number $no\n")
		unless ($no>0 && $no<=64);
	$BitGroup[$no] = $name;
}

sub defFlag($$)
{
	my($no,$name) = @_;

	die("defFlag: invalid flag number $no\n")
		unless ($no>0 && $no<=0x80);
	$Flag[$no] = $name;
}

if (0) {
sub defSolenoid($$)
{
	my($no,$name) = @_;

	die("defSolenoid: invalid solenoid number $no\n")
		unless ($no>0 && $no<=0x65);
	my($no,$name) = @_;
	$Sol[$no] = $name;
}
}

sub defSolCmd($$)
{
	my($no,$name) = @_;

	die("defSolCmd: invalid solenoid command number $no\n")
		unless ($no>=0 && $no<=0xFF);
	my($no,$name) = @_;
	$Sol[$no] = $name;
}

sub defLabel($$$)
{
	my($pg,$addr,$lbl) = @_;

	select_WPC_RPG($pg,7);
	define_label($lbl,$addr);
}

sub defAdjustment($$)
{
	my($no,$name) = @_;

	die("defAdjustment: invalid adjustment number $no\n")
		unless ($no>0 && $no<=0xFFFF);
	$Adj[$no] = $name;
}

sub defAudit($$)
{
	my($no,$name) = @_;

	die("defAudit: invalid audit number $no\n")
		unless ($no>=0 && $no<65);
	$Audit[$no] = $name;
}

sub defThread($$)
{
	my($no,$name) = @_;

	die("defThread: invalid thread id\n")
		unless ($no>0 && $no<=0xFFFF);
	$Thread[$no] = $name;
}

sub defDMD($$)
{
	my($no,$name) = @_;

	die("defDMD: invalid DMD animation\n")
		unless ($no>0 && $no<=0xFFFF);
	$DMD[$no] = $name;
}

#----------------------------------------------------------------------
#	Define System Calls
#
# 	$note ARGUMENTS:
#		1: routine does not return
#----------------------------------------------------------------------

sub define_syscall($$@)
{
	my($lbl,$addr,$args,$note) = @_;
	$args = '' unless defined($args);

	define_label($lbl,$addr);
	push(@SYSCALL,$lbl);
	$SC_ADDR[$#SYSCALL] = $addr;
	$SC_ARGS[$#SYSCALL] = $args;
	$SC_NOTE[$#SYSCALL] = $note;
}

1; 																# return true

